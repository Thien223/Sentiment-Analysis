<language> Korean </language>
<textcode> KSC-5601-1988 </textcode>
<process> raw </process>
<version> 2001(or)</version>
<filename> kaistcorpus_written_raw_or_academic_paper96_nc.txt </filename>
<title> Controlled Timed 페트리네트를 이용한 유연생산셀의 모형화  및 실시간 통제에 관한 연구 </title>
<author> 이영창 </author>
<date> 1994</date>
<publisher> 서울대학교 </publisher>
<kdc> TM530.969 </kdc>
<tdmsfiletext>
제 1 장.  서   론  

 1-1.  연구배경

소비자의 수요욕구가 급변하고 경쟁이 점점 더 치열해지는 최근의 경향 때문에 각 기업들은 공장자동화와 통합된 정보시스팀의 구축에 관심을 기울이고 있다. 이러한 결과로 유연생산시스팀(Flexible Manufacturing System : FMS)과 컴퓨터통합생산시스팀(Computer Integrated Manufacturing System : CIMS)에 대한 관심이 고조되고 있다. 그런데 이러한 생산시스팀들은 이산현상시스팀의 특성을 띠고 있다. 따라서 FMS나 CIMS등을 통합해서 운영하고 제어하기 위해서는 이산현상시스팀을 이해해야 하며 이산현상시스팀을 모형화하고 통제할 수 있는 정형화된 방법론이 필요하게 된다. 
이산현상시스팀(Discrete Event System:DES)은 일련의 물리적인 사건들이 일정하지 않은 간격으로 급작스럽게 비동기적으로 발생하는 시스팀이다. 이산현상시스팀은 비동기성(asynchronous), 상충현상(conflict), 동시성(concurrency)의 특징을 가진다[Ramadge and Wonham, 87].
이산현상시스팀을 모형화하고 통제하기 위한 여러 가지 정형화된 기법들이 연구되어 왔다. 이러한 기법들 중에는 페트리네트를 이용한 모형화 기법이나 State Machine을 이용한  Supervisory control기법 등이 있다. 페트리네트는 그래픽한 묘사능력이 뛰어나기 때문에 비동기성이나 상충현상, 동시성등의 특징을 지닌 복잡한 생산시스팀을 모형화 하기에 적합하다. 그러나 이러한 강력한 모형화 능력에 대한 대가로 상대적으로 의사결정(decision) 힘은 약하다. 반면에 Supervisory control기법은 의사결정 힘은 강하지만 상대적으로 모형화 힘은 약하다. 즉 순차적으로 발생하는 사건들을 묘사하기에는 적합하지만  동시에 발생하는 여러 가지 사건들을 묘사하기에는 적합하지 못하다.[Fei-Yue, 92]
 이산현상시스팀의 통제에 있어서 시스팀의 상태가 좋지 않은 상태(forbidden state)로 흘러가는 것을 방지하고 바람직하지 않은 사건이 발생하는 것을 방지하는 것은 중요한 일이다. 시스팀의 성능을 평가하고 시스팀의 논리적인 행위를 분석하고 통제하기 위한 여러 가지 모형화 기법 및 시뮬레이션 기법이 개발되어 왔다. 그러나 이러한 기법들에 적용되는 통제논리는 주로 시스팀 설계자나 시스팀 분석자의 경험이나 직관에 의지하는 시행착오적인 방법에 의한 것들이 대부분이었다. 따라서 시스팀이 달라질 때마다 새로운 시스팀을 모형화해야 했으며 이에 따라 새로운 통제논리를 구성해야 하는 단점이 있었다.  그러므로 이러한 단점을 보완하고 시스팀이 좋지 않은 상태로 흘러가는 것을 방지하기 위해서는 통제시스팀의 구성요소를 Plant 와 Supervisor로 나누는 생각하는 것이 일반적이다. 이때 Plant는 통제의 대상이 되며 대상시스팀에서 발생 가능한 모든 사건에 의한 상태변화를 묘사한다. Supervisor 는 Plant로부터 발생하는 사건에 대해서 그때그때 적절한 통제패턴을 Plant에 보내주어 시스팀이 바람직한 방향으로 흘러갈 수 있도록 하는 통제기(Controller)의 역할을 한다. 이러한 통제구조의 개념을 이용한 통제는 최근에 들어 활발하게 이루어지고 있다. [Ramadge and Wonham, 87]
생산시스팀이나 통신시스팀들은 성능(performance)이나 행위(behavior)들이 시간적 제약에 아주 민감한 실시간(real-time) 시스팀이다. 따라서 이처럼 시간이 시스팀의 논리적 행위에 큰 영향을 미치는 시스팀의 경우 시스팀을 모형화하고 통제하는데 시간개념을 추가하는 것이 필요하다[Ostroff, 89]. 

 1-2.  연구의 목적

본 연구는 이산현상시스팀의 하나인 유연생산셀을 실시간 통제하기 위해서 Controlled Timed 페트리네트를 이용한다. 그런데 생산 시스팀은 시간에 따라서 영향을 받을 수 있는 시간 종속적인 시스팀이다. 따라서 모형의 논리적 행위(Logical Behavior) 뿐만 아니라 시간의 변화에 따른 시간적 행위(Timed Behavior)도 묘사해 주어야 한다. 그러나 기존의 페트리네트를 이용한 연구들은 시스팀의 논리적 행위만을 묘사해 주는 것이 대부분이었다. 시간적 행위를 묘사하기 위해서 페트리네트에 시간 개념을 고려하기도 하였지만 이러한 경우에도 시간개념이 들어간 페트리네트는 주로 대상시스팀의 모형화나 성능 분석에 주로 쓰였다.  따라서 본 논문에서는 시간개념을 모형화 뿐만 아니라 통제에도 이용하고자 한다. 
생산 시스팀이 작동할 때 발생하는 여러 가지 사건들 중에는 기계 가공을 시작하는 사건과 같은 통제 가능한 사건들도 있고, 기계가공을 종료하는 사건이나 기계 고장이 발생하는 사건과 같은 통제가 가능하지 않은 사건들도 있다. 따라서 시스팀을 통제하는 경우 사건의 종류에 따라 서로 다른 통제가 필요하게 된다. 즉 우리가 통제시스팀을 이용하여 통제할 수 있는 사건들은 통제가능한 사건들일 뿐이다. 그러므로 시스팀을 통제하기 위한 목적으로 페트리네트를 이용하여 대상시스팀을 모형화 하는 경우 이러한 사건의 종류를 구분해 주는 것이 필요하다.  
페트리네트의 경우 페트리네트를 이용하여 대상시스팀을 모형화한 모형이 만들어 지면 이 모형에는 어느 정도의 통제 논리가 포함되어 함께 표현되게 된다. 그러나 생산시스팀에서는 다양한 종류의 부품 그룹이 존재하며 이 부품 그룹들이 서로 다른 공정경로(Route)를 가질 수 있다. 또 같은 부품 그룹내의 부품이라 할지라도 서로 다른 공정경로를 가질 수 있게 된다. 따라서 이러한 다양한 부품들이 공정경로상에서 막힘이 없이 각자의 공정경로상의 모든 작업을 끝마치는 것이 필요하다. 이러한 통제를 수행하기 위해서 Controlled Timed 페트리네트를 이용하여 시스팀의 행위를 파악하면서 적절한 통제를 수행하고자 한다.


본 논문의 목적을 요약하면 다음과 같다. 

     Controlled Timed 페트리네트를 이용한 유연생산셀의 모형화
        - 트랜지션에 시간을 부여
        - 트랜지션을 통제 가능한 것과 통제 가능하지 않은 것으로 구분
     시간개념을 이용한 유연생산셀의 통제
     부품의 종류와 공정경로(Route)를 고려한 유연생산셀의 통제
     데드락 발견 및 해결

 제 2 장.  연구현황

 2-1.  기존의 연구

생산시스팀을 모형화하고 통제하기 위한 기존의 연구로는 크게 수학적(Analytic)모형과 State Machine을 이용한 모형 그리고 페트리네트(Petri Net)를 이용한 모형으로 나누어 볼 수 있다.  
수학적 모형으로는 수리계획법을 이용한 모형, Queueing Network을 이용한 모형, 섭동분석(Perturbation Analysis)을 이용한 모형등이 있다. 이러한 모형은 생산시스팀을 수학식을 이용해서 표현한다. 그러나 이러한 모형들은 시스팀의 동적인 상황에 능동적으로 반응하지 못하므로 주로 시스팀의 성능분석 및 성능평가 그리고 최적화에 주로 쓰인다.
State Machine을 이용한 모형으로는 Ramadge 와 Wonham에 의해서 제안된 Supervisory Control 모형이 있다[Ramadge and Wonham, 87]. Supervisory Control 모형은 생산시스팀이나 통신시스팀, 데이타베이스 시스팀과 같이 시스팀내에서의 사건의 발생이 비동기적이고 비확정적인 이산현상시스팀을 모형화하고 통제하기 위해서 개발된 것이다. Supervisory Control에서는 통제의 대상이 되는 객체인 Plant와 Plant를 통제하는 Supervisor를 구분한다. Plant에서 일어날 수 있는 사건들을 통제가능한 사건과 통제 불가능한 사건으로 구분한다. 또 Plant에서 물리적으로 발생할 수 있는 모든 사건들의 순열(Physically possible sequence of events)과 통제자가 원하는 사건들의 순열(Legal sequence of events)을 분리한다. Supervisor는 Plant를 계속해서 지켜보면서  Plant에서 어떤 사건이 발생함에 따라 Plant의 상태가 바뀌는 경우 자신의 상태를 바꾸어 가면서 Plant에 적절한 통제패턴을 보내주게 된다. 이에 따라 Plant는 Supervisor가 원하는 방향으로 움직이게 되는 것이다. Supervisoey Control 에서 해결하는 문제들은 크게 부적절한 사건의 발생 금지(Illigal String Prevention)와 바람직하지 않은 상태로의 전이방지(Forbidden State Prevention)로 나눌 수 있다.
그러나 Supervisory Control은 State Machine을 이용하여 시스팀을 모형화하고 통제하기 때문에 여러 가지 사건들이 동시에 발생하는 경우(Concurrency)를 적절하게 묘사하지 못한다. 또 시간 개념을 고려하기가 수월하지 않으며 그래픽한 묘사능력이 페트리네트보다 떨어지기 때문에 모형을 보고 전체적인 상황을 이해하는 것이 페트리네트의 경우보다 떨어진다. 따라서 다양한 생산환경을 무리없이 묘사해 내기에는 모형화 힘이 약하다고 할 수 있다.  또 시스팀의 크기가 커짐에 따라 고려해야 할 상태의 수가 지수적으로 증가하는 단점이 있다.  
페트리네트를 이용한 모형은 비동기성(Asynchronous), 상충현상(Conflict), 동시성(Concurrency)등을 쉽게 표현할 수 있는 장점 때문에 이산현상시스팀의 행위를 표현하는데 적합한 것으로 알려져 왔다[Peterson, 76]. 이에 따라 페트리네트를 사용한 생산시스팀의 모형화 및 통제에 대한 연구가 많이 수행되었다. 
Zhou 와 DiCesare는 페트리네트를 이용하여 FMS를 모형화하여 통제하는 것을 시도하였다[Zhou and DiCesare, 90]. 이밖에도 여러 사람들이 생산시스팀을 모형화하고 통제하는데  페트리네트를 이용하였다. 이들이 모형화에 사용한 페트리네트는 다양한 종류의 부품이나 기계등을 구별할 수 없었기 때문에 토큰의 종류를 다양화 시키고 트랜지션에 입/출력 함수를 부여하여 모형화 힘을 증가시키는 Colored 페트리네트에 대한 연구가 진행되었다.  
Colored 페트리네트를 이용한 FMS의 모형화 및 통제에 대한 기존의 연구로는 다음과 같은 것들이 있다. N.Viswanadham 과 Y.Narahari는 FMC를 모형화하는데 Colored 페트리네트를 이용하였다[Viswanadham and Narahari, 87]. 이 연구는 이후의 Colored 페트리네트를 이용한 FMS의 통제의 초석이 되었다. 
Hang Pang Hung 과 Pochu Chang는 CNC 선반, CNC 밀링 기계, 로봇, 팔레트 저장소로 구성된 FMC를  모형화 하고 시뮬레이션 하기 위해서 Colored Timed 페트리네트를 사용하였다[Hang and Pochu ,92]. 이 연구에서는 트랜지션을 트랜지션이 활성화되어 발화될 때 소요되는 시간이 없는 Immediate transition과 트랜지션이 활성화(enabled)된 후 발화(firing)될 때 일정한 시간이 소요되는 Timed transition 으로 구분하였다. 10가지의 dispatching  rule을 사용한 스케줄링에 대해서 시뮬레이션을 수행하여 각각의 dispatching rule을 평가하였다. 그러나 이 연구에서는 시간이 통제의 수단으로 쓰이지는 않았다.
Cossins 과 Ferreira는 Colored 페트리네트를 이용하여 Planning CPN, Cell CPN, Transport CPN의 3 종류의 페트리네트를 구분하여 FMS를 시뮬레이션하고 통제하고자 하였다[Cossins and Ferreira, 92]. 페트리네트간의 신호교환을 위한 신호 플레이스를 도입하였으며 시뮬레이션을 위한 사용자의 입력을 받아들이기 위한 모듈을 두었으며 페트리네트 상에서 일어나는 상충을 해결하기위한 스케쥴러모듈을 두었다. 또  실시간 표시를 위한 모듈을 두었으며 통계치 보고 모듈도 두었다. 
김기범은 페트리네트를 이용한 유연생산시스팀 설계에 관한 연구에서 Colored  and Timed 페트리네트를 사용하여 ASRI FMS공장의 디자인을 위한 시뮬레이션 모형을 개발하였다[김기범, 92]. 
이밖에도 Ramadge 와 Wonham이 제안한 Supervisory Control의 개념을 페트리네트에 적용하려는 논문들이 최근에 들어 나타나기 시작했다. Ushino 와 Matsumoto는 페트리네트에 Supervisory Control의 개념을 적용하기 위하여 외부입력 플레이스를 도입하였다[Ushino and Matsumoto, 88].  
Giua 와 DiCesare는  Supervisory Control 이론을 페트리네트를 이용하여 구현하고자 하였다[Giua and DiCesare, 91]. 
 Krogh 와 Holloway는 Controlled Petri Net의 일종인 Controlled Marked Graph를 이용하여 Forbidden State 문제를 모형화하고 통제논리를 합성하는 연구를 하였다[Krogh and Holloway, 91]. 이 연구에서는 금지된 상태(Forbidden state)를 표현할 때의 state의 수를 줄이기 위한 방법으로 집합조건(Set Condition)이라는 개념을 사용하였다. 그러나 이 방법은 페트리네트의 플레이스와 트랜지션이 Marked Graph로 표현될 경우에만 사용 가능하다.
Sathey 와 Krogh 는 페트리네트의 트랜지션에 발화시간간격을 부여하여 FMC를 통제하고자 하였다[Sathaye and Krogh, 92]. 그러나 트랜지션에 부여된 발화시간이 간격으로 주어질 때에는 주어진 발화간격중의 어느 시점에서 사건이 발생하느냐에 따라 이후의 시스팀의 상태가 달라지기 때문에 통제의 목적으로 사용하기에는 부적합하다. 


 2-2.  기존연구의 한계

페트리네트를 이용한 이산현상시스팀의 연구에 대한 많은 논문들 중에서 시간을 고려한 논문을 상대적으로 많지 않았다. 또 시간을 고려한 논문이라 하더라고 주로 대상시스팀을 분석하거나 시뮬레이션을 통한 대상시스팀의 성능을 평가하기 위한 목적으로 시간을 고려했다. 이산현상시스팀을 통제한다는 측면에서 본다면 시간 개념을 도입하는 예는 많지 않았다. 시스팀을 통제하는 데 시간개념을 도입하는 경우에도 트랜지션에 부여되는 발화시간을 시간간격으로 주는 경우에는 발화시간 간격의 어느 시점에서 트랜지션이 발화하는냐에 따라 이후의 시스팀의 상태가 달라지기 때문에 시스팀을 통제하는 데에는 무리가 있었다. 더구나 시간을 고려하면서 동시에 다양한 공정경로를 가진 다양한 부품이 시스팀 내에서 흘러가는 것을 묘사하면서 통제하는 것에 대한 연구는 미흡했다. 그러나 실제 시스팀에서 발생하는 사건들 은 일정한 시간을 필요로 하고, 시스팀 내에는 다양한 종류의 부품이 서로 다른 공정경로를 가지면서 흘러 다닌다. 따라서 대상시스팀을 모형화하고 통제할 때 이러한 점을 고려해야 한다.
기존의 연구는 또 시스팀이 데드락과 같은 좋지 않은 방향으로 흘러가는 것을 방지하고, 데드락 상황에 직면했을 때 이를 해결하는 방안에 대한 연구가 미흡했다. 데드락 방지를 고려한 논문도 다양한 부품의 종류나 부품의 공정경로등을 고려하지 않았다. 그러나 실제로 다양한 부품이 각각의 공정경로를 따라 시스팀 내를 돌아다닐 때에는 복잡한 양상을 보이게 되기 때문에 데드락과 같은 좋지 않은 상황이 발생할 가능성이 높아진다. 따라서 이러한 상황이 발생하는 것을 미리 파악하여 방지하면서 시스팀을 통제하는 것이 필요하게 된다. 

 제 3 장.  Controlled Timed 페트리네트를 이용한 모형화 및 통제

본 장에서는 본 논문에서 이루고자 하는 통제를 달성하기 위해서 필요한 Controlled Timed 페트리네트에 대해서 설명한다. 

 3-1.  페트리네트의 개요

페트리네트는 1962년 페트리가 통신시스팀을 모형화하고 해석하기 위해서 개발한 기법으로 여러 가지 특징을 가진 시스팀을 그래픽하게 모형화하는데 유용한 기법이다. 페트리네트는 동시성(Concurrency), 비동기성(Asynchronous), 비확정성(Non-deterministic), 상충현상(Concurrency) 등을 표현하는 것이 용이하다. 페트리네트에서 시스팀의 상태나 시스팀의 행위는 토큰(Token)의 분포나 이동상황을 통해서 알 수 있다. 토큰(Token)은 부품이나 기계 같은 자원(Resource) 또는 개체(Entity)등을 의미하며 토큰의 분포에 따라 시스팀의 상태를 알 수 있으며, 시스팀의 상태가 바뀌게 되면 적절하게 토큰을 이동시킴으로서 시스팀의 상태가 바뀌었다는 것을 나타내게 된다. 
페트리네트에서 플레이스는 원으로 표시되며, 각각의 트랜지션은 막대로 표시된다. IN(P,T) = 1 이면 플레이스 P 에서 트랜지션 T 로 향하는 호가 있음을 의미하며, OUT(P,T) = 1 이면 트랜지션 T 에서 플레이스 P 로 향하는 호가 있음을 의미한다. 

일반적으로 페트리네트는 다음과 같이 정의한다.


      
 
      이때 
      
      
      
      
            


앞에서 언급한 것처럼 페트리네트에서 시스팀의 상태변화는 토큰의 위치나 분포를 통해서 파악할 수 있기 때문에 초기 마킹으로부터 토큰이 옮겨 다니는 것을 추적하면 시스팀의 상태변화를 파악할 수 있게 된다. 페트리네트가 시스팀의 행위의 변화에 의한 상태변화를 반영하기 위해서는 토큰을 이동시켜야 하는데, 이때 토큰의 이동을 규정하는 규칙은 다음과 같은 활성화(Enable)와 발화(Firing)라는 개념을 이용해서 설명된다.

    활성화(Enable) : 어느 한 트랜지션의 입력 플레이스에 토큰이 있으면 이 
                     트랜지션은 활성화(Enable) 되었다고 한다. 즉,    
                     이면 트랜지션 는 
                    활성화 되었다 한다.

    발화(Firing) : 활성화된 트랜지션에 의해서 입력 플레이스에 있던 토큰이 
                  출력 플레이스로 옮겨지는 것을 발화라고 한다. 트랜지션이 
                  발화하면 페트리네트의 마킹 이 새로운 마킹 으로 변
                  화한다. 이때 플레이스  에 대해서 새로운 마킹 은 
                  다음과 같이 구해진다.
              
                 


트랜지션 T가 발화되면, 트랜지션 T의 입력 플레이스에서 토큰을 없애고 트랜지션 T의 출력 플레이스로 토큰을 이동시킨다. 이 경우 마킹 는 마킹  으로부터 도달 가능(Reachable)하다고 한다.  페트리네트 Z 가 있을 때, 이 페트리네트가 초기 마킹  에서 도달가능한 상태의 집합을 도달가능 집합(Reachability Set)이라고 하고 R(Z,M0)라고 표시한다.


 3-2.  Controlled Timed 페트리네트

생산시스팀은 시간이 중요한 역할을 하는 시간 종속적인 시스팀이다. 시스팀에서 발생하는 사건들은 발생하는데 일정한 시간을 필요로 한다. 예를 들면 기계가 부품을 가공하는 데에는 시간을 요하며, 컨베이어나 자율운반차량이 부품을 운반하는데에도 시간이 필요하다. 또 로보트와 기계가 상호협조하면서 동작하는 경우 로보트가 제 시간 안에 동작을 멈추지 않으면 기계나 로보트가 파손이 될 수도 있다. 따라서 생산시스팀을 모형화하는데 시간개념을 추가하고, 이를 고려하면서 대상 시스팀을 통제하는 것이 필요하다.
실제 시스팀에서 발생하는 사건들은 크게 다음과 같이 두 가지로 구분할 수 있다. 즉 기계고장이나 기계가공 종료와 같이 통제할 수 없는 사건과 기계가공 시작 같은 통제할 수 있는 사건으로 나뉠 수 있다. 따라서 시스팀의 통제자는 시스팀의 운용목적을 달성하고 시스팀이 좋지 않은 방향으로 흘러가는 것을 방지하기 위하여 필요한 경우 바람직하지 못한 결과를 초래할 수 있는 통제가능한 사건들의 발생을 방지해야 한다.


 3-2-1.  Controlled Timed 페트리네트의 정의

Controlled Timed 페트리네트(CTPN)는 다음과 같이 정의한다. 

    











Controlled Timed 페트리네트는 트랜지션을 통제할 수 있는 트랜지션과 통제할 수 있는 트랜지션으로 구분하고 각각의 트랜지션에는 트랜지션이 활성화된 이후부터 발화하기까지 소요되는 시간이 부여된다. 
본 논문에서는 Controlled Timed 페트리네트가 묘사하는 대상시스팀에서 발생하는 일정한 시간을 소요하는 모든 사건을 '사건 시작' 과 '사건 끝' 에 해당하는 두 개의 트랜지션을 이용해서 묘사한다. 
'사건 시작'에 해당하는 트랜지션에는 0의 시간을 부여하고 가는 막대모양으로 표시하고, '사건 끝'에 해당하는 트랜지션에는 이 사건이 수행하는데 소요되는 시간을 발화시간으로 부여하며 굵은 막대모양으로 표시한다. 이때 '사건 시작'에 해당하는 트랜지션은  통제할 수 있는 트랜지션이 될 수도 있고 통제할 수 없는 트랜지션이 될 수도 있다. '사건 끝'에 해당하는 트랜지션은 일정한 시간을 소요하면서 진행하기 때문에 통제할 수 없는 트랜지션으로 분류된다. 예를 들어 기계가공이라는 사건에 대해서 기계가공 시작이라는 트랜지션은 통제할 수 있는 트랜지션이지만, 기계고장이라는 사건에 대해서 기계고장 시작이라는 트랜지션은 통제할 수 없는 트랜지션이다. 
위의 정의에서 볼 수 있는 것처럼 각각의 트랜지션에는 시간이 부여되어 있다. 각각의 트랜지션에 부여된 시간은 트랜지션이 활성화된 후부터 발화하기 까지 소요되는 시간이다. 트랜지션이 발화하는 순간에 소요되는 시간은 무시한다. 즉 위의 정의에서 트랜지션 ti 의 발화시간이 10 으로 주어졌다면, 이 트랜지션은 활성화된 후 10초가 경과한 후 순간적으로 발화된다는 것을 의미한다. 보통 통제할 수 있는 트랜지션에 부여되는 시간은 0 이고 통제할 수 없는 트랜지션에 부여되는 시간은 일정한 지속시간을 갖는다. 예를 들어 '기계가공 시작' 이라는 트랜지션은 우리가 "기계가공을 시작하라"는  명령을 내리는 순간에 시작이 된다고 가정하는 것이다. 반면에 '기계가공 완료' 라는 트랜지션에 40의 시간이 부여되어 있다면, 이 트랜지션이 활성화된 후 40의 시간이 지난 다음에 발화된다는 것을 의미한다. 즉 기계가공 시간이 40이라는 것을 의미하게 된다.  발화시간은 시간이 지남에 따라 트랜지션들이 발화되면서 동적으로 바뀌게 된다. 
발화시간이 동적으로 바뀌게 되는 이유는 시스팀에서는 여러 가지 사건들이 동시에 활성화될 수 있기 때문이다. 즉. 어느 한 순간에 활성화된 상태에 있는 여러 개의 트랜지션들 중의 하나가 발화되면, 다음 순간에는 이전에 활성화된   상태에 있던 트랜지션들의 발화시간은 방금 발화된 트랜지션이 활성화된 이후에 발화하기까지 소요되었던 시간에 의해서 영향을 받게 된다. 예를 들어 현재의 시점에서 트랜지션 t1 과 t2 가 활성화된 상태에 있고 각각 30과 40의 발화시간을 가지고 있다고 하자. 이때 트랜지션 t1 은 30 이 지난 후에 발화가 되고  t2 는 40 이 지난 후에 발화가 되므로 현재의 순간에 발화할 수 있는 트랜지션은 t1 이 된다. 트랜지션 t1 이 발화된 후 도달하는 상태에서 트랜지션 t2 가 여전히 활성화된 상태로 있다면 이미 트랜지션 t1 이 발화하기 전에 30 의 시간을 소모하였으므로 트랜지션 t2 의 발화시간은 10 이 된다. 즉, 트랜지션 t2 는 앞으로 10 의 시간이 경과되면 발생할 수 있게 된다. 이처럼 현 상태에서 활성화 된 트랜지션이 바로 다음 상태에서도 활성화가 된다면 이 트랜지션은 현 상태에서 발화한 트랜지션의 발화시간에 의해서 영향을 받게 된다.
현 상태에서 한 트랜지션이 발화함으로 인해서 발생하는 트랜지션들의 발화시간의 변화에 대해서는 다음 장에서 알아보기로 한다.



 3-2-2.  Controlled Timed 페트리네트의 예

기계 2 대와 한 대의 로보트와 용량이 2인 버퍼로 구성된 시스팀을 생각해 보자. 기계가 가용하면 버퍼에서 부품을 가져다가 가공을 하며, 가공이 끝난 부품은 다시 버퍼로 저장된다. 각각의 트랜지션에는 발화시간이 표시되어 있다. 굵은 막대로 표시된 트랜지션은 가공시 일정한 시간이 소요됨을 의미한다. 이러한 시스팀을 Controlled Timed 페트리네트를 이용하여 모형화하여 보면 [그림 1]과 같다. 


  
      
 제 4 장.  Controlled Timed 페트리네트를 이용한 유연생산셀의 통제


유연생산시스팀은 독립적으로 자신의 작업을 수행할 수 있는 여러 개의 유연생산셀과 이 유연생산셀들 사이를 왕래하면서 필요한 물자의 운반을 담당하는 AGV나 컨베이어 등과 같은 물류 운반 시스팀으로 구성되어 있다. 유연생산셀은 한 대 이상의 자동화된 기계들로 구성되어 있으며, 셀내부에서의 자재이동을 위해서 로보트나 컨베이어 등이 첨가되기도 한다. 유연생산셀에 투입되는 부품은 들어가면 이 셀에서 수행할 수 있는 일련의 공정들을 거치게 된다. 각각의 유연생산셀은 각자가 수행하는 공정의 특징에 따라 가공셀(Machining Cell), 조립셀(Assembly Cell), 검사셀(Inspection Cell), 운반셀(Transportation Cell) 등으로 나누어 질 수 있다. 
유연생산셀들이 제대로 자신의 임무를 수행하도록 하기 위해서는 적절한 통제를 가할 수 있는 통제 소프트웨어가 개발되어야 한다. 그런데 이러한 통제 소프트웨어를 개발하기 위해서는 우선 적절한 모형화 기법을 이용하여 유연생산셀을 모형화한 후 이 모형을 이용하여 유연생산셀에 대한 통제를 수행할 수 있는 방법론이나 절차가 필요하게 된다. 본 장에서는 이러한 방법론과 절차에 대해서 설명하고자 한다.






 4-1.  상태, 상태그래프, 상태클래스

본 절에서는 FMC의 통제에 사용하기 위해서 Controlled Timed 페트리네트에서의 상태를 정의하고 Controlled Timed 페트리네트에서의 상태그래프 및 상태클래스에 대해서 정의한다.


 4-1-1.  Controlled Timed 페트리네트에서의 상태의 정의

현재의 마킹을 M 이라고 하면 Te(M)은 현재의 마킹 M 에서 발화가능한 트랜지션의 집합을 나타내며, I(Te(M))은 현재의 상태에서 발화가능한 트랜지션들이 발화하기 위해서 필요한 발화시간을 나타낸다.
이때 Controlled Timed 페트리네트에서는 시스팀의 상태 S 를 다음과 같이 정의한다.  

정의     상태 ( S )

       
시스팀의 상태를  로 표현할 때, 상태 S에서 트랜지션 ti 가 발화하여서 새로운 상태 S'로 전이하였다는 것을 다음과 같이 나타낸다. 이때 Ci 는 토큰의 종류를 나타낸다.

                           (ti,I(ti),Ci) 
                      S -------------> S'


시간이 지남에 따른 일련의 트랜지션의 발화순서ω를 다음과 같다고 하자.

            ω  = (t1,I(t1),C1)(t2,I(t2),C2) …… (tn,I(tn),C3)



그러면 ω에 의한 상태변화의 궤적은 다음과 같다.

 
   (t1,I(t1),C1)         (t2,I(t2),C2)          ……          (tn,I(tn),Cn)
S -----------> S1 -----------> S2 ····· Sn-1 -----------> Sn




트랜지션 ti 가 활성화된 후 I(ti) 의 시간이 지난 후에 발화하여 시스팀의 상태가 새로운 상태  로 바뀌었다고 할 때 트랜지션들의 발화시간 I는 다음과 같이 바뀌게 된다.


   
 4-1-2.  Controlled Timed 페트리네트에서의 상태그래프의 정의

 상태그래프(State Graph)는 시스팀의 상태 변화의 궤적을 나타낸다. 시간이 지남에 따라 시스팀내에서는 사건이 발생하기 때문에 시스팀의 상태는 이때마다 바뀌게 된다. 이러한 상태변화를 묘사하기 위해서 상태그래프를 사용한다. 상태그래프에서는 상태들이 노드가 되며 이 노드들은 서로 호로 연결되어 있다. 따라서 어느 한 상태로부터의 비롯되는 상태변화의 궤적을 파악하기 위해서는 상태 그래프상의 해당 노드에서 시작되는 호를 따라가면서 연결되어 있는 노드들을 파악하면 된다.
 

CTPN   와 초기상태  이 주어져 있을 때, 상태그래프 는 다음과 같이 정의한다.

정의     상태그래프 ( SG )
      = 
        이때, 
         :  그래프의 노드 즉, 상태를 의미 
        , 그래프의 호 즉, 상태들을 연결한 호를 의미
        , 호 A 에 대한 일종의 가중치(weight)
            에 의해서 연결되고 있는 상태들 간에 전이가 발생하기 위해서
            필요한 토큰의 종류와 발화해야 할 트랜지션과 이 트랜지션의 
            발화시간
 

만약 상태 S에서 활성화된 트랜지션 중에서 다음 번에 발화할 수 있는 트랜지션 가 있으면 상태  에서 트랜지션 상태  가 발화함으로써 도달하는 새로운 상태  으로 가는 호  가 존재하며  가 존재한다. 만약 다음 번에 발화할 수 있는 트랜지션 가 없으면 상태 S 에서 분지하는 호는 존재하지 않는다.
상태  에서 트랜지션 tk 가 발생하여 새로운 상태  로 전이하게 될 때에는 각 트랜지션의 발화시간을 변경해야 한다.  상태 S 에서 상태 S' 로 전이되었을 때, 새로운 상태 S' 에서의 새로운 발화시간 는 앞에서 설명한 방식을 이용해서 구하면 된다. 
상태그래프의 개념은 다음 [그림 2]와 같다


       
 4-1-3.  Controlled Timed 페트리네트에서의 상태클래스의 정의

상태그래프상의 한 상태로부터 파생될 수 있는 모든 상태들의 집합을 상태클래스(State Class) 라고 한다. 즉, 주어진 상태 S 가 있을 때 이 상태 S 로부터 다음 번 상태 S' 으로 가는 호가 존재할 때 S'을 상태 S 의 상태클래스라고 한다. 
주어진 상태 S에 대한 상태클래스 SC 는 다음과 같이 정의한다.

정의     상태클래스 ( SC ) 
     SC = {S' |    S ----> S' }  
즉, 현재의 상태 S 로부터 분지하는 상태들의 집합

예를 들어 상태 S 가 있다고 하자. 이 상태 S 에서 다음 번에 활성화된 트랜지션들이 t1, t2, t3 이면 상태 S 에서 파생될 수 있는 상태는 [그림 2]와 같이 S1, S2, S3 가 있을 수 있다. 이때 S1, S2, S3 를 상태 S 로부터 파생하는 상태클래스라고 한다.
현재의 상태 S(M)에서 n번 만큼 트랜지션들이 발화한 후 즉, 현재부터 n단계이후에 도달하게 되는 상태들의 집합(상태클래스)으로 다음과 같이 표시된다.

             SCn(M) = (ω , S(M'))

이때 M' 는 n단계 이후에 도달하게되는 상태이고, ω = (t1,I(t1),C1)(t2,I(t2),C2) …… (tn,I(tn),C3) 로서 상태 S(M)에서 새로운 상태 S(M') 까지 도달하기 위해서 발생해야 할 일련의 트랜지션들이다.    
 4-2.  통제의 구조

부품이 유연생산셀로 들어오면 유연생산셀은 부품이 필요로 하는 가공을 수행한다. 그런데 실제 생산시스팀에서는 여러 가지 종류의 부품들이 동시에 시스팀내에 존재할 수 있다. 또, 이러한 각각의 종류의 부품들은 각기 다른 공정경로를 가지면서 시스팀을 돌아다닌다. 따라서 이러한 부품의 종류와 공정경로를 고려한 통제가 필요하다.

본 논문에서 제시하는 통제의 구조는 다음  [그림 3]과 같다. 


 
본 논문에서는 동적으로 변화하는 시스팀에서 시간개념을 통제를 위한 수단으로서 사용한다. 통제과정에서의 시간의 고려는 유연생산셀의 논리적 행위(Logical Behavior) 뿐만 아니라 시간적 행위(Timed Behavior)를 묘사하며, 통제과정에서 고려해야 할 경우의 수를 줄이는데 사용될 수 있다. 
통제 구조의 각각에 대해서 설명하면 다음과 같다.

1) 유연생산셀

유연생산셀은 실제로 통제의 대상이 되는 현실에 존재하는 시스팀이다. 유연생산셀에서 사건이 발생하면 유연생산셀은 통제기와 CTPN 모형과 정보관리기한테 사건이 발생했음을 알리는 신호를 보내며, 통제기로부터의 보내지는 통제패턴에 따라 작동을 하게 된다. 유연생산셀이 페트리네트 모형과 정보관리기한테 보내는 사건발생 신호는 부품의 종류와 발생한 사건의 종류로 구성되어 있다. 즉, 신호는 다음과 같이 구성되어 있다. 

신호 = (Cij, tk,)
     이때 Cij : 부품그룹 i의 j번째 개체(instance)
             tk : 발생한 사건 즉, 트랜지션 k 
 

2) Controlled Timed 페트리네트 모형

Controlled Timed 페트리네트 모형은 유연생산셀을 모형화하고  유연생산셀의 상태를 계속해서 반영한다. 즉, 각 부품이 어느 공정까지 진행되었으며, 각각의 자원(Resource)들이 어떻게 이용되고 있으며 어떤 상태인지를 현재의 토큰의 위치로서 반영한다.
이 모듈은 유연생산셀로부터 사건의 발생을 알리는 신호를 받으면 자신의 상태를 변경하고 변경된 상태의 마킹과 활성화된 트랜지션들을 통제기와 정보관리기한테 알려서 통제기가 유연생산셀의 동적 변화를 통제의 목적으로 사용할 수 있도록 하여준다.


3) 정보관리기 

일반적인 페트리네트의 경우 부품의 종류를 고려하여 모형을 만들면 각 부품의 종류에 따라 각기 다른 공정경로를 그려야 하기 때문에 모형이 복잡해진다. 따라서 페트리네트에 의한 묘사를 단순화하면서 부품의 종류나 공정경로를 고려해서 통제하기 위해서는 부품의 종류나 공정경로 등에 관한 정보를 따로 유지시키면서 이를 이용하는 것이 필요하다. 이러한 방법은 별도의 정보관리가 필요하기는 하지만 부품의 종류나 공정경로, 시간 등을 고려해야 하는 페트리네트의 묘사를 단순화 시켜줄 수 있다.
이러한 목적을 달성하기 위해서는 각각의 부품의 공정경로와 토큰의 위치 그리고 트랜지션의 발화에 관여하는 플레이스의 정보를 유지하고 있어야 한다. 정보관리기는 토큰-플레이스 테이블, 공정경로 테이블, 트랜지션-플레이스 테이블을 포함하고 있다.
토큰-플레이스 테이블은 각각의 토큰(부품)이 Controlled Timed 페트리네트 모형상의 어느 플레이스에 위치하고 있는 가를 알려준다. 이것을 이용하면 현재 페트리네트 모형상의 각각의 플레이스에 어떤 종류의 토큰이 위치하고 있는 지를 알 수 있다. 
트랜지션-플레이스 테이블은 각각의 트랜지션이 발화하기 위해서 필요한 입력 플레이스 및 트랜지션이 발화된 후에 영향을 받게 되는 출력 플레이스, 그리고 트랜지션의 발화시의 토큰 변화를 나타낸다. 
공정경로 테이블은 각각의 부품에 대해서 이 부품이 가공이 끝마치기 위해서 거쳐야 할 오퍼레이션들의 순서에 따라서 각 오퍼레이션의 발화시간과 수행여부를 나타낸다. 이때 오퍼레이션이란 Controlled Timed 페트리네트에 표시되어 있는 트랜지션을 의미한다.  
예를 들어 부품 C11 가 가공을 끝마치기 위해서 거쳐야 할 트랜지션이 t1,t2,t3 이고 C23 가 가공을 끝마치기 위해서 거쳐야 할 트랜지션이 t1,t4,t3이라면 다음과 같은 공정경로 테이블이 작성된다.

                         [표 1] 공정경로 테이블 
      
정보관리기는 세 가지 기능을 한다. 첫째, 정보관리기 모듈은 유연생산셀에서 부품 Cij 에 대해서  사건 tk 가 발생하였음을 알리는 신호를 받으면 공정경로 테이블에서 해당 부품 Cij 의 수행여부를 체크한다. 둘째, 정보관리기는 Controlled Timed 페트리네트로부터 마킹이 변화하였다는 신호를 받아서 토큰-플레이스 테이블의 내용을 변화시킨다. 셋째, 통제기로부터 현재의 상태에서 어떤 한 플레이스에서 발생가능한 다음 번 트랜지션(Next Transition : NT) 이 무엇인지에 대한 정보요청이 있을 때 토큰-플레이스 테이블을 찾아서 현재의 플레이스에 위치하고 있는 토큰의 종류를 파악한 후 이 토큰이 거쳐야 할 다음 번 트랜지션을 공정경로 테이블을 찾아서 알아낸 다음 통제기에게 알려준다. 


4) 통제기

유연생산셀을 통제함에 있어서 통제기가 달성해야 할 사항에는 다음과 같은 것들이 있다. 

      버퍼의 용량초과 방지
      자원사용상의 상충 해결
      데드락 방지 및 해결
      시스팀 운용규칙의 준수     

버퍼의 용량초과를 방지는 Controlled Timed 페트리네트의 버퍼에 해당하는 플레이스에 위치하는 토큰의 개수를 버퍼가 가질 수 있는 최대의 용량으로 설정함으로 해서 달성할 수 있다. 또, 자원사용상의 상충은 Controlled Timed 페트리네트에서 하나의 토큰을 공유하는 두 개 이상의 플레이스로 묘사가 된다. 따라서 데드락을 방지하며, 데드락이 발생하였을 경우 이를 해결하여 주며, 시스팀 운용상의 규칙을 준수시켜줄 수 있는 방법이 필요하다. 
본 논문에서는 데드락 문제를 해결하기 위하여 통제논리를 생성하는 과정중에 부품의 종류와 공정경로를 고려하면서 현재의 상태로부터 N 단계 이후의 상황을 예측하는 전방조사방법을 사용한다. 시스팀 운용상의 규칙들, 예를 들면 버퍼에 입력된 부품들 중에서 어떤 부품이 먼저 사용되어야 하는 가 등에 대한 규칙들은 통제논리를 생성해 나가는 과정에서 고려된다.
통제기는 정보관리기로부터 각각의 토큰 즉, 부품이 페트리네트 모형의 어느 플레이스에 위치해 있는 지를 파악한 후 각각의 부품의 공정경로를 고려하여 현재의 상태에서 데드락에 직면하지 않게 되는 방향으로 유연생산시스팀이 작동하도록 통제가능한 트랜지션의 동작을 통제하게 된다. 이때 통제기가 트랜지션에 대해서 부여하는 통제패턴은 '발생가능(enable)' 과 '발생불가(disable)' 의 두 가지이다. 즉 통제할 수 있는 트랜지션에 대해서 만약 이 트랜지션의 발화가 데드락을 발생시킬 소지가 있으면 이 트랜지션이 발생하지 못하도록 해주는 것을 '발생불가' 라고 하고 그렇지 않을 경우를 '발생가능' 이라고 한다. 그런데 통제할 수 없는 트랜지션에 대해서는 모두 '발생가능'이라는 패턴을 부여한다. 





 4-3.  통제 알고리즘

통제 알고리즘은 유연생산셀의 작동에 있어서 다음과 같은 역할을 해야 한다. 첫째, 다양한 종류의 부품들이 각자의 공정경로를 따라 무사히 가공을 끝마치도록 하는 역할을 수행하여야 한다. 둘째, 유연생산셀에 존재하는 한정된 자원들이 적절히 분배되어 사용되도록 해야 한다. 셋째, 실시간 안에 통제를 이룰 수 있어야 한다. 
이러한 목적을 달성하는 방법중의 하나는 시스팀이 도달할 수 있는 모든 가능한 상태를 구해놓고 이 중에서 바람직하지 않은 상태 즉. 버퍼가 용량을 초과하는 상태라든가 데드락에 도달하게 되는 상태등을 제거하여 통제자가 바라는 시스팀이 흘러가야 할 올바른 상태만을 정해놓는 것이다. 그런 다음 시스팀에서의 사건의 발생에 따라 미리 구해놓은 올바른 상태로 흘러가도록 통제를 하면 된다. 그러나 페트리네트모형의 플레이스와 트랜지션의 수가 늘어나면 이 방법의 복잡도는 지수적으로 증가하게 된다. 더구나 시간이 고려되고 부품의 종류와 공정경로가 고려되면 훨씬 더 복잡해지게 된다. 따라서 다른 방법이 필요하게 된다. 즉 사건이 발생할 때마다 현재의 상태에서 몇 단계 앞을 내다보아 정해진 시간조건과 부품의 공정경로를 만족시키게 하면서 데드락이 발생하지 않는 상태로 시스팀이 흘러가게 하는 사건만이 발생하도록 통제하는 것이다. 물론 이 경우 통제의 대상은 통제할 수 있는 사건에 한정된다. 이 방법은 반드시 데드락을 막아준다는 보장은 하지 못하지만 시간과 부품의 공정경로가 결합된 복잡한 경우에 대해서는 적절한 해결책이 될 수 있다. 


 4-3-1.  부품의 종류와 공정경로를 고려한 생존 트랜지션의 생성

통제논리를 생성하기 위해서는 생존 트랜지션이라는 개념이 필요하다. 생존트랜지션의 개념을 정의하기에 앞서 교집합 트랜지션에 대해서 정의하면 다음과 같다.


정의    교집합 트랜지션 ( ITe(M) )
 현재의 마킹 M 에서 발화가능한 트랜지션 Te(M)과 정보관리기에서 보내온 각 부품별로 다음에 허용가능한 트랜지션(NT)과의 교집합. 

즉, 현재의 상태에서 활성화된 트랜지션들에 대해서 트랜지션-플레이스 테이블을 조사하면 활성화된 트랜지션의 입력 플레이스를 알게 된다. 이제 이 입력 플레이스에 있는 토큰의 종류를 알기 위해서 토큰-플레이스 테이블을 조사하면 현재의 입력 플레이스에 있는 토큰의 종류를 파악하게 된다. 그러면 공정경로 테이블을 이용하여 이 토큰이 다음 번에 거쳐야 할 트랜지션을 찾을 수 있게 된다. 이 트랜지션과 Te(M) 과의 교집합을 구한 결과를 교집합 트랜지션이라고 한다. 어떤 한 플레이스에 토큰이 위치하면 이 플레이스의 출력 트랜지션들은 활성화되게 된다. 그러나 입력 플레이스에 있는 토큰의 종류와 이 토큰의 공정경로에 따라 다음 번에 발화될 수 있는 트랜지션의 종류가 결정되게 된다. 따라서 Controlled Timed 페트리네트 상에서는 활성화되었더라도 토큰의 종류와 공정경로를 고려하면 발화할 수 없는 트랜지션이 생기게 된다. 교집합 트랜지션을 구하는 이유는 토큰의 종류와 공정경로를 고려했을 때 발화할 수 없는 트랜지션을 제거하고 발화가능한 트랜지션만을 구하는 데 있다. 교집합 트랜지션이 구해지면 생존 트랜지션을 구할 수 있게 된다. 
생존 트랜지션은 다음과 같이 정의한다.

정의     생존 트랜지션 ( ST )
    교집합 트랜지션들 중에서 교집합 트랜지션들의 발화시간을 비교하였을 때 시간적으로 먼저 발화해야 할 트랜지션

Controlled Timed 페트리네트는 각각의 트랜지션에 시간을 부여한다. 따라서 하나의 입력플레이스에 토큰이 위치함으로 인해서 발화가능한 여러 개의 교집합 트랜지션이 있다 하더라도 각각의 교집합 트랜지션에 부여되어 있는 시간적 우선순위에 의해서 먼저 발화시켜야 하는 트랜지션과 나중에 발화시켜야 할 트랜지션이 구분되게 된다. 시스팀이 작동해 나감에 따라 앞에서 설명한 것처럼 여러 개의 트랜지션이 동시에 활성화될 수 있기 때문에 트랜지션의 발화시간이 동적으로 변화할 수 있다. 따라서 같은 마킹을 가진 상태에 있다 하더라도 먼저 발화해야 할 트랜지션은 각각 다를 수 있다. 이처럼 생존 트랜지션은 발화시간을 고려하여 구해진 현재의 상태에서 먼저 발화해야 할 교집합 트랜지션을 의미한다. 생존 트랜지션의 개념을 이해하기 위해서 다음과 같은 [그림 4] 와 [표 1] 과 [표 2] 와 같은 경우를 살펴보자.


        


                    [표 2] 토큰-플레이스 테이블

                     


                   [표 3] 트랜지션-플레이스 테이블
           
이 경우 페트리네트 상에서 보면 플레이스 P1에 있는 토큰은 트랜지션 t1에 의해서 발화될 수도 있고, 트랜지션 t2에 의해서 발화될 수도 있다. 그러나 실제로 유연생산셀에서 가공이 되는 각 부품은 각자의 공정경로를 가지고 있기 때문에 t1 이나 t2 중 어느 하나에 의해서만 발화될 수 있다. 유연생산셀이 부품생산이라는 목적을 달성하기 위해서는 이러한 상충현상을 해결해 주어야 하는데 페트리네트 상에서는 토큰에 대한 정보가 부족하여 해결할 수가 없다. 따라서 어느 한 시점에 각 플레이스에 있는 토큰(즉, 부품)의 종류를 알아야 하며, 각각의 토큰들이 다음에 거쳐야 할 공정인 next 트랜지션(NT)을 파악해야 한다. 그런 다음 next 트랜지션의 집합과 활성화된 트랜지션의 교집합을 구해서 교집합 트랜지션 ITe(M) 을 구한 뒤 시간적 우선순위를 고려하여 생존 트랜지션 ST(M)을 구한다. 
생존 트랜지션을 구하는 이유는 활성화된 트랜지션 중에는 토큰의 종류가 구해지면 실제적으로 발화할 수 없는 트랜지션이 포함되어 있을 때 이를 제거하여 각 플레이스에 위치한 토큰이 자신의 공정경로에 적합한 트랜지션을 따라서 흘러가게 할 수 있고, 또 뒤에서 설명하게 될 전방조사를 할 때 고려해야 할 트랜지션 발화의 경우 수를 줄일 수 있기 때문이다. 앞에서 든 예에서 활성화된 트랜지션의 집합은 Te(M) = { t1, t2, t3} 이다. 만약 플레이스 P1에 있는 토큰 A가 공정경로 상에서 t1을 거치도록 되어 있고 플레이스 P3에 있는 토큰 B가 공정경로 상에서 t3를 거치도록 되어 있다면 next 트랜지션의 집합은 NT = { t1, t3 }이다. 그러므로 교집합 트랜지션은 ITe(M) = { t1, t3 } 가 된다. 따라서 유연생산셀에서 다음에 실제로 발화할 수 있는 트랜지션은 t1 과 t3 가 된다. 그런데 t1은 활성화된 후 4 이후에 발화되고 t3는 활성화되고 8 이후에 발화가되므로 생존 트랜지션 ST(M)은 t1이 된다.
생존 트랜지션은 다음과 같은 절차를 거쳐서 구해진다. 이 과정에서 부품의 종류와 공정경로 및 각각의 트랜지션에 부여된 발화시간이 사용된다. 


생존 트랜지션 생성 절차

(단계 1)   현재의 마킹
    현재 상태의 마킹 M 을 구한다.

(단계 2)   활성화된 트랜지션
    현재 상태에서 활성화된 트랜지션 Te(M) 을 구한다.

(단계 3)   next 트랜지션
    각각의 활성화된 트랜지션들에 대해서 
 3-1.   활성화된 트랜지션에 대한 입력 플레이스를 구한다.
   3-2.   토큰-플레이스 테이블을 참조하여 입력 플레이스에 있는 토큰의 
        종류를 구한다.
 3-3.   공정경로 테이블을 참조하여 next 트랜지션인 NT 와 NT 의
             발화시간을 구한다.

(단계 4)   교집합 트랜지션 
    단계 3 에서 구한 NT 와 Te(M) 과의 교집합 트랜지션을 구하고 
    발화시간을 부여한다.

(단계 5)   생존 트랜지션 
    구해진 교집합 트랜지션들의 시간적 우선순위를 고려하여 현재 발화할 수 
    있는 생존 트랜지션 ST(M) 을 구한다.


통제를 수행하는 과정에서 현재의 상태에서 발화할 수 있는 생존 트랜지션이 여러 개일 때는 이 중에서 발화시켜야 할 하나의 생존 트랜지션을 결정해야 한다. 이 결정과정에는 여러 가지 선정 규칙들(Dispatching Rule) 이 쓰일 수 있다. 예를 들면 선입선출, 후입선출, 잔여공정수가 가장 많은 것, 잔여공정시간이 가장 적은 것 등의 여러 가지 규칙들이 쓰일 수 있다.  
하나의 플레이스에 여러 개의 토큰이 위치할 경우 이 토큰에 의해서 활성화된 생존 트랜지션은 토큰의 종류에 따라 여러 가지 발화시간을 가질 수 있다. 예를 들어 기계 M 의 가공을 마치는데 토큰 A 는 30 의 시간이 소요되고 토큰 B 는 40 의 시간이 소요된다고 하자. 이 때 기계가공을 나타내는 트랜지션은 토큰 A 에 의하여 발화되었다고 생각하면 30 발화시간이 부여되어야 한다. 반면에 토큰 B 에 의해서 발화되었다고 생각하면 40 의 발화시간이 부여되어야 한다.  트랜지션 t 의 입력 플레이스에 토큰 A 와 토큰 B 가 위치한 경우에는 동시에 두 개의 서로 같은 트랜지션이 연속해서 활성화 되었다고 생각한다. 즉, 트랜지션 t 에 대해서 t1, t2 의 두 개의 트랜지션이 연속해서 활성화되었다고 생각한다. 이때 위에서 설명한 선정 규칙에 의해서 선정된 트랜지션이외의 트랜지션들의 발화시간은 앞에서 설명한 발화시간변화의 규칙을 따르면 된다. 
생존 트랜지션의 유무 여부로 시스팀의 데드락 상황을 파악할 수 있다. 즉, 현재의 상태에서 발화할 수 있는 생존 트랜지션이 하나도 없으면 데드락 상태이다.
 4-3-2.  상태클래스의 생성

상태클래스는 다음에 설명할 N 단계 전방조사 방식을 이용하여 유연생산셀의 행위를 예측하는데 쓰이는 것으로서 생존 트랜지션 생성 절차를 이용하여 구한 생존 트랜지션 ST(M)의 원소에 대해서 한 단계 앞의 상황을 예측하기 위해서 상태그래프를 작성하고 상태클래스를 생성한다.
상태 클래스는 다음과 같은 절차를 거쳐서 구해진다. 


상태클래스 생성 절차

(단계 1)   생존 트랜지션 파악
    생존 트랜지션 생성 절차를 이용하여 현재 상태에서의 생존 트랜지션을 
    구한다. 각각의 생존 트랜지션에 대해서 다음의 단계 2 에서 단계 4를 반복
    한다.

(단계 2)   새로운 상태의 생성
       3-1.   생존 트랜지션 tj   ST(M), j = 1  |ST(M)|   를 발화한 후의 
             새로운 마킹 Mj'을 구한다.
       3-2.   트랜지션-플레이스 테이블을 참조하여 새로운 마킹 Mj'에서의 
              활성화된 트랜지션 Te(Mj')을 구한다.
       3-3.   Mj' 과 Te(Mj') 으로 구성된 새로운 상태 S(Mj') 를 구한다.

(단계 3)   발화시간의 조정
     새로운 마킹 Mj'에서의 활성화된 트랜지션 Te(Mj')의 발화시간에 대해서 
      (경우 1)   tk   {t | Te(M)   Te(Mj') } 인 경우
            I(tk) =  max( 0, I(tk) - I(ti)) ,  i k  

      (경우 2)   tk   {t | Te(Mj') - Te(M) } 인 경우
              새로운 마킹 Mj' 에서도 활성화된 트랜지션 tk 의 경우에는 
              트랜지션  tk 의 초기 발화시간인 I(tk) 를 쓴다. 

      (경우 3)  tk   {t | Te(M) - Te(Mj') } 인 경우
              트랜지션 ti 가 새로운 마킹 Mj' 에서는 더 이상 활성화되지 않기 
              때문에 사용하지 않는다.

(단계 4)   상태그래프 및 생성
     상태 S(M)에서 새로운 상태 S(Mj') 으로 향하는 호를 그리고 이 호에 상
     태 S(M)에서 상태 S(Mj')으로 변화하기 위해서 필요한 토큰과 트랜지션
     과 트랜지션의 발화시간으로 구성된 라벨을 붙인다. 

(단계 5)  수행체크
     모든 생존 트랜지션에 대해서 단계 2 에서 단계 4 까지의 과정을 수행 했
     으면 단계 6 으로 간다. 아니면 단계 2 로 간다.


(단계 6)  상태클래스 생성
       각각의 생존 트랜지션  tj   ST(M) , j = 1  |ST(M)|  에 대해서 구
       한 S(Mj') 의 집합이 상태 S(M)로부터 발생할 수 있는 상태클래스가 
       된다.
 

 4-3-3.  전방조사

유연생산셀을 통제할 경우 하나의 상태에서 발화가능한 여러 가지 생존 트랜지션들이 존재할 수 있다. 이때 어느 생존 트랜지션을 먼저 발화 하느냐에 따라 나중에 시스팀이 직면하게되는 상태가 달라질 수 있다. 따라서 나중에 바람직하지 않은 상태가 발생하지 않도록 하는 생존 트랜지션이 발화되도록 하여야 한다. 이러한 목적을 달성하는 데에는 크게 두 가지 방법이 있을 수 있다. 
첫번째 방법은 현재의 상태에서 도달가능한 모든 상태를 구한 후에 이 중에서 바람직하지 않은 상태로 가게 하는 트랜지션들을 제외시키는 방법이다. 그러나 이 방법은 시스팀이 복잡해지거나 시스팀에 새로운 첨가되거나 부품의 종류와 공정경로가 고려되게 되면 그 복잡도가 지수적으로 증가하게 된다. 따라서 실제 시스팀에 적용하기에는 무리가 있다. 
두번째 방법은 동적인 방법이다. 이 방법은 현재의 상태에서 도달가능한  모든 상태를 구하는 대신, 현재 상태로부터 N 단계 이후까지의 상태만을 구하는 것이다. 이렇게 하면 N 단계에 이르기 까지 데드락 같은 바람직하지 않은 상태가 발생하지 않도록 하는 생존 트랜지션을 찾아낼 수 있게 된다. 이 과정에서 부품의 종류와 공정경로가 고려되며 상태클래스 개념이 사용된다. 이러한 전방조사의 개념이 [그림 5] 에 나타나 있다.
 

그러나 이 방법은 반드시 데드락이 발생하지 않는 다는 것을 보장하지는 못한다. 이 방식은 N의 값이 커질 수록 데드락이 발생하는 경우를 더 많이 찾아낼 확률이 높다. 이론적으로는 페트리네트가 주어진 마킹에서 도달할 수 있는 상태의 수가 한정되어 있을 경우는 N의 값을 크게 함으로써 데드락이 발생하는 경우를 모두 다 찾아 낼 수 있  다. 그러나 N이 커질 경우 고려해야 할 상태의 수가 많아지고 계산량이 많아지게 되는 단점이 있다. 그러나 이 방식은 초기 마킹 상태에서 N 단계 이후의 전방을 조사해 놓았을 경우만 계산량이 많고 그 다음부터는 계산량이 줄어들게 된다. 
예를 들어 마킹 M을 가진 현재의 상태 S(M)에서 트랜지션 ti가 발생해서 새로운 마킹 M'을 가진 새로운 상태  S(M')로 상태가 전이되었다고 할 때, 상태 S(M') 에서 다시 N 단계 전방조사를 해서 상태 클래스 SCn(M') 을 구해야 한다. 그런데 상태 클래스 SCn-1(M') 은 상태 클래스 SCn(M)과 같으므로 SCn(M)에서 한 단계 앞만 더 살피면 SCn(M')을 구할 수 있게 된다[그림 6].



     


 또 본 논문에서는 발화시간을 고려하기 때문에 시간적으로 우선 순위가 뒤지는 것은 전방조사시 고려하지 않는다. 따라서 전 방조사시 고려해야 할 상태 수를 줄일 수 있는 장점이 있다.
그런데 이 방법을 사용함에 있어서 N 을 어떠한 값으로 설정하는 가에 대한 고려가 있어야 한다. 일반적으로 유연생산셀의 통제 소프트웨어는 상당한 기간에 걸쳐서 시스팀을 통제하는데 사용된다고 할 수 있다. 따라서 적절한 N 값의 설정은 실제 시스팀에서 여러 가지 N 값을 가지고 통제 소프트웨어를 실행시켜본 후 해당 시스팀에 적절한 N 값을 설정하면 된다.
전방조사를 수행하는 절차는 다음과 같다.


 
 N 단계 전방조사

(단계 1)   새로운 상태그래프 및 상태클래스 생성
    1-1.   i 단계의 상태클래스 SCi(M),  i = 0, 1,   , n-1 의 각각의 상태 
          에 대해서 상태클래스 생성 절차를 이용해서 한 단계 전방의 새로운 
          상태그래프와 상태클래스 SCi+1(M)을 생성한다.
    1-2.   상태클래스 SCi(M)의 모든 상태에 대해서 새로운 상태클래스와 
          상태그래프를 구했으면 단계 2로 간다. 아니면 단계 1-1로 간다.

(단계 2)   생존 트랜지션 파악
새로 도달한 상태클래스 SCi+1(M) 의 각 상태에 대해서 생존트랜지션을 파악한다.

(단계 3)   데드락 발견
새로 도달한 상태클래스 SCi+1(M) 의 모든 상태에서 발화할 수 있는 생존트랜지션이 하나도 없으면 데드락 상태이다.


(단계 4)   종료판정
N 단계가 모두 구해졌으면 종료한다. 아니면 단계 5로 간다.

(단계 5)   반복 
단계를 하나 높인 후 단계 1로 간다.



N 단계 전방조사는 모든 상태를 고려하는 것이 아니고 N 단계 까지만의 도달가능한 상태만을  고려한다. 따라서 현재의 상태에서 보았을 때 데드락이 발생하지 않게 하는 생존트랜지션을 선택했다 하더라고 N 단계 이후에 데드락이 발생할 수 있다. 따라서 이러한 상황의 해결에 대한 고려가 있어야 한다. 이러한 데드락 상황의 해결에 대해서는 다음에 자세히 살펴보기로 하자. 


 4-3-4. 역추적에 의한 데드락 해결

시스팀내에 버퍼의 용량과 부품을 잡는(seize) 자원의 갯수를 n 개라고 할 때, 만약 시스팀내에 n 개의 부품이 존재하면 데드락이 발생한다. 또 n-1개의 부품의 있다 하더라도 다음과 같은 [그림 7]과 같은 경우에 데드락이 발생할 수 있다.  [그림 7]을 Controlled Timed 페트리네트를 이용해서 표현하면 [그림 8]과 같다.

        
    

기계 2대와 용량이 2인 버퍼로 구성된 시스팀의 경우를 생각해 보자. 현재 기계 1에 있는 부품은 가공을 끝마쳤기 때문에 버퍼로 들어오려고 한다. 기계2는 아직 가공중이고 가공이 끝나면 버퍼로 들어오게 되어 있으며 버퍼에 있는 부품은 기계2의 가공을 받으려고 기다리고 있다. 이러한 상황에서 기계1의 부품이 버퍼로 들어오게 되면 데드락이 발생한다. 이러한 현상의 데드락은 기계들 사이에 버퍼가 있어서 작업의 중간에 반드시 버퍼를 거쳐야 하는 경우에 발생한다. 
이러한 데드락 상황을 해결하기 위해서 역추적 및 지연 방법을 사용한다. 역추적 개념은 다음의 [그림 9]와 같다.


   
 

이러한 역추적 및 지연 방식을 이용한 데드락을 해결할 때 문제가 되는 것은 데드락 상황이 발생하도록 만든 트랜지션을 발견하는 것이다. 일단 이 트랜지션이 발견만 되면 이 트랜지션의 발생을 일정만큼 시간 지연시켜서 데드락 상황이 발생하지 않도록 할 수 있다. 그런데 본 논문에서 모형화에 이용한 Controlled Timed 페트리네트는 시스팀에서 발생하는 사건에 대해서 '사건 시작'에 해당하는 트랜지션과 '사건 끝'에 해당하는 트랜지션으로 구분한다. 이때 '사건 시작'에 해당하는 트랜지션은 통제할 수 있는 트랜지션이다. 따라서 전방조사를 해나가는 과정에서 N단계 까지 전방조사한 결과 도달하는 모든 상태가 전부 데드락이 발생하는 상황일 경우에는 데드락이 생긴 상태에서 역으로 추적하여 부품이 버퍼로 들어가게 하는 첫번째 트랜지션을 찾는다. 만약 발견된 트랜지션이 데드락이 발생한 상태에서 N-3단계 이전의 상태라면, 이 트랜지션의 발화시간을 현재의 발화시간보다 더 긴 시간으로 설정하여서  이 트랜지션을 지연시킨 다음 다시 N단계에 이를 때 까지 전방조사를 한다. 만약 이 경우에도 데드락이 발생하면 다시 N-3단계의 상태로 돌아와서 데드락을 발생시키는 트랜지션의 발화시간을 더 늘려서 다시 N단계 까지 전방조사한다. 이러한 과정을 데드락이 발생하지 않을 때 까지 반복한다. 
앞의 예에서는 기계1이 작업을 끝마치더라고 기계2가 가공을 끝마치고 나서 버퍼로 들어오고 현재 버퍼에 있는 부품이 기계2로 가공하러 갈 때 까지는 기계1에 있는 가공을 끝마친 부품이 버퍼로 가지 못하도록 트랜지션 t4를 지연시키면 된다.
그런데 N 단계 전방조사 이후에 도달할 수 있는 상태가 여러 개이고, 이들 상태가 모두 데드락 상태일 경우를 생각해 보자. 이 경우 데드락을 해결하기 위해서 역추적 및 지연방법을 어느 상태에 대해서 수행해야 하는 가를 결정해야 한다. 이러한 역추적 대상을 결정하는 방법 중의 하나로서 데드락 상태 중에서 임의로 하나를 선정하여서 역추적 및 지연방법을 수행하고 이 상태로 이끌게 하는 현재 상태의 생존 트랜지션을 발화시키는 방법이 있다. 또 다른 방법으로는 모든 데드락 상태에 대해서 역추적을 수행하고 난 후 데드락을 해결하기 위해서 지연시켜야 하는 시간이 가장 적은 상태에 해당하는 현재 상태의 생존 트랜지션을 발화시키는 방법이 있다. 두번째 방법의 경우 계산시간은 첫번째 방법보다 더 많은 계산시간이 소요될 수 있지만 전체적인 대상시스팀의 성능(예를 들면 시스팀내의 체류시간, 기계의 유휴시간 등)의 측면에서 보면 더욱 효율적인 방법이라고 할 수 있다. 























 4-3-5. 통제 알고리즘

통제 알고리즘을 순서도로 나타내면 다음과 같다.

     
 4-4.  예제

본 논문에서 제시한 알고리즘을 이용하여 다음과 같은 예제를 풀어 보았다.

1) 대상시스팀 : 기계 2 대, 용량 2 인 버퍼 하나,
          로보트 1 대 
2) 부품투입순서 : A1-B1-B2-A2-A3-B3 
3) 발화시간 : I(t2) = 10, 
        I(t4) = I(t10) = I(t8) = I(t14) = 4
        I(t6) =  A 종류의 부품의 경우에는 30
           B 종류의 부품의 경우에는 40
        I(t12) = A 종류의 부품의 경우에는 40
          B 종류의 부품의 경우에는 50
4) 공정경로 :
    A 종류 부품 : t1-t2-t3-t4-t5-t6-t7-t8-t9-t10-t11-t12-t13-t14-t15
    B 종류 부품 : t1-t2-t9-t10-t11-t12-t13-t14-t3-t4-t5-t6-t7-t8-t15

5) 가정 : ① 모든 부품은 버퍼를 거쳐서 기계에 할당되고 기계가공을 마친 
            부품은 버퍼로 돌아온다.
         ② 또 하나의 플레이스에 두 개 이상의 토큰이 있을 때 이 토큰들에 
            의해서 활성화되는 트랜지션은 각각의 토큰에 의해서 활성화 되는 
            것으로 간주한다. 만약 t2u 가 토큰 B1 과 B2 에 의해서 활성화 
            된다면 t2uB1, t2uB2 처럼 표시한다.  
대상시스팀을 그림으로 나타내면 다음과 같다.


 
각각의 트랜지션이 의미하는 바는 다음과 같다.



t1 : 부품입력시작         t2 : 부품입력끝             t3 : 기계1로 운반시작  t4 : 기계1로 운반끝          t5 : 기계1 가공시작        t6 : 기계1 가공끝   
t7 : 기계1에서 운반시작      t8 : 기계1에서 운반끝      t9 : 기계2로 운반시작  t10 : 기계2로 운반끝         t11 : 기계2 가공시작       t12 : 기계2 가공끝   
t13 : 기계2에서 운반시작      t14 : 기계2에서 운반끝      t15 : 시스팀에서 인출




               트랜지션-플레이스 테이블은 다음과 같다.

  

전방조사를 수행해 나갈 때 얻을 수 있는 시스팀이 도달할 수 있는 상태들은 다음과 같다. 시스팀의 마킹으로 볼 때는 활성화된 트랜지션이지만 공정경로나 부품의 종류등을 고려할 때 교집합 트랜지션이 될 수 없는 트랜지션들은 밑줄을 이용하여 표시한다. 

초기상태   
초기상태에서 한 단계앞을 전방조사하면 S1이 된다. 따라서 초기 상태에서 한 단계 앞의 상태 클래스는 S1 이고 두 단계 앞의 상태 클래스는 S2 이고 세 단계 앞의 상태 클래스는 S3이다. 상태 S1의 한 단계 앞의 상태 클래스는 S2 이고 두 단계 앞의 상태 클래스는 S3 이고 세 단계 앞의 상태 클래스는 S4이다. 따라서 초기 마킹 M0 = (3, 2, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0) 에 대해서 SC1(M0) = {(t1c, S1)}, SC2(M0) = {(t1ct1c, S2)}, SC3(M0) = {(t1ct1ct2u, S3)} 이다. 


(t1c, 0, A1)   
S1       
                                  A1-3



상태 S1 의 마킹 M1 = (2, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0)  에 대해서 SC1(M1) = {(t1c, S2)}, SC2(M1) = {(t1ct2u, S3)}, SC3(M1) = {(t1ct2ut3c, S4)} 이다.




(t1c, 0, B1)
S2       
                              A1-3, B1-3



(t2u, 10, A1)
S3       
                             A1-4, B1-3



(t3c, 0, A1)
S4       
                                A1-5, B1-3



(t4u, 4, A1)
S5  
                              A1-6, B1-3



여기에서는 t1c와 t5c 두 개가 생존 트랜지션이다. 따라서 두 가지 가능성이 생긴다. 이 경우 S5에서 한 단계 앞의 전방에 있는 상태 클래스는 S5-1 와 S5-2 이다. 이 경우 S5 의 마킹 M5 = (1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0) 에 대해서 SC1(M5) = {(t1c, S5-1), (t5c, S5-2)} 이고 SC2(M5) = {(t1ct5c, S6), (t5ct5c, S6)},  SC3(M5) =((t1ct5ct2u, S7), (t5ct5ct2u, S7)} 이다.  이러한 식으로 계속해서 상태클래스를 구할 수 있다. 상태그래프는 하나의 상태에서 파생되는 상태클래스들을 노드로 하고 호에 (트랜지션, 발화시간, 토큰의 종류) 로 구성된 가중치를 붙임으로써 생성할 수 있다. 

( Case S5-1 ) t1c를 발화한 경우
(t1c, 0, B2)
S5-1  
                                                                    A1-6, B1-3, B2-3



( Case S5-2 ) t5c를 발화한 경우
(t5c, 0, B2)
S5-2  
                           A1-6, B1-3, B2-3




Case S5-1 의 경우 도달하는 상태 S5-1 이나 Case S5-2 의 경우 도달하는 상태 S5-2 모두가 t5c 를 발화하게 된다.  따라서 다음 번에 도달하게 되는 상태는 S6 이다.


(t5c, 0, A1)
S6  
                           A1-8, B1-3, B2-3



(t2u, 6, B1)
S7  
                           A1-8, B1-4, B2-3



(t9c, 0, B1)
S8  
                           A1-8, B1-12, B2-3



S8에서 발화할 수 있는 생존 트랜지션은 t2u 와 t10u 의 두 가지 경우가 있다. 

(Case S8-1)
(t2u, 4, B2)
S8-1     
                          A1-8, B1-12, B2-4



상태 S8-1 에서 발화해야 할 생존 트랜지션은 t10u 이다. 따라서 다음 단계에 도달할 수 있는 상태는 S9 이다.

(Case S8-2)
(t10u, 4, B1)
S8-2     
                          A1-8, B1-13, B2-3



(t11c, 0, B1)
S8-2-1   
                         A1-8, B1-15, B2-3



상태 S8-2-1 에서 발화할 수 있는 생존 트랜지션은  t2u 이다. 따라서 상태 S8-2-1 는 t2u를 발화시키고 상태 S10 로 가게된다.

(t10u, 4, B1)
S9  
                         A1-8, B1-13, B2-4



(t11c, 0, B1)
S10  
                         A1-8, B1-15, B2-4



(t6u, 20, A1)
S11  
                         A1-9, B1-15, B2-4



(t7c, 0, A1)
S12  
                         A1-10, B1-15, B2-4



(t8u, 4, A1)
S13  
                         A1-4, B1-15, B2-4



(t8u, 4, A1)
S14  
                         A1-4, B1-16, B2-4



상태 S14에서는 발화할 수 있는 생존 트랜지션이 하나도 없으므로 데드락 상태이다. 따라서 이러한 상황을 해결하기 위해서 역추적 및 지연 방법을 사용한다. 데드락에 도달한 상태에서 역으로 추적해서 최초로 버퍼에 부품이 들어가게 하는 트랜지션은 t7c 이다. 따라서 t7c 을 35초 지연시켜본 후 다시 전방조사를 수행해 보면 다음과 같다.

S11  
                         A1-9, B1-15, B2-4



(t7c 을 35초간 지연 시킨다.)
S12'     
                          A1-9, B1-15, B2-4



(t12u, 0, B1)
S13'     
                          A1-9, B1-16, B2-4



(t13c, 0, B1)
S14'     
                          A1-9, B1-17, B2-4



(t14u, 4, B1)
S15'     
                           A1-9, B1-4, B2-4



(t9c, 0, B2)
S16'     
                          A1-9, B1-4, B2-12



위에서 볼 수 있는 것처럼 상태 S11 에서 데드락을 방지하기 위하여 역추적및 지연 방법을 사용한 결과 상태 S16'에 이르러서도 발화할 수 있는 생존 트랜지션인 t10u 가 존재하므로 데드락 상황이 방지되어서 S16' 상태와 같이 데드락이 발생하지 않는 상태로 진행한다. 
이러한 방식으로 유연생산셀에서 사건이 발생할 때마다 위와같은 전방조사를 수행하면 유연생산셀을 통제할 수 있게 된다.








 제 5 장.  결론 및 추후 연구과제

지금까지 Controlled Timed 페트리네트를 이용한 유연생산셀의 통제에 대해서 알아보았다. 
현재의 상태에서 생존 트랜지션을 구한 후에 각각의 생존 트랜지션에 대해서 전방조사를 수행하였다. 전방조사 결과 새로운 상태클래스와 상태그래프가 생성되었으며, 이들을 이용하여 현재의 상태로부터 몇 단계 앞의 상황을 예측할 수 있었다. 또, 데드락과 같은 바람직하지 않은 상황에 도달하지 않도록 하는 통제 패턴을 내려 주는 것이 가능하였다. 
그러나 전방조사를 이용하여 새로운 상태를 예측하는 과정에서 데드락과 같은 바람직하지 않은 상황에 직면하게 되는 수가 있었다. 이런 경우에는 역추적 및 지연의 방법을 사용하여 데드락을 유발시키는 트랜지션을 찾아내서 일정시간동안 발화되는 것을 지연시킴으로써 데드락을 해결할 수 있음을 보였다. 
추후의 연구과제로서는 Controlled Timed 페트리네트 모형을 이용한 유연생산시스팀과 같은 좀 더 일반적이고 복잡한 시스팀의 통제에 대한 연구, 유연생산셀의 구성(Configuration) 변화에 따른 데드락 해결 기법의 연구, 계층적 통제구조에서의 Controlled Timed 페트리네트를 이용한 통제기법의 연구 등이 있다. 

</tdmsfiletext>
