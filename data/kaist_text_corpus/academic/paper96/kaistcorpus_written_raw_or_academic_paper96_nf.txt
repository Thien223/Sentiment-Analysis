<language> Korean </language>
<textcode> KSC-5601-1988 </textcode>
<process> raw </process>
<version> 2001(or)</version>
<filename> kaistcorpus_written_raw_or_academic_paper96_nf.txt </filename>
<title> 선형계획법 적산형의  자료구조와 재역산  기준에 관한  연구 </title>
<author> 김동환 </author>
<date> 1994 </date>
<publisher> 서울대학교 </publisher>
<kdc> TM530.96 </kdc>
<tdmsfiletext>
 I. 서론
  1. 연구목적
  선형계획법(Linear Programming)은 경영과학 분야에서 가장 널리 사용되고 있는 모형중의 하나이다.  이것은 모형 수립이 명료하고 해법이 잘 개발되어 있을 뿐만 아니라 대단히 많은 변수의 방대한 문제도 쉽게 다룰수 있기 때문에 시스템의 기획 및 설계 분야, 경영 관리 및 운영 분야, 공학 분야의 최적화 문제, 그 밖에 환경과 지역개발 문제 등 다방면에 걸쳐서 넓게 이용되고 있다.[1]
  이러한 선형계획 문제를 해결하는데 사용되는 해법은 Dantzig가 제안한 단체법(Simplex Method)이 널리 사용되고 있다. 단체법의 전산 프로그램 수행시 메모리 소요와 수행시간에 가장 많은 영향을 주는 부분은 기저역행렬의 계산과 보관 방법이다. 기저역행렬을 이론적으로 계산할 때는 (NROW NROW)차 행렬로 보관 계산하지만 이를 전산 프로그램으로 구현할 경우 실제적인 문제에 있어서는 기저 역행렬의 요소값이 영인 경우가 많이 발생하므로 영이 아닌 요소만 보관하고 계산하는 것이 효율적이다. 그래서 본 논문에서는
  첫째, sparse한 제약식 계수행렬(Constraint Coefficient Matrix)과 기저역행렬의 비영요소 보관에 대한 자료구조(Data Structure)를 개발하여 기억공간(Memory)의 소요를 줄임은 물론 비영요소만을 연산에 이용함으로써 불필요한 연산을 감소시키고자 한다.
  둘째, 적산형에 적절한 재역산(Reinversion) 시기를 찾아냄으로써 단체법의 실행과정에서 기저역행렬을 이용한 연산의 정확도를 향상시킴과 동시에 연산 속도를 향상시키고 아울러 정확한 해를 구하고자 한다.
  2. 연구동기
  공학 기술이 나날이 발전해감에 따라 그에 따른 공학적 도구의 발전속도가 눈부시게 빠르게 진행되고 있다. 이 기술발전의 산물 중 하나가  바로 개인용 컴퓨터(PC, Personal Computer)의 자료처리 용량 증대와 계산속도 및 정확성의 향상이다. 그로 인하여 최적화 기법(Optimization Method)의 여러 이론들을 프로그램화하여 실제 문제에 적용시켜 단 몇초 내지는 수분, 수시간 내에 수학적 최적해(Optimal Solution)를 얻어낼 수 있게 되었다. 이러한 발전은 선형계획법의 여러 해법들의 실제적 구현에도 적용되었다.
  지금까지 알려진 대부분의 선형계획법 프로그램은 단체법을 사용하여 최적해를 구하고 있다. 단체법은 매 단계의 계산이 하나의 정점가능해(Extreme Point Feasible Solution)에서 이웃한 정점 가능해로 이동해가면서 해를 구하는 방법이다. 이 기법은 대부분의 경우에 대단이 효율적으로 사용한다면, 일반적인 선형계획 문제를 최선의 방법으로 풀 수 있다. 그러므로 기저역행렬 보관법 중 하나인 적산형을 이용하여 개선된 자료구조를 구현함으로써 PC의 제한된 기억용량을 극복하고 재역산의 적절한 실시 시기를 선택하여 최적해(Optimal Solution)의 정확성을 보다 높일 수 있는 방안을 개발하여 일반적인 선형계획 문제에 있어 최선의 단체법을 구현해 보자는데 있다.
  3. 논문구성
  본 논문은 6개의 장으로 구성되어 있으며 각 장의 내용을 살펴보면 다음과 같다.
  제 1장에서는 본 논문의 연구목적과 연구동기에 대해 서술되어 있고, 제 2장에서는 제 1절에 적산형 역행렬 수정방법 및 재역산 기준에 대한 연구 현황이 서술되어 있다. 여기에서는 수정단체법(Revised Simplex Method), 적산형 역행렬 수정법 및 변형에 대해 서술하고 있으며 2절에서는 재역산 기준에 대해 서술하고 있다.
  3장은 연구내용을 서술하고 있는데 1절에서는 선형계획법의 sparse matrix를 효과적으로 처리할수 있는 계수 행렬, 적산형 역행렬의 비영요소 보관 자료구조를 제시하고 있다.  2절에서는 재역산 시기 산정에 관한 방안이 서술되어 있다.
  4장은 앞장에서 제시된 재역산 시기를 산정키 위해서 행해졌던 중간 과정들의 통계적 유의성의 검증과, 제시된 재역산 시기의 실제적 효용성을 실증하기 위한 실험 및 결과, 결과 분석이 행해지고, 제 6장에서는 실험결과를 전체적으로 분석하여 예상했었던 기대효과와 비교함으로써 본 논문의 연구내용에 대한 결론과 추후에 행해져야 할 연구 방향에 대해 언급하고 끝맺음하고 있다.
II. 연구현황
  1. 적산형 역행렬 계산법
   1.1 수정 단체법
    일반적인 LP 문제의 형태를 행렬 형태로 표현하면 다음과 같다.  
|
|
  여기서, C는 (1 N) 행벡터, X, l, u는 (N 1) 열벡터, b는 (M 1) 열벡터 그리고 A는 (M N) 행렬이다.
이와 같은 문제를 해결하는 해법으로 널리 알려진 수정 단체법(Revised Simplex Method)의 전체적인 흐름은 아래와 같은 단계를 따른다.
                                  



위의 계산 과정에서 기저역행렬의 수정은 [단계 5]에서 이루어지며 나머지 각 단계의 연산들도 역행렬을 이용하여 수행함으로 를 정확하게 유지하고 수정하느냐에 따라 전체 해법의 수행속도 및 최종해의 정확도에 지대한 영향을 미친다.
   수정 및 보관 방법으로 널리 알려진 것으로는 명시형(Explicit Form), 적산형(Product Form), 상하 분해형(LU Factorization), Cholesky 분해형, QR 분해형 등이 있다. 이 중 적산형 기법에 관한 연구는 Smith & Orchard-Hays(1963), Wolfe & Culter(1963), Larsen(1962), Orchard-Hays(1968), 차동완 외 2인(1988) 등의 많은 연구가 있다. 이들 연구에서는 명시형보다는 적산형이 계산속도, 연산정확도, 메모리 이용면에서 효율적이라고 알려져 있다. 이외에도 적산형의 변형들도 연구되어 "Round-Off Error"를 감소시키는 방법들이 개발되어 있다.
   1.2 적산형 역행렬 수정법 및 변형
  적산형으로 기저역행렬을 보관할 경우 선형계획 해법에서의 우월성은 
      
  1) Sparse, Packed된 원행렬(Original Matrix)를 가지는가 ?
  2) 기저(Basis)를 재역산할 때 가능한 적은 수의 비영요소를       발생시키는가 ?
  3) 최적의 재역산 빈도를 사용하는가 ?

에 달려 있다고 알려져 있다.[4] 그러므로 적산형의 효율성을 제고하는데 있어서 중요한 것은 기저의 수정 방법과 재역산 기준 및 방법에 달려 있다고 할 수 있다.
  적산형은 모든 행렬이 항상 기본행렬(Elementary Matrix)의 곱으로 표현될 수 있다는 성질을 이용하여 다음과 같이 를 보관한다.
지금 행렬 A가 다음과 같이 주어졌다고 하자.



여기서 기본행렬 을 다음과 같이 두자. 기본행렬이란 하나의 열(Column)을 제외한 모든 열이 단위 벡터(Unit Vector)인 행렬을 말한다.

           단, 

그러면 는


가 된다. 첫 열은 단위 벡터가 된다.


           단, 

그러면 라고 두면



가 된다.
  이와 같이 를 정의하면

가 된다. 이 식에서
                    [1-2]
이 된다. 이것은 주어진 행렬의 역행렬은 기본행렬의 곱으로 표현된다는 것을 알 수 있다. 그러므로 적산형에서는 매회 발생하는 eta-vector들과 이 eta-vector들의 열의 위치들만 기억하고 있으면 필요할 때마다 를 계산하게 된다.
  지금
                   [1-3]
이라고 하자. 그러면 가 사용되는 단체승수 계산(BTRAN)과 진입열 수정(FTRAN) 단계에서는 

      [1-4]
와 같이 수행하면 된다. 의 계산은 기저가 변할때마다 생기는 하나의 eta-vector만 이전의 eta-vector들의 곱에다 곱해주면 되므로 행렬 연산이 아닌 벡터 연산을 수행함으로 연산속도면에서도 훨씬 빠르다.[1][8]12]
  적산형으로 를 보관하여 컴퓨터에서 프로그램을 수행할 경우 임의의 실수를 기억공간(Memory)에 기억시킬때 그 수를 정확하게 표현할 수는 없다. 즉, 단정도(Single Precision)로 실수를 기억시킬때 최대 유효숫자는 십진법으로 6자리이다. 따라서 7자리 이상의 유효숫자를 갖는 임의의 실수는 오차를 가진 채로 컴퓨터의 주기억 공간에 기억되며, 컴퓨터로 모든 계산을 수행할 때 발생하는 수들의 정확성을 최대한으로 보장할수록 보다 정확한 값을 얻을수 있게된다. 그래서 기존의 기법을 개선한 보다 효율적인 기법이 MPFI(Modified Product Form of Inverse)이다.[2]
  적산형 기법에서 를 만드는데 있어 선회요소(Pivot Element)로 나누기를 함으로써, 일반적으로 그 나누어진 수는 원래의 수보다 소숫점 이하로 많은 자릿수를 갖게 됨에 따라 컴퓨터가 기억하는 과정에서 "Round-Off Error"가 발생하므로, 이것을 제거시키기 위하여 선회행에 대하여 선회요소로 나누는 것을 일단 보류하고, 그 다음 단계에서 나누기 계산을 수행하면 약간의 "Round-Off Error"를 감소시키게 된다. 그 이유는, 한 단계 늦추어서 를 곱하고 나서 선회요소로 나누어진 계산의 결과에서 발생하는 수는, 원래의 수가 이미 를 곱한 후이므로 그 수는 상당히 작은 "Round-Off Error"를 갖게되기 때문이다.
  그러므로, "Round-Off Error"를 감소시키려는 방법으로 기본의 적산형 기법을 수정하여 만든 것이 MPFI 기법이다. MPFI는 적산형에서의 를 하나의 대각행렬(Diagonal Matrix) 의 역행렬과 와 유사한 행렬인 로 분해하여(즉, ) 를 다음과 같이 나타낸다.
  [1-5]
여기서 는 t번째 행의 대각 원소가 선회요소로 된 대각행렬이다. 그리고, 는 와 비슷하며 t번째 행의 대각 원소가 1인 점이 다른 다음과 같은 행렬이다.



이 방법은 적산형 기법에서 나누기 계산을 한 단계 후에 처리하는 것과 같으며 "Round-Off Error"를 감소시키게 된다. 이 MPFI는 를 나타낼 때 기억용량을 를 기억시키는 얀만큼이나 더 필요한 것처럼 보이나, 실제로 를 기억시키지 않으며 의 t번째 대각 원소를 그대로 선회요소로 기억시킴으로써 를 기억시킨 것과 같아지며, 의 계산에서는 제외시키게 된다.
  2. 재역산 기준
  선형계획법 문제를 단체법을 이용하여 계산을 계속하게 되면 "Round-Off Error"가 쌓이게 된다. 그래서 적절한 시기에 를 다시 만들어야 한다. 이 작업을(Reinversion)이라고 한다. 이러한 재력산을 수행함으로써 그동안 누적되었던 오차를 없애며 에서 불필요한 항을 제거시킴으로써 계산속도를 빠르게 할 수 있다. 이 재역산 기준으로는 다음의 기준을 사용하여 수행할 수 있다.

     1) 단체계산 횟수, 예로써 메 30 - 50 회마다 재역산을           실시한다.
     2) 4사 5입 오차, 즉 | | 또는 | |          가 허용오차, 예로써 , 를 넘을때 재역산을 실시          한다.
     3) Eta-vector가 허용된 기억공간을 넘을 때 재역산을 실          시한다.

  명시형에서 기저(Basis)가 변할때마다 새로운 가 생기듯이 적산형에서도 기저에 변화가 생길때마다 새로운 eta-vector가 생성되어 보관된다. 단체법의 대부분의 연산들은 와 관련되어 있는데 이러한 eta-vector를 너무 많이 보관하고 있으면 기억용량의 낭비를 초래할 뿐 아니라 "Round-Off Error"를 야기시킨다. 그리고 계산을 위해 eta-vector를 기억장소로부터 꺼내고 새로 생긴 eta-vector를 저장시키는데 많은 시간을 요하게 되어 전체적인 프로그램의 수행시간이 늘어나게 된다.
  이러한 이유에서 적절한 시기에 위에 제시한 기준으로 재역산을 수행하여야 한다. 이런 기준 외에도 일반적인 응용 프로그램들에서는 컴퓨터의 주기억 장치의 전송시간(Transfer Time)을 기준으로하여 재역산을 실시한다고 알려져 있다.
  앞에서 언급한 시간 모형과는 다르게 별도의 재역산 시기의 결정없이 단체계산동안 누적된 "Round-Off Error"를 어떤 허용오차(Error Tolerance)와 비교하여 재역산을 실시하기도 하는데 여기에 쓰이는 허용오차에는 다음과 같은 것들이 널리 사용되고 있다.[6]

     1) TOLDJ() ; 할인가(Reduced Cost)와 관련된 허용          오차로써 만약  TOLDJ이면 현재의 해가 최적          해이다.
     2) TOLAIJ() ; 행렬계수에 대한 허용오차로써 만약          행렬요소 의 크기가 TOLAIJ보다 작으면 0으로 간          주한다.
     3) TOLPIV() ; 선회요소에 대한 허용오차. 선회요소          의 크기가 TOLPIV보다 작은 것은 피하고 만일 모든          선회행의 요소가 이보다 작으면 재역산을 수행한다.
     4) TOLRHS() ; | |를 계산하여 이 허용오          차보다 크면 재역산을 수행한다.

  이런 기준들은 개별적으로 이용되기도 하지만 보통 조합하여 이용된다. 이외에도 앞에서 언급한 재역산 시기 산정 모형 중 Timing Model은 알고리듬(Algorithm)에서 소비되는 실제시간(Actual Time)을 가지고 총시간(Total Time)을 최소화하는 재역산 빈도를 계산하는 모형이다. 이 모형을 살펴보기 전에 먼저 기호를 다음과 같이 정의하자.

         k : 총 반복(Iteration)수 
         R : 재역산 빈도(Frequency)
          F : 재역산 후의 첫번째 iteration의 평균시간(Average                   Time)
         G : iteration당 증가 시간
         I : 재역산에 필요한 평균소요시간

그러면 총시간은



위의 식[1-6]은 다음과 같이 근사화(Approximation) 시킬 수 있다. 

   

이 식 [1-7]을 최소화하는 R을 구하면 즉,
   

위식에서 구해진 의 빈도로 재역산을 실시하면 총시간을 최소화 한다고 한다.[14]
III. 연구 내용
  1. Sprse Matrix 처리 적산형 단체법 자료구조의 설계
   1.1 계수행렬의 비영요소 보관 자료구조
  게수행렬 A를 NROW NCOL차 행렬로 보관하려면 다음과 같은 변수만 있으면 해결될 것이다.


[표1] A행렬 보관을 위한 선언 변수와 역활(영요소 포함)

그러나 이러한 자료구조는 희박도(Sparsity)가 높은 행렬을 보관할 때에는 기억장소의 낭비가 너무 많으므로 비영요소만 보관하여 사용하는 것이 효율적이다. A행렬의 비영요소 보관을 위한 자료구조를 위해 다음과 같은 변수들이 선언되어져야하며 각 변수의 역활은 아래의 표와 같다.



[표 2] A행렬의 비영요소 보관을 위한 선언변수와 역활
이와같이 선언한 변수들을 가지고 계수행렬을 보관하는 자료구조는 [그림 1]과 같다. 이 자료구조의 특징은 계수행렬의 비영요소 값과 그 요소의 행지수를 보관하고 비영요소의 값을 열시작 주소 배열 즉, COLI[]을 참조하여 찾아간다. 그리고 계산의 효율을 위해 각 열의 비영요소 갯수를 보관한다.

     ⊙ 열시작 주소, 비영요소 수(COLI[], CLN[])




     ⊙ 비영요소값, 행번호(AN[],RN[]) 



[그림 1] A행렬 비영요소보관 자료구조

위와 같은 자료구조에서 실제적으로 다음과 같은 제약식 계수 행렬을 보관하는지 살펴보자.

  

즉, 



[그림 2] A행렬 비영요소 보관예

   예를 들어 의 값이 알고 싶다고 하자. 먼저 AN[]배열에서 1열의 시작주소 COLI[1]는 1이다. 그리고 k를 1부터 CLN[1]까지 증가시키면서 RN[1+k-1]이 3행의 위치를 찾는다. RN[2]에서 3행이 되므로 AN[2]의 값 2가 원하는 값이다.
   1.2 Eta-vector 비영요소 보관 자료 구조
  Eta-vector를 보관하는 자료구조는 앞절의 계수행렬 보관과 크게 다를 바가 없으며 이를 위해 사용되는 배열과 그 역활은 다음과 같다.


[표 2] Eta-vector 비영요소 보관을 위한 선언변수와 역활

이와 같이 선언한 변수를 가지고를 보관하는 자료구조의 특징은 각 eta-vector의 비영요소 값과 행지수를 보관하고 각 eta-vector의 비영요소 값은 eta-vector의 시작주소 배열 즉, ETAINI[]을 참조하여 찾아간다.  그리고 비영요소 값만 연산에 이용하기 위해 각 eta-vector의 비영요소 갯수를 보관하며 새로운 eta-vector가 생길때마다 비영요소만 배열 BIN[]에 차례로 보관한다.




     ⊙ Eta-vector 시작 주소, 비영요소 수(ETAINI[], ETALN[])

  

     ⊙ Eta-vector 비영요소값, 행번호(BIN[], ETARN[]) 



이와같이 설계된 자료구조에 지금 다음과 같은 2개의 eta-vector를 생성했을 때 보관을 어떻게 하는지 살펴보면,






[그림 4] Eta-vector 비영요소 보관예
BIN[]에 비영요소들만 차례대로 보관된 eta-vector들은 기저 역행렬값이 필요할 때마다 각 eta-vector의 BIN[]에서의 시작위치를 ETAINI[i] (i=1,      , NETA)를 참조하여 그 위치의 값을 찾아 계산해낼 수 있다.


   1.3. 기억공간 소요 분석
  앞에서 살펴본 자료구조의 설계 결과로써 기억공간 소요는 다음의 표와 같다.



[표 3] 기억공간 소요 계산

위의 계산에서 알 수 있듯이 계수 행렬 및 eta-vector의 비영요소 수가 적으면 즉, 밀도(density)가 낮으면 비영 요소만 보관하는 자료구조가 훨씬 유리하다. 하지만 밀도가 높다면 모든 요소를 보관하는 쪽이 유리하다.


2. 적산형의 재역산 시기에 대한 연구
  단체법의 수행 과정 중 기저가 변할 때마다 새로운 하나의 eta-vector가 생성되는데 이 eta-vector의 수가 NROW개보다 훨씬 많아진다면 명시형보다 기억 소요면에섵나 계산속도면에서 유리하다고 할 수 없으며 오차의 누적면에서도 유리하다고 볼 수 없다. 그러므로 적당한 시기에 재역산을 수행해 새롭게 eta-vector들을 만들어 주어야 한다. 단체법의 반복 횟수(iteration) 연산량의 관계를 살펴 보면 재역산을 실시하지 않을 경우 반복횟수가 증가함에 따라 연산량도 증가하는 형태를 가지게 되며([그림 5]) 재역산을 실시할 경우 재역산 적용시기 전까지는 재역산을 실시하지 않을 때와 동일하게 증가하고 거기에 재역산을 실시하면 재역산 과정 속의 연산량만큼 연산량이 늘어났다가 끝난 후에는 n개의 새로운 eta-vector가 만들어지므로 이것만큼의 연산량으로 줄어들게 된다. 여기서 단체 계산 중에 생기는 새로운 eta-vector는 이전의 eta-vector들의 곱에 의해 만들어지는데 이 때 비영요소 수가 늘거나 줄기도 한다. 그래서 각 eta-vector의 비영요소 수를 추정해낼 수 있다면 eta-vector를 이용한 연산 횟수를 계산해낼 수 있다. 그래서 이것으로 각 iteration의 연산 횟수와 총연산 횟수를 계산할 수 있다. 재역산 시기는 이런 총연산 횟수를 최소화시키는 시기로 결정할 수 있을 것이다.  이에 대한 방안의 흐름은
  첫째, eta-vector의 비영요소 수를 추정하는 식을 만들고,
  둘째, 이 식을 바탕으로 eta-vector를 이용한 연산들의 연산량을 계산한다.
  세째, 두번째 단계에서 구한 계산량을 바탕으로 재역산을 실시하지 않을 때 단체법에서의 각 iteration의 연산량을 계산한다.
  마지막으로 임의의 k번재 iteration에서의 재역산을 실시하지 않았을 때의 연산량보다 재역산을 실시했을 때의 연산량이 작아지는 최초의 시점을 찾아서 재역산 시기로 삼는다.([그림 6])






















[그림 5] 단체법의 연산 횟수와 연산량의 관계








 
☞ 재역산을 수행하는 시기 k를 결정

[그림 6] 재역산 시기 선정을 위한 방안의 흐름
   2.1 Eta-vector의 비영요소 수 추정
  재역산 시기 선정을 위한 첫번째 단계로 eta-vector의 비영요소 수를 추정하는 식을 구해야 한다. 기저가 변할 때마다 새로이 생성되는 eta-vector는 다음과 같이 구해진다. 먼저
  ; i번째 -vector
  ; i번째 단체계산의 진입열 벡터
라 정의하자. 그러면



과 같은 관계로 얻어진다. 위의 식에서   표시는 우변의 항에 의해 좌변의 항이 구해진다는 의미이다. 여기서 다음과 같은 가정을 하자.




위와 같은 가정 하에서 각 eta-vector의 비영요소 수는 다음과 같이 계산되어질 수 있다. 먼저 기호를 다음과 같이 정의하자.
 Ni ; i-번째 eta-vector의 비영요소 수
 d ; 전체 문제의 density
 n ; 제약식 갯수
그러면 i-번째 eta-vector의 비영요소 수는 다음의 식과 같이 (i-1)번째 eta-vector의 비영요소 수에 의해 설명되어질 수 있는 순환식(recursive equation)의 형태로 나타난다.




위의 식들이 어떻게 구해졌는지 살펴보면 N1은 간단히 구해지며, N2를 살펴보면 N1만큼의 비영요소 수에다 새로이 만들어지는 E2에 새로운 비영의 요소가 생기는 수, 즉 E1의 영의 요소수에다 새로운 진입열의 비영요소의 확률과 새로운 eta-vector에서 비영요소가 생길 확률의 곱의 합으로 표현되어질 수 있다. 이런 식으로 계산을 계속하면 Ni도 쉽게 구할 수 있다. 즉, Ni식은 식 [2-3]과 같이



구해진다. 이를 정리하면 앞의 순환식과 같아진다. 예를 들어 살펴보면 다음과 같은 문제에서의 eta-vector의 비영요소 수 추정값과 실제 비영요소 수의 결과를 살펴보면



iteration 1)
단계 1] 
단계 2] 
단계 3]

       
단계 4] 
         최소 비율 검정을 하면 탈락변수는 x6
단계 5]  
             

       * 실제 eta-vector의 비영요소 수 = 3
       * 추정 비영요소 수 
          N1 = NROW   d = 3   1.0 = 3
                 
iteration 2)
단계 2] 
단계 3]

       
단계 4] 

       최소 비율 검정을 하면 탈락변수는 x5

단계 5]  
             

       * 실제 eta-vector의 비영요소수 = 3
       * 추정 비영요소수 
         
        

iteration 3)
단계 2] 
단계 3]

      모든 비기저변수의 할인가가 비음이므로 현재의          해가 최적.


   2.2 Eta-vector를 이용한 단체연산의 연산횟수 계산
  재역산 시기를 선정하기 위한 두번째 단계로써 eta-vector를 이용한 단체법에서의 각 연산들의 연산량을 계산하여야 한다. 연산량을 계산하는 이유는 단체법의 연산의 대부분이 기저 역행렬과 관련되어 있어서 적산형의 경우 eta-vector가 몇개인가에 따라 연산량이 달라진다. 그래서 이 연산량을 기초로 재역산 기준을 설정키 위해서 앞 절의 결과를 가지고 연산량을 계산한다.
eta-vector는 매 회 생성되는 것이 아니라 기저에 변화가 발생했을 경우에만 새로이 생성된다. 그래서 단체횟수가 많더라도 생성되는 eta-vector의 수는 상대적으로 작을 수도 있다. eta-vector를 이용하는 단계 이름과 연산에는 다음과 같은 것들이 있다.



[표 4] 단체법의 eta-vector 관련 연산

위의 연산들의 연산량을 계산하면 다음과 같은 식들이 나올 수 있다. 덧셈 연산과 곱셈 연산에는 시간의 차이가 있으므로 구별하여 계산하였다.




  결론적으로 위의 덧셈 연산량과 곱셈 연산량을 합하면 단체법의 각 반복에서의 총연산횟수가 된다. 위와 같이 얻어진 연산횟수 계산식을 가지고서 앞절의 식에 적용시켜 살펴보자.


iteration 1)

단계 2] 
     *의 실제 곱셈 연산횟수 = 0
     *의 실제 덧샘 연산횟수 = 0
     *의 추정 곱셈 연산횟수 = 0
     *의 추정 덧셈 연산횟수 = 0

단계 4] 

     *의 실제곱셈 연산횟수 = 0
     *의 실제 덧샘 연산횟수 = 0
     *의 추정 곱셈 연산횟수 = 0
     *의 추정 덧셈 연산횟수 = 0
      최소비율검정을하면 탈락변수는 
단계 5]  
             
        

     *의 실제 곱셈 연산횟수 = 5
     *의 실제 덧샘 연산횟수 = 2
     *의 추정 곱셈 연산횟수 = 5
     *의 추정 덧셈 연산횟수 = 2


iteration 2)
단계 2] 

     *의 실제 곱셈 연산횟수 = 5
     *의 실제 덧샘 연산횟수 = 2
     *의 추정 곱셈 연산횟수 = 5
     *의 추정 덧셈 연산횟수 = 2



단계 4] 

     *의 실제 곱셈 연산횟수 = 0
     *의 실제 덧샘 연산횟수 = 0
     *의 추정 곱셈 연산횟수 = 0
     *의 추정 덧셈 연산횟수 = 0
     최소 비율 검정을 하면 탈락변수는 x5
단계 5]  
        
                    
     *의 실제 곱셈 연산횟수 = 10
     *의 실제 덧샘 연산횟수 = 4
     *의 추정 곱셈 연산횟수 = 10
     *의 추정 덧셈 연산횟수 = 4

      


iteration 3)
단계 2] 
     *의 실제 곱셈 연산횟수 = 10
     *의 실제 덧샘 연산횟수 = 4
     *의 추정 곱셈 연산횟수 = 10
     *의 추정 덧셈 연산횟수 = 4
단계 3]

     모든 비기저변수의 할인가가 비음이므로 현재의 해       가 최적.

   2.3 재역산 시기 산정
  적산형으로 기저역행렬을 보관할 경우 단체법의 효율성에 있어서 주안점이 되는 것은 재역산 기준과 방법이라고 II.1.2에서 언급한 바 있다. 본 논문에서는 연산량을 기초로한 재역산 시기를 산정하는 것이 목적이므로 앞절의 단계에서 구한 연산횟수 계산식을 이용하여 재역산을 실시하지 않을때와 재역산을 실시할 경우의 총연산횟수를 계산해야 한다. 재역산을 실시하게 되면 현재의 기저를 가지고 새로운 NROW개의 eta-vector를 만들고 해를 계산하는데 이때의 연산량은 다음과 같다. 지금 k회에서 재역산을 실시한다고 한다면 



과 같이 된다. 그러면 앞의 계산 결과를 바탕으로 어느 시점에서 재역산을 실시할 것인가가 문제이다.  덧셈 연산과 곱셈 연산에 필요한 시간을 p,  라 둘때 재역산을 실시하지 않을때와 재역산을 실시할때의 itreration k에서의 총계산시간은 식 [2-6], [2-7]과 같이 된다.

재역산 시기는 k를 n+1부터 한단위씩 늘려가면 최초로



식 [2-8]이 성립하는 k를 찾아내서 재역산 시기를 삼고 재역산 간격을 (k-n)으로 잡는다.

IV. 실험 및 결과분석
1. 실험도구 및 실험기기 선정
  앞의 III.2의 적산형의 재역산 시기를 위해 작성된 부프로그램은 다음과 같다.

  ⊙ INISOLNp : 적산형 단체법의 초기해 구함.
  ⊙ BTRANNp : 단체승수 계산.
  ⊙ FTRANNp : 진입열 수정.
  ⊙ UPBINVNp : 새로운 eta-vector 생성.
  ⊙ UPSOL2Np : 해수정.
  ⊙ REINVNp  : 적산형으로 재역산 수행.

PC에서는 임의의 선형계획 문제 생성을 위해서 LPGEN20을 이용하였고 재역산 기준의 효율성 여부를 검증하기 위해서는 UNIX 운영 체제환경하에서 Netlib Test 문제를 이용하였다.  이들 프로그램들은 모두 Borland C++ Compiler Ver. 3.1 환경하에서 작성되었다.
  실험에 사용된 컴퓨터는 LPGEN으로 생성된 문제는 PC를 사용하고 Netlib문제는 Work Station을 사용하여 실험하였다.

  ⊙ IBM PC 386 호환 기종.
     주기억장치 용량 : 4 Mbyte
     Hard Disc 용량 : 122 Mbyte
     운영체제 : DOS 6.0
  ⊙ Work Station(HP-715/33)
     주기억장치 용량 : 32 Mbyte
     Hard Disc 용량 : 900 Mbyte
     운영체제 : HP-UX


2. Eta-vector 비영요소 수 추정식의 검증
  새로이 생성되는 eta-vector의 비영요소 수는 계수행렬의 비영요소의 분포에도 영향을 받으며 이전의 eta-vector들의 비영요소 수에도 영향을 받는다. 따라서 앞장에서 제시된 비영요소 수 추정식이 어느정도 통계적으로 유의한지 검증할 필요가 있다.

【 실험 1 】Eta-vector의 비영요소 수 추정평균과 비영요소 수              실제평균의 비교
  
  문제 크기 : 10 20, 20 30, 30 40, 40 40
  A행렬의 밀도 : 10%, 20%, 30%, 40%, 50%, 60%, 70%,                          80%, 90%,100%

【 실험 결과 】
문제 크기와 밀도에 따른 eta-vector들의 총비영요소 수의 실제값과 추정값은 아래의 [표 5]와 같고, 이를 그래프 비교하여 나타내면 [그림 7],[8],[9],[10]와 같은 형태로 나타난다.
   

[표 5] Eta- vector의 총비영요소 수의 추정값와 실제값의 비교 











[그림 7] 10 20 문제에서의 각 density별 eta-vector의 총비영           요소 수의 추정값과 실제값











[그림 8] 20 30 문제에서의 각 density별 eta-vector의 총비영          요소 수의 추정값과 실제값 











[그림 9] 30 40 문제에서의 각 density별 eta-vector의 총비영          요소 수의 추정값과 실제값 











[그림 10] 40 40 문제에서의 각 density별 eta-vector의 총비영          요소 수의 추정값과 실제값 

앞의 결과를 가지고 문제크기와 density에 따른 eta-vector의 비영요소 수의 실제 평균과 추정 평균은 아래의 [표 6]와 같고, 이를 그래프로 표현한 것이 [그림 11],[12],[13],[14] 이다.

             
[표 6] Eta- vector의 비영요소 수의 실제 평균과 추정 평균의 비교 

【 결과 분석 】
위의 결과에서 알 수 있듯이 eta-vector의 비영요소 수의 실제값보다 추정값이 over-estimate하는 경향이 있다는 것을 알 수 있는데 이는 실제에서는 각 eta-vector의 비영요소 수는 늘어나기도 하고 줄어들기도 하는 반면에 추정식에의한 비영요소 수는 꾸준히 증가하는 형태를 가진다. 그 이유는 비영요수 수 추정식이 이전의 eta-vector의 비영요소 수에다 새로운 진입열의 비영요소의 확률과 새로운 eta-vector에서 비영요소로 바뀔 확률의 곱의 합으로 표현되는데 여기서 사용되는 확률들은 계속 증가함으로 이런 결과가 생긴다. 그러나 추정식의 결과가 실제치에 근사하다는 결과를 얻었다.












[그림 11] 10 20 문제에서의 각 density별 eta-vector의 비영요           소 수의 실제 평균과 추정 평균










[그림 12] 20 30 문제에서의 각 density별 eta-vector의 비영요           소 수의 실제 평균과 추정 평균











[그림 13] 30 40 문제에서의 각 density별 eta-vector의 비영요           소 수의 실제 평균과 추정 평균











[그림 14] 40 40 문제에서의 각 density별 eta-vector의 비영요           소 수의 실제 평균과 추정 평균 
3. Eta-vector와 관련된 단체연산의 연산횟수의 검증
  Eta-vector들의 비영요소 수 추정식이 실제와 근사하다는 결과를 앞의 실험에서 얻었다. 이를 바탕으로 eta-vector와 관련된 단체법의 각 연산들 즉, 단체승수 계산, 진입열 수정 등의 추정 연산횟수를 구할수 있다. 여기서도 추정값과 실제값의 관계를 통계적으로 검증, 분석해 볼 필요가 있다.

【 실험 2 】Eta-vector 관련 단체 연산의 연산횟수, 총연산횟수              의 실제값과 추정값의 비교

  문제 크기 : 40 40
  A행렬의 밀도 : 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%,                    90%,100%

【 실험 결과 】절대 오차 = | 실제연산횟수 - 추정연산횟수 |
Eta-vector들의 비영요소 수를 추정한 후 이 결과를 가지고 이들과 관련된 단체연산들의 연산 횟수를 계산하여 실제 연산 횟수와 비교한 것은 아래의 [표 7]과 같으며 이를 그림으로 표현한 것이 [그림 15],[16]이다.


[표 7] Eta- vector 관련 단체연산횟수의 절대오차와 총연산횟수

【 결과 분석 】
위의 표에서 보는 바와 같이 eta-vector와 관련된 개개 연산에 있어서 오차는 어느정도 있는데 이는 eta-vector의 비영요소 수 추정치가 over-estimate, 증가 경향때문이다. 절대오차면에서 밀도에 상관없이 해의 수정과 관련된 연산횟수의 추정이 가장 오차가 크다. 그리고 Density가 높을수록 아주 근사한 결과를 얻었지만 Density가 낮다고 해서 오차가 많이 누적된다는 결론을 내릴 수는 없는것 같다. 그보다는 계수행렬의 비영요소의 분포에 오차가 영향을 받는것 같다. 그러나 덧셈과 곱셈의 총연산 횟수의 비교에 있어서는 추정치가 실제치와 근사하다는 결론을 얻을 수 있다. 











[그림 16] 밀도별 각 연산횟수의 실제치와 추정치의 비교












[그림 17] 밀도별 각 연산별 연산횟수의 절대오차












[그림 18] 각 연산별 연산횟수의 절대오차의 percentage

4. 재역산 수행 기준의 효율분석
  앞의 2, 3절의 결과를 토대로 재역산을 실시하지 않을때와 실시할때의 총 연산횟수, 총 계산시간을 계산해서 적산형의 재역산 기준으로 설정할 수 있다. 이 재역산 기준을 Netlib 문제에 적용시켜 실제적인 효율성을 단체계산 횟수를 기준으로 본 연구에서 제시한 재역산 기준을 사용한 경우와 사용하지 않은 경우를 비교 실험해보았다.

【 실험 3 】재역산 기준의 효율 분석

  대상 문제 : Netlib Test 문제

【 실험 결과 】

Eta-vector의 비영요소 수를 바탕으로 계산한 연산횟수를 추정 연산횟수 재역산 기준을 적용했을 경우와 적용하지 않았을 경우의 총 반복횟수면에서의 비교, 실험 결과는 아래의 [표 8]과 같다.

【 결과 분석 】
위의 [표 8]에서 * 표시가된 부분은 연산횟수를 기초로한 재역산 기준을 적용하지 않을때보다 총 반복 횟수가 늘어난 경우이다. 재역산 실시 시기를 살펴보면 문제의 제약식 수와 근사한 결과를 얻었다. 재역산 시기가 문제의 총 반복 횟수보다 큰 경우에는 즉, afiro, sc50a, standata 등, 재역산 기준을 적용할 경우와 아닐 경우에 차이는 없다. 재역산 시기 산정모형을 보면 제약식수를 기초로 비영요소의 수를 추정하고 이를 바탕으로 관련 연산의 연산량을 계산해내므로 문제의 제약식수에 영향을 많이 받는 것 같다. 재역산 기준을 적용했을때에 총 반복 횟수가 늘어나는 것은 재역산을 실시해서 NROW개의 eta-vector를 새로이 만들어냄으로써 의 오차가 줄기보다는 오차가 늘어나서이다.
  결론적으로 총연산횟수를 기준으로한 재역산 기준을 다른 재역산 기준(예를 들자면 허용오차에 의한 재역산 수행)과 함께 사용한다면 반복횟수와 계산시간면에서 효율적일 것이다.
V. 결론 및 추후 연구 방향
  본 연구에서는 적산형 단체법의 sparse matrix 처리를 위한 자료구의 설계와 재역산 기준에 관하여 그 모형들을 제시하고 재역산 모형의 효율성에 대해서 실험을 통해 비교 분석하였다.
  Sparse matrix 처리를 자료구조에는 계수행렬과 eta-vector를 비영요소만 보관하는 구조로 설계하여 density가 낮은 실제 문제에 적용에 있어 불필요한 기억공간 소요를 절감하엿고 계산 효율을 향상시켰다.
  재역산 기준 설정의 경우 연산량의 추정식을 기초로 기준을 제시하였는데 이 기준은 문제의 제약식수를 기초로 eta-vetor의 비영요소 수를 추정하여 얻어지는데 비영요소수의 추정치와 실제치와의 차는 문제의 밀도보다는 계수행렬의 비영요소의 분포에 영향을 받는다 것을 알수 있었다. 이를 바탕으로 계산한 재역산 시기를 실제 문제에 적용시켜본 결과 총반복횟수를 줄이는 결과를 얻었다.
  본 연구 이후에 이루어져야 할 추후 연구로는 
  첫째, sparse matrix 처리를 위한 자료구조에서 의 특정 요소를 참조하고자할 경우 그 값을 계산하는데 시간이 꽤 소요된다, 이 문재의 처리를 위한 보완된 자료구조의 개발이 필료하다.
  둘째, eta-vector의 생성시기의 추정이다. eta-vector와 관련된 연산량의 계산실험 결과에서 알수 있듯이 맨처음 eta-vector가 언제 생성될지 알 수 없다는 것이다. 이것을 근사하게 추정해낼 수만 있다면 여기서 제시한 재역산 기준이 보다 좋은 결과를 가져올 것으로 기대된다.
  세째, 재역산 수행 방법에 대한 연구이다.  재역산 수행 방법을 보다 효율적으로 함으로써 재역산 수행 시간의 감소, 프로그램의 수행시간 단축 및 정확한 해를 기대할 수 있을 것이다. 

</tdmsfiletext>
