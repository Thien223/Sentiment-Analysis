<language> Korean </language>
<textcode> KSC-5601-1988 </textcode>
<process> raw </process>
<version> 2001(or)</version>
<filename> kaistcorpus_written_raw_or_academic_paper96_nk.txt </filename>
<title> 양방향 궤도를 가진 다수의 자동유도운반차 시스템의 통제에  관한 연구 </title>
<author> 박종덕 </author>
<date> 1994 </date>
<publisher> 서울대학교 </publisher>
<kdc> TM530.961 </kdc>
<tdmsfiletext>
Ⅰ. 서  론 

 
자동유도운반차 시스템(Automated Guided Vehicle System: AGVS)은 유연생산시스템(FMS)의 한 부분으로써 작업장에서 물자배급 및 수거기능을 수행하는 여러 자동유도운반차의 운영시스템을 뜻한다.  자동유도운반차(Automated Guided Vehicle: AGV )는 전자기 또는 광막기능에 의한 자동 유도장치를 갖추고 유도궤도를 따라 밧데리를 이용하여 운행하도록 되어 있다.  자동유도운반차는 필요한 물품을 자동으로 하적하고 선적할 수 있도록 소형 롤러 컨베이어(roller conveyor), lift/lower 테이블, 포크(folk) 등의 장비를 갖추고 있으며, 차량의 운행과 작업은 메인 컴퓨터에 의한 원격조정 또는 운반차 내부에 설치된 마이크로 컴퓨터에 저장된 프로그램에 의해 수행되는 무인 운반차(driverless vehicle)이다.  AGVS는 컴퓨터에 의해 운영통제되는 제조공정과 창고조직과의 연결을 위한 필수적인 매개체로서 그 연구의 중요성이 부각되고 있다. [ Tompkins, 1980]

자동유도운반차는 일반적으로 바닥에 유도선 매설, 반사테이프 부착 등의 방법으로 고정된 경로를 따라 움직이는 궤도 방식과 자동 스티어링(automatic steering)에 의해 경로를 유도 또는 자율 주행하는  무궤도 방식으로 나뉜다.  무궤도 방식은 현재 기술개발 단계이며 실용화에는 아직 미흡한 기술 수준이다.  


궤도 방식에서 경로선정에는 크게 단방향 이동모형(unidirectional flow model)과 양방향 이동 모형(bidirectional flow model)으로 구분할 수 있다. 그밖에 다중 레인 모형(multiple lane model), 혼합 모형(mixed model) 등이  있다. 국내에서는 일반적으로 한 공장에서 7대 내지 8대의 AGV가 운용되며 AGV가 20대 이상 사용되는 경우에는 단방향 궤도를 사용한다.  단방향 이동 모형은 차량이 경로의 한쪽 방향으로만 이동하는 것으로, 도달하지 못하는 점이 없어야 한다.  설계나 운행이 양방향 이동 모형보다 간편하고 가격이 싸다는 장점이 있으나, 이동시간이 길다는 단점이 있다.  Egbelu and Tanchoco(1986)는 단방향 궤도를 사용하는 시스템보다 양방향 궤도를 사용하는 시스템이 운반차의 수, 생산성(productivity), 총작업소요시간(makespan) 등에서 훨씬 좋은 결과를 보임을 시뮬레이션을 통하여 보여 주었다.  그러나, 양방향 궤도를 사용하는 시스템은 운영 통제의 문제가 단방향 궤도를 사용하는 시스템보다 훨씬 복잡해서 자동유도운반차의 수가 너무 많거나 시스템이 커지면 적용하기 어려워서 아직 생산 현장에서는 많이 사용되지 않고 있다.  따라서, 양방향 이동을 허용하는 자동유도운반차 시스템의 운용통제 문제에 관심이 집중되어 왔다.   

자동유도운반차 시스템의 운용통제에 있어서 중요한 문제는 배차문제, 스케쥴링 문제이다.  작업 도중에 생산 시스템은 한 워크스테이션에서 다른 워크스테이션으로 부품 등의 운반을 요구할 수 있다. 이 작업을 자동유도운반차가 수행하도록 자동유도운반차 시스템 제어기(system controller)는 다음과 같은 2가지 문제를 해결해야 한다.[Wang, 1991]

1) 배차(dispatching): 워크스테이션으로 부터의 이동요구를 수행할 자동유도운반차를 선택한다. 
2) 스케쥴링(scheduling): 자동유도운반차가 요구노드(request node)로 이동할 경로와 시간을 결정해 준다.

자동유도운반차가 이동할 경로는 다른 자동유도운반차와의 충돌(collision), 막힘(deadlock) 없이 운행할 수 있도록 스케쥴링을 해 주어야 한다. 또한 요구노드로 가장 빨리 도착할 수 있게 하거나 주행시간, 대기시간의 최소화 등의 목표를 충족시켜야 한다.

이와 같이 자동유도운반차 시스템에서 통제문제의 핵심은 최적 경로의 생성과 충돌, 막힘 현상의 제거이다. 따라서, 본 논문에서는 자동유도운반차가 충돌, 막힘 현상 없이 최단시간에  요구노드에 도달할 수 있도록 하는 통제기법을 개발하였다.

Ⅱ. 연구 현황 


AGV의 경로계획(path planning)에 관한 전략은 여러 가지가 있다.  이런 경로계획은 크게 근시적 전략(myopic strategy)과 원시적 전략(hyperopic strategy)으로 나눌 수 있다. 
근시적 전략은 순차적 차량 경로계획(Sequential Vehicle Routeing)이라고도 하며, 한번에 단지 하나의 운반차만을 스케쥴링하는 것을 말한다. 양방향 이동이 허용되는 경우에 여러 차량의 경로계획을 동시에 하는 것은 충돌과 막힘 현상을 유발할 수 있으므로 양방향 이동 네트워크에서는 근시적 전략을 주로 사용한다.  
원시적 전략에서는 새로운 운반차의 스케쥴링을 할 때마다 기존의 스케쥴을 모두 버리고 주어진 스케쥴링 기간 동안의 모든 운반차들에 대한 주행 스케쥴을 다시 최적화하는 것을 말한다. 

Maxwell(1981), Maxwell & Muckstadt(1982), Kusiak & Cyrus(1985), Chen et al.(1987)은 운반요구를 미리 알고 있다고 가정하고 자동유도운반차의 배차와 경로계획 문제를 동시에 해결했다.  그러나, 이 방법은 운반 요구가 변하지 않는다는 비현실적인 가정과 계산상의 복잡함 때문에 실시간 통제 시스템으로 구현하기 어려운 단점이 있다. 

Kim & Tanchoco(1991)는 자동유도운반차의 속도는 일정하다고 가정하고, 타임윈도우(time window)를 이용한  자동유도운반차 경로계획과 스케쥴링 기법을 제시했다. 이 방법은 이미 결정된 타임윈도우는 여유시간이 있음에도 불구하고 이동시킬 수 없기 때문에 비효율적인 면이 존재한다.  

Taghaboni(1989)는 이웃 노드들과 가용한 전체 네트워크 정보의 상태를 고려하여 각각의 운반차가 목적지로 한 노드씩만 주행하도록 하는 node-to-node routeing 기법을 제시하였다.  이방법은 실제 교통 상황과 전체적인 스케쥴링 예측능력의 부족 때문에 source-to-goal routeing 기법 보다 수행도가 나쁘다.

Broadbent(1985), Sen(1990), Wang(1991)은 AGV의 스케쥴링 기법을 보다 발전시켜 각 노드의 점유시간을 시간표(timetable)로 저장하여 두고서 매번의 스케쥴링 이후 이를 갱신(update)하는 방법을 사용하였다.  이를 통하여, 최단거리 경로에 다른 자동유도운반차가 존재하는 경우는 차순의 최단거리 경로를 탐색하도록 했다. 이때, 매회의 경로 탐색을 온라인(on-line)으로 수행하지 않고 오프라인(off-line)으로 미리 찾아 저장하여 두고 차순의 최단거리 경로를 온라인으로 탐색한다.  이 방법들은 최단 경로상에 자동유도운반차가 존재하면 차순의 최단경로를 탐색하므로 원래의 최단경로로 가는 경로가 간섭현상(blocking)은 일어나지만 차순의 최단경로로 가는 것보다 빨리 갈 수 있음에도 불구하고 차순의 최단경로로 가도록 스케쥴링하는 경우가 생길 수 있다.

김창욱(1992) 등은 양방향 유도궤도를 가진 자동유도운반차 시스템에서 막힘방지분선(DPS: Deadlock Protection Segment)을 이용하여 막힘(deadlock), 충돌(collision) 현상 없이 자동유도운반차의 운행을 가능하게 했다.  주행시의 충돌을 막기 위하여 궤도를 여러 개의 분선으로 나누어 하나의 분선에 둘 이상의 자동유도운반차가 동시에 진입할 수 없도록 했다.  그러나, 이 논문에서는 오프라인(off-line)으로 스케쥴링을 할 때 고장나거나 작업을 하기 위해 정지해 있는 자동유도운반차 만을 고려하기 때문에 실제로 주행을 할 때에는 스케쥴링을 할 때 와는 많은 상황이 바뀌게 되므로 교통의 혼잡, 대체경로로의 빈번한 이동을 야기할 수가 있다.
이러한 스케쥴링 기법을 정리하면 [표 2.1]과 같다.

[표 2.1] 자동유도운반차의 스케쥴링에 관한 기존의 연구 
 
Ⅲ. 연구 목표 


Ⅲ-1. 연구 대상 시스템의 특성 및 가정 


자동유도운반차 시스템의 주행궤도를 네트워크로 표현하는 것은 일반적으로 행해지는 방법이며 이것은 [그림 3.1]과 같이 나타낼 수 있다.


 [그림 3.1] 주행궤도의 통제점, 레인, 노드의 예 


주행궤도는 다수의 노드(node)와 레인(lane)으로 구성된다. 레인은 궤도를 구성하는 기본적인 요소로 노드와 노드를 연결한 선분이다.  자동유도운반차는 레인을 따라서 주행하며, 정상적인 주행 상태에서는 레인 상에 정지하지 않는다. 노드는 레인과 레인이 만나는 점으로 자동유도운반차가 정지하거나 출발할 수 있는 위치로 워크 스테이션, 적재/이재 위치(pick-up/drop-off point), 교차점 등을 표시한다.  따라서, 자동유도운반차의 주행경로는 레인들과 경유노드 들의 연결선으로 이루어 지며, 출발노드와 경유노드 그리고 목적노드의 순서로 표현된다.

본 논문에서 고려하고자 하는 시스템의 특성은 다음과 같다.

(1) 자동유도운반차가 움직이는 유도경로는 양방향이다. 이 유도경로는 공간을 적게 차지하고 유연성이 있는 양방향 모형으로 레인을 한 번에 하나의 자동유도 운반차가 지날 수 있다. 즉 ,노드를 연결하는 유도경로는 단일 궤도이다. 또한, 자동유도운반차의 유도경로는 격자형이다.

(2) 자동유도운반차의 경로계획은 관리제어기에 의해 통제되는 중앙통제(central control) 방법과 각각의 자동유도운반차에 탑재된 운반차 제어기에 의해 통제되는 분산통제(distributed control) 방법이 있다.  본 논문에서는 중앙통제 방법을 사용한다.

(3) 자동유도운반차가 노드를 통과하는데 걸리는 시간은 일정하다.

(4) 자동유도운반차는 단 하나의 로트(lot)만을 운반할 수 있다.

(5) 각 노드에는 고유 식별번호가 부여된다.

(6) 관리제어기(supervisory controller)는 자동유도운반차의 궤도상의 정확한 위치를 알 수 없으나 통제점을 지날 때마다 자동유도운반차의 위치가 확인되므로 어느 노드나 레인에 위치하는지 알 수 있다. 통제점은 [그림 3.1]에 나타나 있다.

(7) 경로의 교차점, 적재장소(loading point), 이재장소(unloading point) 등이 네트워크에서 노드로 표현되며 각각의 노드는 다음과 같은 안전구역이 존재한다. 안전구역이란 충돌을 방지하기 위하여 노드 주변에 정의된 사각형 모양의 구역이다. [Egbelu & Tanchoco, 1984]

 안전구역(safety zone) = 자동유도운반차의 길이 + 안전거리   2


Ⅲ-2. 연구 목표 

   
본 논문에서는 양방향 이동경로가 허용되는 자동유도운반차 시스템에서 간섭현상(blocking), 충돌(collision), 교통혼잡(congestion) 등을 고려하여 자동유도운반차 간에 충돌 없이 요구노드(refquest node)로 최단시간에 자동유도운반차를 배차할 수 있는 타임 윈도우를 이용한 스케쥴링 알고리듬을 개발하고자 한다.  스케쥴링 전략은 한번에 하나의 자동유도운반차만을 고려하고 이미 결정된 경로계획은 수정하지 않는 순차적 운반차 경로계획(sequential vehicle routeing)을 사용할 것이다. 즉, 이미 계획된 목적노드까지의 도착시간은 지연되지 않도록 스케쥴링 한다. 그러나, 이미 결정된 경유노드 및 레인의 점유시간은 변경될 수 있다.

Ⅲ-3. 자동유도운반차의 통제구조

자동유도운반차의 관리제어기는 워크스테이션에서 자동유도운반차를 요구하는 경우에 필요한 자동유도운반차를 선택하고 이동할 경로와 각 노드를 통과할 시간을 결정해야 한다. [그림 3.2]에 자동유도운반차의 통제방법이 나타나 있다. 본 논문에서는 경로계획 및 스케쥴링에 관한 연구를 하였다.

[그림 3.2] 자동유도 운반차의 통제 방법 
Ⅳ. 문제의 모형화 


Ⅳ-1. 주행궤도의 네트워크 표현 


자동유도운반차 시스템의 주행궤도는 네트워크(network)로써 표현할 때, 각 노드(node)와 레인(lane)은 네트워크를 이루는 요소가 된다.  n개의 노드의 집합은 N = (1, 2, 3, ... , n) 으로 표현된다.  노드 i로부터 노드 j로 향한 레인 l(i,j)가 존재할 때 l(i,j)는 레인 공간 L의 원소가 되며, 노드 i는 노드 j로 인접한다(adjacent to)고 하고, 노드 j는 노드 i로부터 인접한다(adjacent from)고 한다.  노드 i와 노드 j 사이의 궤도가 양방향이면, 레인 l(i,j)와 l(j,i)로 두개의 레인이 양 노드 사이에 존재하게 된다.  한편, 이 레인의 물리적인 길이를 경로길이 d(i,j)로 정의한다.  그러면, 주어진 네트워크는 노드공간 N과 레인공간 L로써 이루어지는 그래프 G로 표현된다.

 G = { (1, 2, ... , n-1, n); l(i, j)}
     단, l(i,j)   L


노드 p로부터 도달가능(accesible)한 노드 q까지의 경로 P: (p,q)는 l(p, p1), l(p1,p2), ... , l(pm, q)의 순서열(ordered sequence)로 이루어 진다.

Ⅳ-2. 타임 윈도우(time window) 


노드(node)에서의 교통상황을 고려하기 위하여 각 노드의 예정된 점유시간표를 유지하고, 한번에 하나의 자동유도 운반차만이  그 노드를 점유할 수 있도록 스케쥴링 한다.  본 논문에서는 타임 윈도우의 여유시간을 고려하여 자동유도운반차의 경로계획 및 스케쥴링을 수행한다. 타임윈도우의  x축은 시간이고  y축은 노드이며 이 좌표축 상에 운반차의 주행경로와 노드의 점유시간이 표시된다.

주행궤도가 [그림 4.1]과 같고 자동유도운반차 v1, v2 의 주행 스케쥴이 다음과 같다고 하자.
v1: [(0,4),(1,2)]   [(14,18),(2,4)]   [(33,37),(4,-)]
v2: [(0,4),(3,1)]   [(19,23),(1,-)]

 

 [그림 4.1] 주행궤도의 예 

즉, v1은 노드1에 0초에 도착하여 4초에 노드1을 이탈하고 노드2로 향한다. 노드1에서 노드2로의 순주행시간은 10초이므로 14초에 노드2에 도착한다. 노드2에는 14초에 도착하여 18초에 노드2를 이탈한다. 노드4에는 33초에 도착하여 37초에 다른 노드(노드 2,3 외의 노드)로 출발한다. 
v1,v2의 스케쥴을 타임윈도우로 표시하면 [그림 4.2]와 같다.

[그림 4.2] 주행 스케쥴의 타임윈도우로의 표현 

본 논문에서는 타임 윈도우의 여유시간을 이용하여 경로계획 및 스케쥴링을 수행하였다.  그러나,  타임윈도우의 여유시간을 이용하게 되면 이미 결정된 경로계획은 고수하지만,  노드의 점유시간을 여유시간 내에서 조정함에 의하여 다른 자동유도운반차의 운행을 가능하게 할 수 있어 보다 효율적이고 유동적인 스케쥴링이 가능하다.



[그림 4.3] 타임윈도우에서 여유시간의 예 


예를 들어 설명하면 다음과 같다. [그림 4.3]에서 기존의 스케쥴이 다음과 같다고 하자.  v1이 정상적으로 주행하면 노드j에 시간 t3에 도착할 수 있지만 v2가 노드j를 점유하고 있기 때문에 v2가 노드 j를 나가는 순간인 시간 t4에 노드j로 진입하도록 스케쥴 되어 있다.  따라서,  기존의 스케쥴에서 a의 여유시간은 (t4 - t3)이다. 이때 v3를 스케쥴링 한다고 가정하자.

시간 α에 v3가 노드i에 도착할 수 있다면, 여유시간을 이용하지 않는 경우에는 노드i로 t2에 진입하도록 스케쥴링 하게 된다.  그러나, 타임윈도우의 여유시간을  이용하면 v1의 노드i에서의 여유시간은 (t4-t3)이므로, 이 여유시간 내에 v3가 노드i를 지나갈 수 있으면 타임윈도우 a에서 t1을 v3가 노드 i를 점유하는 시간만큼 증가시키면 v3는 노드 i에 시간 α에 진입할 수 있게 된다. 이 방법은 기존의 경로계획에는 전혀 영향을 주지 않으며 단지 v1이 노드 i에 진입하는 시간만을 늦어지게 할 뿐이다.
예약 타임윈도우(reserved time window)의 집합은 R로 다음과 같이 정의된다. 
 

예약 타임윈도우란 자동유도운반차가 노드를 점유하고 있는 시간(노드를 통과하는데 걸리는 시간)을 말한다.   

자유 타임윈도우(free time window)의 집합은 F로 다음과 같이 정의된다.

 
자유 타임윈도우란 자동유도운반차가 노드를 점유하고 있지 않아서 노드로의 진입이 가능한 상태를 나타내는 타임윈도우 이다.  [그림 4.1]을 예로 들어 설명하면 다음과 같다. a가 노드 i의 k번째 예약 타임윈도우라고 하면 ,
 

이므로 가 된다. v1이 노드 i를 이탈하는 시간 t2부터 노드 i의 (k+1)번째 자유 타임윈도우라고 하면,

 
가 되므로  가 된다. 


Ⅳ-3. 여유시간을 이용한 진입가능시간의 계산 


<용어>
 : 자동유도 운반차가 노드i를 통과하는데 걸리는 시간
 : 노드i에서 노드j까지의 레인을 주행하는데 걸리는 순주행 시간
 : 노드i에서 노드j까지의 길이
 s : 자동유도운반차의 속도
  : 노드i의 에 진입할 수 있는 가장 빠른 시간
 : 에서 노드j에 도착할 가장 빠른 시간
 :  에서 로 진입할 수 있는 가장 빠른 시간

레인의 순주행 시간은 t(i,j) 로 정의되며 [그림 4.2]에서 볼 수 있듯이 다음과 같은 식에 의하여 계산될 수 있다.

 t(i,j) = ( d(i,j) - li - lv )/s   










[그림 4.4] 레인의 순주행 시간 


에서 노드j에 도착할 가장 빠른 시간 는 다음 식에 의하여 계산된다.


혼란이 없으면 는 α로 표시하였다. α값은 예약 타임윈도우나 자유 타임윈도우 내에 포함될 수 있으며 각각 다른 방법에 의해 τ를 계산한다. 

에서 노드j로의 진입가능 시간을 계산하려 할 때 다음과 같은 2가지 경우를 고려해야 한다.


Ⅳ-3-1. α가 자유 타임윈도우에 포함되는 경우 



 [그림 4.5 ] α가 자유 타임윈도우에 포함되는 경우 

에서 노드j로 정상적으로 주행하면 [그림 4.5]와 같이  사이에 노드j에 도착할 수 있다고 하자. 노드j의 통과 시간이 tj 이므로, 노드 j에 α에 도착하여 의 시작시간  전에  를 통과할 수 있는가가 문제가 된다. 즉 다음과 같이 2가지 경우로 나뉘게 된다.
 
1)인 경우 
이때는 자동유도운반차가 노드 j에 α에 도착하여 의 시작시간  전에  를 통과할 수 있기 때문에 타임윈도우를 이동시킬 필요가 없다. 따라서, 로의 가장 빠른 진입 가능시간 τ=α가 된다.

2)인 경우
이 경우에는  의 타임윈도우를 m= 만큼 이동시켜야만 로의 진입이 가능하다. 를 예약한 자동유도운반차를 v라 하자. 이 때 v의 이후의 주행스케쥴에서 예약 타임윈도우를 R1, R2, ... ,Rm 이라 하고, 여유시간을 S1, S2, ... , Sk, ... , Sm (단,)이라 하자. 이때 
       ① 
를 만족하는 최초의 k를 찾는다. 이런 k가 존재하지 않으면 로의 진입은 불가능하다. 이 값을 만족하는 k가 존재하면 의 이동을 제한하는 의 크기를 검사해야 한다. 즉,
      ②
인가를 검사한다. ②식을 만족하면 를 m만큼 이동시킬 수 있다. 를 m만큼 이동하면 v의 노드j 다음 경로인 노드k의 예약 타임윈도우 은 (m-S1)만큼 이동할 수 있으면 되므로
      ③
을 만족하면 된다. ③식을 만족하면 계속해서 위와 같은 과정을 Sk까지 반복한다. 만약 Sk까지 모두 만족시키면 에서로 시간 α에 진입하는 것이 가능하고 이것을 가능하게 하기 위해 이동시켜야 할 타임윈도우는 k개이며 의 이동시간은 

이다. 그러나 ②식을 만족하지 않으면 의 이동 가능성을 검사해야 한다. 이 과정은 의 이동 가능성을 검사하는 방법과 동일하다. 단, 을 만큼 이동시킬 수 있는가를 검사하면 된다. 만약, 이면  이므로 도 m만큼 이동시켜야 한다. 
위의 조건을 모두 만족하면 에서 로의 가장 빠른 진입가능 시간 가 된다. 그러나 위의 조건을 만족하지 않으면 노드 로의 진입은 불가능하다. 로의 진입이 불가능하면 이후의 자유 타임윈도우로의 진입 가능성을 검사한다. 위의 조건을 만족하는 자유 타임윈도우가 존재하면 그 타임윈도우의 시작시간이 에서 노드 j로의 가장 빠른 진입가능 시간이 된다.



Ⅳ-3-2. α가 예약 타임윈도우에 포함되는 경우 



[그림 4. 6] α가 예약 타임윈도우에 포함되는 경우 

에서 노드j로 정상적으로 주행하면 [그림 4.6]과 같인  사이에 노드j에 도착할 수 있다고 하자. 즉, α의 값이 에 속하는 경우이다. 만약, 타임윈도우의 여유시간을 고려하지 않는다면 로는 진입할 수 없고 시간 에 로 진입할 수 있는가를 검사해야 한다. 그러나, 여유시간을 이용하는 경우에는 를 만큼 증가시킬 수 있으면 시간 α에 로 진입할 수 있다. 이때 이동시킬 타임윈도우의 이동 크기는 tj 보다는 크고 2tj보다는 작다. 를 이동시킬 수 없으면 로의 진입은 불가능하고 로 에 진입할 수 있는가를 검사해야 한다. 이런 방법으로 노드j로 진입할 수 있는 자유 타임윈도우와 가장 빠른 진입가능 시간 τ를 구한다.
노드가 n개이고 자동유도운반차가 m개인 경우 이동을 고려해야 할 타임윈도우는 최악의 경우에는 (m-1)n개 이다. 또한, 노드j로 진입 가능한 자유 타임윈도우를 찾으려면 최대 m개의 자유 타임윈도우를 탐색해야 한다. 그러므로, 계산의 복잡성을 줄이기 위하여 이동시킬 수 있는 타임윈도우의 수를 제한하고 여유시간이 어떤 작은 값 ε보다 작은 경우의 여유시간은 없는 것으로 간주한다.


Ⅴ. 자동유도운반차의 스케쥴링 


본 논문에서의 스케쥴은 다른 자동유도운반차들의 이미 계획된 목적 노드까지의 도착시간은 지연시키지 않으면서 예약 타임윈도우의 여유시간을 이용하여 한번에 하나의 운반차만을  스케쥴링하는 순차적 차량 스케쥴링 기법이다. 스케쥴링 알고리듬은 노드에서 노드로 주행하는데 걸리는 시간을 비용으로 하여 두 점 사이의 최단 경로를 구하는 알고리듬인 Dijkstra 방법을 이용하였다. 이때 각 노드의 자유 타임윈도우가 Dijkstra 방법에 사용될 네트워크의 노드가 되고 한 자유 타임윈도우에서 다른 자유 타임윈도우로 이동하는데 걸리는 시간이 비용이 된다. 




   
[그림 5.1] 스케쥴링 알고리듬 



Ⅴ-1. 타임윈도우에서 충돌 및 막힘 현상의 발견 및 방지 

AGV간의 충돌은 Broadbent et al.(1985)에 의하면 2가지로 분류된다.

1) 교차충돌(head-on conflict): 2개 이상의 AGV가 서로 다른 레인에서 교차점으로 동시에 진입하는 경우와 한 레인에서 진행방향이 반대인 두 자동유도운반차가 서로 만나는 경우에 발생한다.

2) 추월충돌(catching-up conflict): 2개의 AGV가 같은 방향으로 서로 다른 속도로 주행하고 있을 때 뒤따르는 AGV의 속도가 더 빠른 경우에 발생한다.

첫번째 경우는 교차점에서 충돌이 발생하는 가를 미리 검사하고 충돌이 발생하는 경우에는 대체 경로로 가면 된다. 두번째 경우는 뒤 따르는 AGV의 속도를 늦추거나 다른 경로로 주행하도록 하면 된다. 


Ⅴ-1-1. 추월 충돌의 방지 

[그림 5.2]에서 A는 이미 예약된 타임윈도우라고 하자. 새로 스케쥴링할 운반차가 B라고 하면 이 경우에 추월 충돌이 발생하게 된다. 즉, A가 노드i에 늦게 진입했음에도 불구하고 노드j에 B보다 먼저 진입하는 경우이다. 이런 상황을 미리 발견하고 충돌이 발생하지 않도록 스케쥴링 해야 한다. 에서 로 진입하려 할 때 충돌의 발생여부를 알려고 한다면 다음과 같은 과정을 거쳐야 한다.
이후에  노드i를 예약한 자동유도운반차의 집합을 A, 이전에 노드j를 예약한 자동유도운반차의 집합을 B라 할 때  이면 추월 충돌이 발생한다. 이 경우에는 에서 로 진입할 수 없다.

[그림 5.2] 추월충돌의 발견 


Ⅴ-1-2. 교차 충돌의 방지 

[그림 5.3]에서 A는 이미 예약된 타임윈도우라고 하자. 새로 스케쥴링할 자동유도운반차가 B라고 하면 교차충돌이 발생하게 된다. 즉, A, B는 노드i, j 사이에서 서로 교차하게 된다. 이런 상황을 방지하기 위하여 [그림 5.3]에서 알 수 있는 바와 같이 추월 충돌을 발견할 때와 같은 방법으로 계산하여 에서 로의 진입 가능성을 검사하면 된다. 즉, 추월 충돌과 교차 충돌의 발견 방법은 동일하다.

[그림 5.3] 교차충돌 발견 



Ⅴ-1-3. 막힘 현상(deadlock)의 방지 
막힘 현상은 [그림 5.4]에 나타나 있다.

[그림 5.4 ] 막힘 현상(deadlock) 

타임윈도우를 이용할 경우에 막힘 현상이 발생하는 경우에는 결국 교차충돌이 일어나게 된다. 따라서 교차충돌이 일어나지 않도록 하면 막힘 현상도 방지할 수 있다. 


Ⅴ-2. 진입 가능시간 계산 알고리듬 

에서 노드 j (j i)로 시간의 제약하에서 충돌없이 가장 빨리 진입할 수 있는 자유 타임윈도우와 진입 가능한 시간을 구하는 알고리듬이다.  노드 j가 i로부터 연결된 노드인가를 검사하고(공간상의 도달 가능성), 다음으로 진입 가능한 타임윈도우와 그때의 진입 시간을 구하고(진입 가능시간 계산), 마지막으로 에서 로의 이동이 충돌을 발생시키지 않는가(충돌 가능성)를 검사한다.  위의 모든 과정을 거친 자유 타임윈도우로만 진입 가능하다. 만약 노드j로 진입할 수 있는 자유 타임윈도우가 없으면 에서 노드j로 진입할 수 없다.
에서 노드j로의 진입가능 자유 타임윈도우 및 진입가능 시간은 다음의 알고리듬에 의해 계산된다.



진입가능시간 계산 알고리듬

단계1) 공간상의 도달가능성
 l(i,j)   L 이면 진입 불가능(  =  )
 아니면 단계2)로

단계2) 진입 가능시간 계산
  = 1 이면  시간표를 이용하여 α를 계산
   
 여유시간을 이용하여 가장 빨 진입할 수 있는 자유 타임윈도우 및  가장 빠른 진입가능 시간 τ를 계산
 2-1) α가 자유 타임윈도우에 포함되는 경우
 2-2) α가 예약 타임윈도우에 포함되는 경우
 이 과정에서 구한 자유 타임윈도우를 라고 하자.
단계3) 충돌 가능성 검사
   A: 노드 i의  직후에 노드 i를 예약한 운반차의 집합
 B: 노드 j의  직전에 노드 j를 예약한 운반차의 집합
    이면에서 로 진입 불가능 

단계4) 종료
 타임윈도우의 이동이 있으면  =1, 
   그 때의 시간표는 Temp에 저장 
 위의 조건들을 만족하면 진입 가능
 

Ⅴ-3. 스케쥴링 알고리듬 


<용어>
 : 출발 타임윈도우
tnow : 현재 시간
 : 자동유도 운반차가 노드i를 통과하는데 걸리는 시간
 : 노드i에서 노드j까지의 레인을 주행하는데 걸리는 순주행 시간
 : 노드i에서 노드j까지의 길이
  : 노드i의 에 진입할 수 있는 가장 빠른 시간
 : 에서 노드j에 도착할 가장 빠른 시간
 :  에서 로 진입할 수 있는 가장 빠른 시간
 : 로 가장 빨리 진입할 수 있는 타임윈도우
O : 로부터 구해진 최단 타임윈도우의 집합
C : O로부터 직접 도달 가능한 F-O에 속하는 자유 타임윈도우의 집합
 : 로 진입하기 위해 이동시킨 다른 타임윈도우의 이동 시간표
N: 노드의 집합


이 알고리듬의 개요는 다음과 같다.

1단계) 초기화
 출발노드와 목적노드를 지정하고 초기화 한다.
 출발 타임윈도우로의 가장 빠른 진입시간을 현재시간으로 놓음
 
2단계) 진입 가능시간 계산
 현재의 최단 타임윈도우에서 가장 빨리 진입할 수 있는 자유 타임윈 도우를 찾는다. 이런 타임윈도우가 존재하지 않으면 스케쥴링이 불 가능하다.

3단계) 최단 타임윈도우 선정
 2단계에서 구한 자유 타임윈도우 중에서 가장 빨리 진입할 수 있는    타임윈도우들을 찾는다. 

4단계) 종료검사
 3단계에서 구한 타임윈도우가 목적노드의 자유 타임윈도우이면  5단계로 가고 그렇지 않으면 2단계로 되돌아 간다.

5단계) 경로발생 및 스케쥴링 
 목적 노드의 자유 타임윈도우로부터 역추적하여 경로를 찾아내고 각  노드로의 진입시간과 이탈시간을 계산하여 스케쥴을 발생시킨다.  또한, 변경된 타임 윈도우들의 값을 수정한다.
스케쥴링 알고리듬

단계1) 초기화
  
단계2) 진입가능 시간 계산
 각각의 j에 대하여 다음을 수행
  2-1) O에 속하는 모든  (i j)에 대하여  진입가능 시간 계산 알고리듬에  의해 진입가능한 자유 타임윈도우()와 
 진입가능 시간 를 계산.
  2-2) 모든 를 만족하는   를 찾는다.
  2-3)
  
  2-4)  이면 C에
단계3) 최단 타임윈도우 선정
 C =   이면 불가능
 
 최소값이 둘 이상일 경우에는 출발 타임윈도우로부터 최소노드를 거치 는 타임윈도우를 택함에 의해 해결
 O에 를 삽입하고 C에서 를 삭제
 에 temp를 저장

단계4) 종료검사
 목적노드의 자유타임윈도우가 O에 있으면 5단계로
 아니면 2단계로

단계5) 경로발생 및 스케쥴링
 배열 P로부터 경로발생
 최적경로상의 모든 에 대하여 
 진입시간:  , 이탈시간:  + ti
 로 하여  스케쥴을 발생
. 타임 윈도우의 값을 수정하고 종료.



Ⅴ-4. 알고리듬의 복잡도 


스케쥴링 알고리듬에서 2단계가 가장 많은 시간을 필요로 한다. 2단계는 노드의 수만큼 반복해야 한다. 반복할 때마다 O의 원소는 1개씩 증가한다. 따라서, 이 알고리듬은 최악의 경우 (|F| - 1)만큼 반복을 해야한다. (|F|는 F의 원소의 갯수이다.). 노드의 수를 n, 자동유도운반차의 수를 m이라 하자. 그러면, |F|는 많아야 mn개이고 이동시킬 타임윈도우의 수는 많으면 (m-1)n이다. 또한, 어떤 노드로 가장 빠른 시간에 진입 가능한 자유타임윈도우를 찾으려면, 최악의 경우에는  m번을 탐색해야 한다.  따라서, 전체 알고리듬의 복잡도는 이다.  

이동시킬 타임윈도우의 수를 k개로 제한하면 알고리듬의 복잡도는 충돌 발견 단계의 영향을 받는다. 타임윈도우의 충돌을 발견하려면 의 계산이 필요하다. 따라서, 이 경우에 알고리듬의 복잡도는 이다.   

Ⅵ. 예제 


[그림 6.1]과 같은 주행궤도를 가지는 시스템을 생각하자. 사각형 안에 있는 숫자는 노드번호이며 노드와 노드를 연결한 선은 주행궤도이며, 주행궤도에 쓰여있는 숫자는 레인을 주행하는 순주행 시간이라 하자. 이때 3개의 예제를 푼 결과를 Kim & Tanchoco가 제시한 방법과 비교해 보았다. 3개의 예제 모두가 여유시간을 이용할 수 있는 예제이다. 사각형 안에 있는 숫자는 노드번호이며 노드와 노드를 연결한 선은 주행 궤도이며, 주행궤도에 쓰여있는 숫자는 레인을 주행하는 순주행시간이라 하자. 계산상의 편의를 위해 노드를 직선으로 통과하느냐 회전하느냐에 관계없이 노드 통과 시간은 4초이고 출발명령을 받고 출발노드에서 출발해서 그 노드를 이탈하는데 걸리는 시간은 3초라고 하자. 

[그림 6.1] 자동유도 운반차의 주행궤도의 네트워크  
단, 레인위에 표시된 숫자는 이동시간이고 사각형 안의 숫자는 노드번호
[예제1]: v5를 노드4   노드2 까지 스케쥴

[표 6.1] 자동유도 운반차의 스케쥴 예제1  

 단, [(진입시간,이탈시간,여유시간),(현재 노드 #, 다음 노드 #)]

[표 6.2] 결과1 


본 논문의 방법은 v3의 노드1, 노드4에서의 여유시간을 이용하였다. 즉, 노드1로의 진입시간은 1초 지연되고 노드3으로의 진입시간은 3초 지연되었다. 그러나 노드5로의 진입시간은 기존의 스케쥴링과 같이 43초로 변하지 않았다.    
[예제2]: v4를 노드1   노드6 까지 스케쥴

[표 6.3] 자동유도 운반차의 스케쥴 예제2  

 단, [(진입시간,이탈시간,여유시간),(현재 노드 #, 다음 노드 #)]

[표 6.4] 결과2 

본 논문의 방법을 사용하면 v2의 노드4로의 진입시간이 1초 지연되어 17초에 진입할 수 있도록 수정한다. 그러나,  노드5 이후로의 진입시간에는 지연이 생기지 않는다. 즉, 목적지에 도착하는 시간은 변함이 없다.
[예제3]: v5를 노드3   노드7 까지 스케쥴

[표 6.5] 자동유도 운반차의 스케쥴 예제3  

 단, [(진입시간,이탈시간,여유시간),(현재 노드 #, 다음 노드 #)]

[표 6.6] 결과3 

본 논문의 방법을 이용하면 v3의 스케쥴에서 여유시간이 5초인 노드4에서의 진입시간이 1초 지연되지만 노드2까지 도착하는 시간은 원래의 스케쥴과 같다.

위의 3개의 예제를 보면 예약 타임윈도우의 여유시간을  이용한 경우에 주행시간이 현저히 단축됨을 알 수 있다. 예제 3에서 볼 수 있듯이  통과하고자 하는 노드에서 적재/이재 작업이 이루어지고 있는 경우에 여유시간을 고려하지 않으면 많은 시간이 낭비됨을 알 수 있었다.  
Ⅶ. 결론 및 추후 연구과제 


 양방향 궤도를 가진 자동유도 운반차 시스템이 단방향 궤도를 가진 자동유도 운반차 시스템 보다 더 효율적이라는 실험결과는 많지만 운영 통제 상의 어려움 때문에 단방향 궤도를 가진 시스템을 주로 사용하고 있다. 따라서, 본 논문에서는 양방향 궤도를 주행하는 자동유도운반차의 스케쥴링 기법에 대해 연구하였다. 이 방법은 이미 결정된 경로계획은 변경시키지 않고 목적지까지의 도착시간도 지연시키지 않는다. 

본 논문에서 제시한 알고리듬은 예약 타임윈도우의 여유시간을 이용한다. 본 논문은 새로 스케쥴링 할 차량을 다른 운반차와 충돌이 없게 하면서 최단 시간에 목적지까지 도착할 수 있도록 스케쥴링하는 알고리듬을 제시하였다. 노드가 n개이고 자동유도운반차의 수가 m개인 경우 이 알고리듬의 복잡도는 이다. 그러나, 이동시킬 타임윈도우의 수를 k개로 제한하면 알고리듬의 복잡도는 이다. 실제로 예제를 풀어본 결과 수행도도 매우 좋음을 알 수 있었다.

추후 연구과제로는 교차점에서 여러 자동유도운반차의 동시 주행을 허용하는 경우의 문제, 배차(dispatching) 방법과의 연관성, 버퍼(사이딩, 스퍼)가 존재하는 경우 등에 관한 연구이다.

</tdmsfiletext>
