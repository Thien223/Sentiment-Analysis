<language> Korean </language>
<textcode> KSC-5601-1988 </textcode>
<process> raw </process>
<version> 2001(or)</version>
<filename> kaistcorpus_written_raw_or_academic_paper96_tek.txt </filename>
<title> 컴퓨터통합생산을 위한 분산-협조형 생산현장제어시스템 설계에 관한 연구(A Study on Design of a Cooperative-distributed Shop  Floor Control System for Computer  Integrated Manufacturing) </title>
<author> 박남규 </author>
<date> 1994 </date>
<publisher> 서울대학교 </publisher>
<kdc> TD530.961 </kdc>
<tdmsfiletext>
1. 서 론

1.1 연구배경 및 목적

소비자의 욕구다양화에 따른 제품의 다양화 및 제품 수명주기의 단축과 메카트로닉스 기술의 급격한 발전, 그리고 컴퓨터 기술의 발전이 하나로 융화되어 컴퓨터통합생산 (CIM : Computer Integrated Manufacturing)이라는 새로운 생산방식이 등장하였다. CIM은 각종 장비와 센서, 소프트웨어, 데이타 베이스, 컴퓨터 통신망, 그리고 다양한 경영관리 기법 등으로 구성된다. 각종 기계와 장비 등은 "정보"라는 매개체를 통하여 컴퓨터 통신망으로 연결되며, 이때 각종 정보를 공유하게 된다. 또 다른 관점, 즉 의사결정이라는 관점에서 볼 때에, CIM이란 제품의 수요예측, 수주에서부터 판매 및 서어비스까지를 포함하는 새로운 개념이다. 이 경우 CIM의 효과적인 추진을 위해서는 시스템 내에서의 정보흐름과 연관관계를 파악하는 것이 필수적이라 할 수 있다.
산업용로보트나 NC공작기계를 중심으로 주로 제조공정의 자동화에 치중하던 초기의 공장자동화 (FA : factory automation)는, "자동화의 섬(island of automation)"이라 불리는 역현상을 초래하여 시스템 전체를 일관된 틀 안에서 관리하는 데 문제점을 드러냈다. 최근의 CIM은 정보화, 네트워크화를 통하여 이 섬들을 연결시켜 줌으로써 이와 같은 逆현상을 극복하고 기업 활동 전체의 통합을 추구하는 방향으로 발전해 나가고 있는 추세다. CIM의 추진에 있어서 생산현장(shop floor)이 갖는 의미는 매우 크다. 모든 의사결정의 최종적인 구현 수단인 제품생산이 이루어지는 곳이며, 동시에 모든 의사결정의 기본자료가 발생되는 곳이기 때문이다. 따라서 생산현장에서의 적절한 제품생산계획 및 기계부하 할당과 각종 자료 및 정보의 효율적인 관리는 CIM 시스템의 효과적인 운용을 위한 기본이라 할 수 있다.
CIM 환경 하의 생산현장은 기존의 job shop과는 다른 몇가지 중요한 특성을 갖는다. 첫째, CIM 시스템은 강력한 실시간 반응요구(real-time requirement)를 갖는다. CIM 시스템에서는 컴퓨터통신망에 의해 기업 내의 모든 요소가 서로 연결되어 있기 때문에, 생산현장에서 최고경영자에 이르기까지의 모든 정보를 관계자들이 공유하고 있다. 따라서 어느 특정 단계(즉, communication node)에서의 상황이 시스템 전체에 즉시 알려져야만이 時宜性있고 정확한 의사결정이 이루어지기 때문에 실시간 반응요구가 크다고 볼 수 있다. 둘째, CIM 시스템은 개념적으로 통합되어 있을 뿐 실제로는 분산(logically integrated, physically distributed)되어 있다. 분산은 통합과는 대립되는 개념이다. CIM에서의 통합(integration)이 가지는 의미는 매우 중요하다. 그러나 실제의 CIM 시스템은 분산된 시스템이며 단지 정보와 컴퓨터 통신망이라는 매개를 이용하여, 분산된 시스템들을 개념적으로, 논리적으로 통합시켜 놓은 것이다. 셋째, CIM 시스템 내에 분산된 시스템들은 異質性(heterogeneity)을 갖는다. CIM의 생산현장을 구성하는 각종 기계와 장비들은 동시에 일괄구매된 같은 회사 제품이 아닐 뿐만 아니라 같은 회사 제품이라 할 지라도 그 성능과 규격이 매우 다양하다. 따라서 통합을 추진하는 경우에 각 기기간의 통신 및 정보교환 문제를 고려해야만 한다. 넷째, CIM 시스템을 구성하는 각 요소(communication node or machine cell)별로 서로 다른 수준의 자동화 및 지능화(local intelligence)가 추진되어 있다. 공장을 새로 짓는 경우를 제외하고는, 현실적으로 CIM의 추진이 한 번에 일괄적으로 이루어지는 경우는 드물다. 이상적으로 볼 때는 하향식(top-down) 접근법에 의한 CIM의 추진이 바람직 하지만, 현실적으로는 이미 존재하던 공장을 자동화시켜 가면서 단계적으로 CIM을 이루어가는 상향식(bottom-up) 접근법을 사용하기 때문에, 필연적으로 CIM의 각 요소는 자동화의 정도가 서로 다르게 되며, 각자 서로 다른 종류의 자동화 기능을 보유하게 된다. 따라서 CIM의 추진시에는, 각 요소의 지능화 및 자동화의 정도에 대한 차이를 고려해야 한다. 위와 같은 사항 외에도 CIM 시스템은 적응제어 능력(adaptive control ability), 고장 자가진단 등의 많은 특징을 가진다(Mitchel 1991). 이와같은 사항들의 결집에 의한 구현체로서 현재 유연생산시스템(FMS;Flexible Manufacturing System)이 현장에서 많이 운용되고 있다. 그러나 FMS 본래의 취지와는 달리 현재의 FMS 운용은 많은 어려움을 안고 있다. FMS는 기존의 생산시스템과 달리 자동화된 각종 장비와 고도의 정보처리 기술 그리고 실시간 제어 기술 및 분산제어 기술이 융합된 복합 시스템이다. 따라서 효율적인 FMS의 운용을 위해서는 복합 시스템에 적합한 의사결정 구조를 갖추어야 함이 당연한 논리적 귀결이다. FMS의 운용을 위한 의사결정과 관련된 연구는 시스템 구성 및 설계, 생산계획, 일정전개, 그리고 시스템 운용 제어 등 4가지로 대별할 수 있다. 시스템 운용 제어를 제외한 나머지 분야에 대한 연구는 그 동안 많이 이루어졌으나, 시스템 운용 제어에 관한 연구는 이제 초기 단계에 불과하다. FMS의 본래 취지를 달성하기 위해서는 정보처리 기술, 실시간 제어 기술, 분산처리 기술 등과 논리적으로 조화를 이루고, 복합 시스템에 적합한 새로운 시스템 운용제어 구조를 갖추어야 한다. 이와 같은 특성을 반영하기 위해 본 연구에서는 분산 인공지능 (dritributed artificial intelligence)기법을 이용하여 CIM 시스템의 생산현장운용을 위한 on-line 분산제어 시스템을 제시하였다. 

CIM의 추진을 생산현장에 맞추어서 파악해 본다면, 유연생산시스템은 바로 생산부분의 CIM 시스템이라고 볼 수 있다. 각종 자동화 기술이 발전함에 따라 FMS의 구성은 점점 복잡해지고 있으며, 성능 또한 크게 향상되고 있다. 특히 컴퓨터 통신 기술이 급격히 발전함에 따라, 소위 LAN이라 불리는 근거리 통신망(local area network)이 설치되어, 공장 내의 곳곳을 하나로 연결시켜줌으로써, FMS의 운용 기술은 새로운 전기를 맞이하였다. 기존의 FMS 관리 및 운용방식은 LAN 환경 하의 공장을 제어하는 데 높은 비효율성과 많은 한계를 노출하고 있다(Ranky 1990b). 장기적이고 전략적인 의사결정을 다루는 상위단계에서는 기존의 FMS 운용방식과 LAN이 설치된 CIM 환경하의 FMS 운용방식이 크게 다르지 않다. 그러나 단기적인 운용이나 주로 실시간 응답과 관련된 의사결정을 다루는 하위단계에서는 그 운용방식에 있어서 큰 차이를 보인다. 따라서 기존의 FMS 운용 방식을, LAN과 정보처리 기술, 시스템제어 기술이 하나로 혼합된 새로운 환경에 그대로 적용시킨다면 필연적으로 많은 문제점이 수반될 수 밖에 없다.  그러나 불행하게도 FMS의 운용방식, 그 중에서도 FMS 시스템 운용제어와 관련된 연구에서는 LAN 환경하의 문제를 다룬 연구가 극히 제한적으로 존재할 뿐이고(Shaw 1987, Parunak 1986, Ow 1988), 대부분의 연구는 기존의 FMS의 운용에 관한 연구들이다 (Lingarkar 1990, Sarin 1990, 장성용 1991, 엄완섭 1992). 
이러한 문제들을 고려하여, 본 논문에서는 LAN과 정보기술, 제어기술이 혼합되어 설치된 환경 하에서, FMS 운용 문제 중 하위단계에 해당하는 작업일정계획 및 생산현장 제어문제에 관하여 연구하였다. FMS가 기존의 생산방식에 비하여 가지는 큰 장점은 제품가공상의 대체 공정, 기계의 다양한 성능, 가동준비시간의 감소, 고장 등의 예기치 못한 상황에 대한 대처 능력, 시스템의 모듈화에 의한 확장의 용이성, 실시간 처리 등이라 할 수 있다.  따라서 FMS의 이와 같은 특성을 반영한 운용방식이 도입된다면, FMS의 '시스템으로서의 성능'이 충분히 발휘될 수 있다.  기존의 연구들은 대부분이 이와 같은 상황중 일부분만을 반영하고 있거나 또는 이런 내용을 반영하지 못하고 있다.  특히 이와 같은 상황을 반영한다 할지라도, 중앙집중식 제어(centralized control) 방식을 취하기 때문에 운용방식의 robustness나 효율성을 보장하기 힘든 상황이었다.  본 연구에서는 FMS의 상황을 현실 그대로 모형화 할 수 있도록, 생산현장의 상황과 개념상 일치성을 보이는 분산형 공장제어방식을 도입하였고, 이와 같은 운용방식이 robustness를 유지할 수 있도록 하기 위하여, 실시간 정보획득과 on-line 감시, 시스템 이상방지 및 동적인 상황대처 등의 능력을 가진 생산현장 제어시스템을 개발하고자 한다.

1.2 연구 범위 및 논문의 구성

본 논문은 FMS를 실제상황에 맞도록 분산시스템으로 모형화하고, 그 모형을 기반으로 FMS의 분산제어 프로토콜(protocol)을 제시하고 또한 가장 효율적인 FMS의 운용방식을 결정하기 위한 몇 가지 이론을 제시하고 이의 타당성을 분석함을 그 연구 목적으로 하고자 한다.  이와 같은 목적을 이루기 위하여 다음과 같은 몇가지 원칙을 따라서 모형을 개발하였다. 

1) FMS의 확장 가능성을 살리기 위해 분산형 구조를 그대로 모형화한다.
2) 각종 자원 (예: 기계, AGV, AS/RS 등)의 다양한 기능을 간략화시키는
   가정없이 그대로 인정한다. 
3) 의사결정을 내리는데 있어서, LAN을 통하여 생산현장의 가장 최근 상태의
   정보를 이용한다. 
4) 예상하지 못한 상황의 발생을 수용하고 시스템의 정지상태를 방지하기
   위하여 능동적 대처를 할 수 있는 방법을 도입한다. 

위에 언급된 사항들은 특별한 것이 아니고, FMS가 가져야 하는 보편적인 기능들이며, 다만 이제까지의 연구들에서 여러 가지 가정을 통하여 무시해 왔던 것들로서, 본 연구에서는 실제 시스템에서 발생하는 상황을 있는 그대로 포함시키고자 하는 의도에서 그 같은 원칙을 세우게 되었다.  본 논문에서는 FMS 생산현장(shop floor)의 일반적인 운용형태를 모형화함으로써, FMS의 생산현장 제어에 대한 모형 이론적 틀(model-theoretic framework)을 제시하고자 한다.  따라서, 특정 FMS를 대상으로 하는 것이 아니라, 일반적인 구성요소를 가진 FMS에 대한 모형이론을 개발함으로써 향후 FMS의 생산현장 제어시스템 개발에 대한 방법론을 제시함을 그 연구 범위로 한다.  

본 논문은 8개의 장으로 구성되었다.  각 장별 내용은 간략히 다음과 같다.

1장  연구의 배경 및 동기, 그리고 FMS의 분산형 일정계획 및 제어시스템
     개발의 필요성 및 연구 범위를 다룬다.
2장  기존의 FMS 일정계획 및 운용 제어에 대한 현황분석 및 문헌조사. 
     유사연구에 대한 분석 및 본 논문에서 제안한 MODERATO 시스템 설명
3장  FMS의 생산현장 제어 문제에 대한 정의 및 분석
4장  본 논문에서 제안한 MODERATO 시스템에 대한 상세 소개. 
     1절과 2절에서는 MODERATO 시스템의 이론적 배경을,
     3절에서 6절까지는 MODERATO 시스템의 구조에 대한 소개와
     각 모듈의 기능을 설명한다. 
     7절에서는 MODERATO 시스템의 특성에 대한 분석을 한다.  
5장  Petri net을 이용한 FMS 모형화 및 이 모형을 이용한
     FMS 정지상태 방지 대책을 다룬다.  
6장  실험 및 성능 비교
7장  결론 및 추후연구과제

부록  Order agent에 사용된 전문가 시스템과, 
      Petri net에 대하여 소개한다. 
2. 연구 현황 및 분석

2.1 일정계획에 근거한 접근방법

FMS의 생산일정계획은 기존의 job shop 생산일정계획 문제와 일견 비슷해 보이나 대체공정의 존재로 인하여 훨씬 복잡한 문제로 알려져 있다(Montazeri 1990).  FMS의 일정계획을 푸는 방법은 수리계획모형 및 발견적기법을 이용하는 방법, dispatching rule을 적용하는 방법, 그리고 최근 십여년 사이에 새롭게 부상한 인공지능 기법을 이용한 방법 등이 있다. 이중 수리계획모형은 주로 off-line 방식에 의하여 일정계획을 작성하는데 주로 쓰이며(schedule generation), dispatching rule 및 인공지능 기법은 on-line 방식의 일정계획 및 생산현장 제어에 주로 사용된다. 어느 방식을 사용하느냐에 무관하게 위의 방식은 거의 대부분이 중앙집중식 일정계획법이다.  
각각의 방법에 속하는 최근의 연구는 다음과 같이 요약할 수 있다.

(1) 수리계획모형 및 발견적 기법을 이용한 연구

▶ Chang and Sullivan(1989) : critical resource, 즉 bottleneck을 발생시키는 resource를 기준으로 하여, beam search를 수행함으로써 makespan을 최소화 시키는 방법을 제시함
▶ Aftentakis(1986) : 정수계획법과 그래프이론을 이용하여 생산량을 최대화시키는 알고리즘을 제시함
▶ Sherari, Sarin and Desai(1990) : makespan을 최소화하기 위한 대체공정 선택, 부하할당 순서 및 시기 결정을 위한 모형 및 알고리즘을 제시함
▶ Shingu and Nakamura(1985) : 순환형  FMS를 대상으로 일정계획 문제를 2단계로 나누어서 푸는 발견적 알고리즘을 제시함
▶ Kusiak(1988) : 기계가공과 조립이 포함된  FMS의 일정계획 문제를 다루기 위하여 2단계의 발견적 기법을 제시함
(2) Dispatching rule을 이용한 연구
▶ Stecke and Solberg(1981) : FMS의 부품할당(part loading) 문제 해결을 위해서, dispatching rule을 이용한 simulation 실시

▶ Slomp(1988) :  FMS 일정계획 문제를 4단계로 세분하고 이 단계들을 계층적으로 풀기위한, 3가지 발견적 기법을 제시하고 그중 SPT/TOT 규칙이 제일 우수하다고 주장

▶ Montazeri and Wassenhove(1990) : 20개의 dispatching rule을, 서로 다른 몇가지 비교평가 기준에 따라 simulation하고 그 결과를 제시함. (공정 및 부품생산량, 부품간 생산비 등의 자료가 같이 제시됨). 특정한 dispatching rule이 모든 비교평가 기준에서 항상 우월한 경우는 없다는 결과를 제시함

▶ Lin and Solberg(1991) : 대체공정을 고려했을 경우, 보다 나아지는 작업일정계획의 효과를 조사함. 실제공정 상태에 대한 정보 획득을 통하여 대체공정을 충분히 활용할 것을 주장함
이 외에도 dispatching rule을 적용한 연구는 매우 많다.

(3) 인공지능 기법을 이용한 연구

생산일정계획(scheduling)이란 제한된 가용자원을 효과적으로 배분하여 시스템 전체의 성능을 향상시키는 일(activity)이다. 작업자나 기계등의 상태는 시간이 지남에 따라 변화한다. 생산현장의 동적인 변화에 대하여 효과적으로 대응하기 위해 생산일정계획을 다시 작성하는 일(rescheduling)은 대단히 시간이 많이 걸리고 어려운 문제이다. 최근에는 이와같은 문제를 해결하기 위하여 인공지능 기법을 활용한 생산일정계획에 관한 연구가 많이 진행되었다(Browne 1988). 대표적인 연구로는 Fox의 ISIS(Fox and Smith 1984), Shaw의 Pattern-directed Search를  이용한 연구(Shaw  1988,1989), Wysk의 simulator를 이용한 multipass 일정계획(Wu and Wysk 1987), Ow의 OPIS(Ow 1986), Sarin의 동적 일정계획에 관한 연구(Sarin 1990), 안재경의 지능형 일정계획에 관한 연구(Ahn 1991) 등이 있다. 

ISIS(Fox 1984)는 생산일정계획에 인공지능 기법을 적용한 연구의 효시라 할 수 있는 시스템이다. ISIS는 계층적 제약조건지향의 탐색 방법 (hierarchical constraint-directed search)을 사용하여 job shop에 대한 생산일정계획을 수행하였다. Fox는 job shop을 여러 가지의 제약조건이 모여 있는 것으로 보고, 이 제약조건을 만족시켜 가는 과정을 생산일정계획의 수립과정으로 보았다. ISIS에서는 5가지의 제약조건群(constraint category)을 제시하였는데, 납기, 공정중재고, 품질, 생산성 등과 같이 생산 조직의 목표(organizational goal)와 관련된 제약조건, 기계나 장비의 물리적인 특성, 가동준비 시간 등과 같은 물리적인 제약조건(physical constraint), 대체공정, 공구, 자재, 사람 등과 같은 일시적인 제약조건(casual restriction), 기계고장 시간, 근무 교대 등과 같은 가용성 관련 제약조건(availability constraint), 그리고 특정 공정이나 기계 등에 우선순위를 주는 선호도관련 제약조건(preferrence constraint) 등이다. ISIS에서는 문제영역에 대한 지식(domain knowledge)과 제약조건을 구조 표현 언어인 SRL(schema representation language)을 이용하여 표현하고, 각 표현단계(abstraction level)별로 실행모형(activity model)과 표현단계 사이의 계층적 관계(relational hierarchy)를 나타내었다. 그러나 주문선택을 중심으로 생산일정계획을 진행시켜 나가기 때문에, 기계고장 등과 같은 동적인 상황(dynamic event)에 대응하는 면에서 취약한 단점을 가지고 있다. 

ISIS의 약점을 보완하여 OPIS라는 시스템이 Carnegie-Mellon 대학에서 개발되었다(Ow, 1986). OPIS는 많은 수의 제약조건을 균형시키기 위해 자원, 주문, 사건에 근거한 문제분해방법(multiple problem decomposition approach)을 사용하였다. OPIS시스템은 현장의 상태를 여러가지 관점에서 파악하여, 그때의 상황에 가장 적절한 생산 일정계획 방법을 사용하도록 설계되어 있다. 
예를 들어 bottleneck 공정에서는 기계중심의 생산 일정계획을 수행하고, 나머지 공정에서는 주문중심의 생산 일정계획 방법을 사용하였다. OPIS는 Hearsay II의 blackboard 개념을 이용하였고(Barr 1989), 시스템관리 모듈과 생산일정계획 작성모듈이라는 두 가지 종류의 계층적 지식기반(hierarchical knowledge source)을 가지고 있다. 이 지식기반 구조는 생산일정계획의 제어와 조정을 용이하게 해준다. OPIS시스템은 기계중심의 생산일정계획과 주문중심의 생산일정계획을 비교해가며 추론을 수행하기 때문에 분산인공지능 기법의 사용에 대한 동기를 제공하고 있다. ISIS와 OPIS는 모두 predictive 생산일정계획을 위한 동기를 제공하고 있다. 

Sarin(Sarin 1990) 등은 이와 같은 약점을 극복하고, 동적인 상황에 대처할 수 있는 reactive 생산일정계획 시스템을 제안하였다. 이들의 접근방법은 ISIS나 OPIS에서 취하고 있는 문제분해 접근법이 아니라 문제를 유형 별로 분류하는 접근법(problem categorization)을 취하고 있다. 생산현장의 동적인 특성을 해결하는 것은 대단히 지식집약적인 문제풀이과정이다. Sarin 등의 연구는, 생산현장의 경우 대개는 특정한 상황마다 생산일정계획 담당자 나름대로 그 상황에 대처해 나가는 묵시적인 원칙과 전략이 있다는 사실에 착안하여 진행되었다. Sarin 등은 생산현장에서 발생할 수 있는 동적인 상황을 [사전에 예측할 수 없고 생산시스템의 상태에 변화를 유발시키는 disruption]으로서 정의하고 기계고장, 긴급주문, 새로운 주문의 수주, 자재고갈, 작업자 결근, 가공완료, 근무교대와 같은 7가지의 경우를 제시하였다. Sarin등은 동적인 데이타베이스(dynamic database)를 운용하기 위하여 blackboard 개념을 사용하였으며, 모듈화된 지식기반을 유지하여 blackboard와 함께 서로의 정보를 이용하도록 하였다. 또한 frame 구조와 relational table 그리고 생성규칙을 이용하여 지식을 표현하고, 작업관련 정보를 나타내는 frame과 근무교대 정보를 관리하는 frame 등 2가지 frame을 제시하였다. Sarin 등은 그들이 제안한 문제중심형 접근방식(problem-based approach)이, ISIS나 OPIS에서 채택하고 있는 문제분해형 접근방식(problem decomposition approach)보다 더욱 적합한 방법이라고 주장하였다. 이와 같은 주장은 생산시스템의 분산성과 실시간응답 및 제어요구 등을 고려해 볼 때 타당성을 갖는다고 여겨진다. 

안재경(Ahn 1991)은 규칙기반형 전문가시스템을 이용한 일정계획시스템을 제안하였다. 규칙이 작동되는데 필요한 조건들은 시스템 내에서 발생되는 것들과 시스템 외부에서 발생되는 것들로 나누어 생각하였다.  이외에도 Shaw는 pattern search를 이용한 지식기반형 생산일정계획을 제안하였고 (Shaw 1985), 많은 연구진들이 인공지능 기법을 응용한 생산일정계획에 참여하였다 (Browne 1988, Oliff 1988a, Oliff 1988b).

2.2 FMS 운용 제어에 관한 접근방법
 
   2.2.1 중앙집중형 및 계층형 제어를 이용한 연구

FMS의 생산과정을 계층적으로 보고, 이 흐름을 제어함으로서 FMS의 일정계획을 수행한 연구는 1983년에 Kimemia와 Gershwin에 의하여 시작되었다(Kimemia and Gershwin 1983).  그들은 흐름제어 이론과 동적계획법, 선형계획법을 사용하여 계층적인 흐름을 제어하였다. Maimon은 이 모형을 발전시켜서 대체공정을 다룰수 있고 feedback 제어가 가능한 새로운 모형을 제시하였다(Maimon 1987, Maimon and Gershwin 1988). Kumar 등은 실시간응답 특성을 가진 분산형 일정계획 방법을 제시하였다(Kumar and Perkins 1990).
 Kumar는 고장이나 자원고갈, 수요변동 등과 같은 요인을 사건으로 정의하고 이와같은 사건의 발생에 근거하여 제어기간을 조정하고자 했으며 최적화기법을 사용한 흐름제어 기법을 제시하였다.
2.1절에서 언급한 인공지능을 이용한 기법의 대부분은 중앙집중형 및 계층형 구조에 속한다. 이 연구들 중에서 지능형 일정계획이나, 지능형 simulation을 이용한 연구들은, 분산형 제어 시스템의 필요성을 강력하게 나타내 준다는 점에서 특히 주목할만하다. 

2.2.2  분산형 생산일정계획

생산시스템의 분산화와, 개별자동화의 진행에 의한 자동화의 섬 현상, 그리고 생산시스템의 robustness 보장을 위한 관리 및 정보시스템의 분산 유지 등으로 인하여 생산현장 내에서 분산시스템의 중요성이 크게 부각되고 있다. 생산일정계획 및 FMS 운용 제어 분야에서도 이와 같은 분산시스템의 특징을 반영한 연구들이 진행되었다.
 
Parunak(Parunak 1986, Kusiak 1988) 등은 YAMS(Yet Another Manufacturing System)라는 분산 생산일정계획 시스템을 개발하였다. YAMS는 객체지향형 시스템으로서 계층적인 구조를 갖도록 설계되었다. YAMS에서는 공장을 상위 단계의 work cell과 하위 단계의 workstation으로 모형화하고, 상위 단계에서 공장을 감독, 관리하는 기능을 수행하도록 하고 있다. YAMS의 주요 구성요소는 global scheduler, CAPP, team scheduler, dispatcher mover, workstation controller, work cell, workstation등이다. 각 workstation 또는 work cell끼리의 통신 및 정보교환은 Davis와 Smith(Davis,1983)가 제안한 "입찰네트워크(contract net)" 모형(4.2절 참조)을 사용하였으며 통신을 위한 방법으로는 각 workstation끼리의 협상(negotiation)을 사용하였다. 

Shaw(Shaw 1987)는 cell형 생산시스템에 LAN이 설치되어있는 경우를 대상으로하여 분산형 동적(distributed-dynamic) 생산일정계획에 관한 연구결과를 발표하였다. 이 연구에서 Shaw는, Davis와 Smith가 제시한 입찰네트워크 모형을 이용하여 네트워크 차원의 입찰(network-wide bidding) 방법을 사용하여 컴퓨터 통신망의 특성을 활용할 수 있는 분산 생산일정계획을 시도하였다. 또한 Shaw는 APN(augmented Petri net)을 사용하여 bidding scheme을 모형화 하였다. Shaw는 simulation을 통하여, cell제어용 컴퓨터에서 생산일정계획을 일괄적으로 수행하던 기존의 방법과 분산 생산일정계획의 방법에 대하여 비교분석을 하였다. 그 결과 분산 생산일정계획이 기존의 생산계획 방법보다 우월함을 보였고, 분산생산일정계획 중에서도 EFT(earliest finish time)에 의한 방법이 좋은결과를 보이고 있음을 밝혔다. 

Ow, Smith 그리고 Howie(Ow 1988)는 1988년에 CSS (cooperative scheduling system)라는 분산 생산일정계획 시스템을 제안하였다(Oliff 1988). CSS도 근본적으로는 Davis와 Smith의 입찰네트워크 모형과 협상(negotiation)방법을 채택하고 있다. CSS는 주무관리를 위한 work order manager(WOM)와 각종 기계 및 자원의 관리를 위한 resource broker(RB)로 이루어진다. RB는 각 자원에 하나씩 존재한다. WOM에서는 주문에 대한 작업완료 시간과 각 RB와의 계약을 맺는 일을 수행한다. ISIS나 OPIS에서는 일단 reservation이 이루어지면(즉, 생산일정계획이 결정되면) 절대로 그 생산일정계획을 바꿀 수가 없다. 만약 바꾸고자 하는 경우에는 생산일정계획을 재작성(rescheduling)해야 한다. CSS에서는 WOM과 RB가 각 주문에 대하여 여유시간을 계산하여, 전체 생산일정계획을 유지하는 범위 내에서 특정작업의 가공시작 시간이나 가공완료 시간을 여유시간만큼 변경시켜 줄 수 있는 융통성을 가지고 있다. 그러나 Davis와 Smith의 입찰네트워크모형을 사용한 대부분의 연구는 resource node 끼리의 재협상이나, 컴퓨터 통신망을 통한 정보교환시의 문제점, FMS의 복잡한 물류시스템 등을 간과하고 있어서 실제 실행모형으로서의 가능성은 의문시 된다. 

Upton과 Barash는 FMS의 분산 운용 시스템을 대기행렬 네트워크(queueing network)를 이용하여 수리적으로 분석하고자하는 연구를 수행하였다(Upton 1991). 이들의 연구는 입찰모형(auction model)을 이용하여 모형화된 FMS를 대상으로 하고 있으며, 수 많은 simulation을 통하여 수리적 의미에 대한 해석을 시도하였다. 그러나 이 연구는 기본적으로 분산시스템의 수행도를 분석해보는 simulator라는 점에서 기존의 대기행렬 네트워크와 크게 다르지 않으며, 실제 운용을 위한 구조를 개발하는 기존의 연구와는 다소 거리가 있다고 할 수 있다. 

Nof는 여러대의 robot가 일정한 공간을 공유하며 작업하는 경우에, 이들 사이의 협조 및 경쟁관계에 의하여 진행되는 작업을 제어하기 위한 의사결정 모형을 분산 시스템으로 모형화하였다(Hanna and Nof 1989, Rajan and Nof 1990). Nof의 연구는 cell 단위로 제어되던 기존의 운용 방식에 대한 연구를, 보다 구체적인 수준의 제어를 요구하는 robot과 같은 요소기계의 수준까지 확장했다는 점에서 향후의 연구방향과 관련하여 주목할만 하다고 할 수 있다.  

Rana와 Taneja는 AGV의 제어 방법을 고려한 분산시스템 모형화에 대한 연구를 수행하였고(Rana and Taneja 1988), O'Hare(O'Hare 1990)는 분산인공지능의 기법을 생산시스템에 응용한 사례에 대한 조사를 하였으며, 문장석(문장석 1993)은 배정문제(assignment problem)를 이용하여 부품과 자원의 할당에 대한 입찰문제를 풀었다. 문장석의 모형은 실행의 관점에서 볼 때 분산형 모형이라고 하기보다는 오히려 정보의 집중화에 의한 중앙 집중형 구조를 취하고 있다. 정대영(정대영 1994)은 분산 제어시의 통신부하 문제와 AGV 및 AS/RS 등과 같은 물류 시스템에 관한 상세한 연구를 포함하고 있어서 FMS의 분산 제어와 관련된 향후의 발전방향과 관련하여 많은 점을 시사하고 있다. 

2.3 본 논문에서 제안된 시스템

본 논문에서는 LAN이 설치되어 있는 FMS의 생산일정계획과 생산현장제어를 위하여 분산형 동적 (distributed-dynamic) 구조를 가진 생산현장제어 시스템 MODERATO를 제안하였다. MODERATO란 MODEl for Robust And Transparent control of manufacturing Object에서 밑줄친 철자의 합성으로 이루어진 것이다. 어떤형태의 문제라도 그에 대한 해법으로 가장 이상적인 방법은, 수학적 모형 구축을 통한 최적해를 구하는 방법이지만, FMS처럼 복잡한 시스템의  분산제어 시스템을 수학적으로 정확하게 모형화하고 최적해를 구하는 것은, 현실적으로 거의 불가능하다고 할 수 있다. 그러나 이와 같은 어려움이 있다고 하여, 중앙집중형(off-line schedule generation 방식) 운용 제어 방식이나 그 변형을 분산적인 특성을 가지는 FMS의 운용에 그대로 적용한다면 아주 나쁜 결과를 초래할 것이다. 따라서 양자의 장점만을 택하여 FMS의 분산 제어에 적합한 새로운 방법을 도입한다는 의미로, 협상과 업무공유 방법을 이용한 MODEARTO 시스템 구조를 제시하였다. 이와같은 개념은 음악 용어로서의 "moderato(보통 빠르게)"와도 그 의미가 잘 부합되는, 重意的인 의미를 가지는 모형이름이다. MODERATO는 Davis와 Smith(Davis 1983)가 제시한 "입찰네트워크"를  기반으로 하여 개발된 모형이다. MODERATO는 크게 3종류의 agent로 구성되며, 각 agent는 LAN상의 하나의 node에 대응된다. LAN을 통하여 각 agent는 자신에 관한 최신정보를 보내며 이와같은 정보를 근거로 shop에 관한 상황을 파악하고 독자적인 의사결정을 할 수 있다. MODERATO에 관한 자세한 내용은 4장에 나와있다. 본 논문에서 제시된 모형이론적 방법론은, 실제 FMS의 운용 소프트웨어 등을 개발할때 대상 FMS에 그대로 이식(porting)시켜 사용할 수 있다. 또 모형의 각 기능들이 분산형 구조에서 다중 업무처리(multitasking) 서비스를 지원할 수 있고, 독자적인 입.출력을 가지기 때문에 modularity가 좋은 구조다. 따라서 확장성이 좋기 때문에 이 방법론을 채택하여 생산현장제어 시스템을개발할 경우, 시스템 설계를 위한 추가의 노력없이 그대로 객체지향형 시스템으로 개발할 수 있는 장점이 있다. 본 논문에서 수행한 연구는, 장기적으로 CIM전용 CASE(Computer-aided Software Engineering) Tool이나 simulator를 개발하는 것도 염두에 두어, 모형의 robustness를 유지할 수 있는 구조를 채택하였다.

3. FMS의 생산현장제어 문제

3.1 개요

지금까지의 연구에서는 생산현장제어라는 말이 명확한 정의나 구분없이 포괄적인 의미로 사용되었다. 그러나 FMS에 LAN 환경이 갖추어지고, 여기에 적합한 분산형 운용 제어 시스템을 갖추고자 하는 경우, 생산현장제어 문제는 매우 복잡해진다. 왜냐하면 생산현장제어는 그 의미상 FMS 공장 내에서 일어나는 모든 일(activity)을 제어하겠다는 뜻으로서, 제어대상으로는 유형의 것은 물론이고 무형의 것도 포함되기 때문이다. 그러므로 FMS의 생산현장제어 문제를 보다 정확히 다루기 위해서는 생산현장제어에 대한 정의가 선행되어야 한다.   
본 논문에서는 생산현장제어를 3가지로 정의하였다. FMS 공장내에서의 실제 생산흐름(physical flow)과 이때 이 흐름을 FMS 제어 컴퓨터에 알리기 위해 발생하는 정보흐름(information flow), 그리고 이 두가지 흐름을 지원하기 위한 도구로서의 통신메시지흐름(communication flow), 이 3가지 흐름을 제어하는 것을 FMS의 생산현장제어라고 정의하였다. 생산현장제어 문제를 이와같이 구분하지 않으면 다음과 같은 문제가 발생할 수 있다. 전체 FMS의 운용을 위한 시스템과의 연계시에, 정보 불일치 또는 통신지연 등의 발생으로 인하여, 본래 잘 설계된 생산현장제어 시스템이 궁극적으로 나쁜 성능을 보일 수 있다. 또 향후 생산현장제어 시스템의 성능 개선이나 FMS 확장 및 변경에 따른 생산현장제어 방식의 수정 필요시에, 상호작용이 있는 내용들을 찾아내기가 매우 어려워지기 때문에 중복되는 노력의 투자가 발생될 수 있다.
위에서 구분한 3가지의 생산현장제어 문제는 의미상으로는 상호 독립적으로 존재하지만, 실제 행동은 3가지가 동시에 일어나기 때문에 반드시 구분하여 다루어야만이 이미 언급한 문제점들을 피할 수 있다.
본 논문에서 제시한 협조-분산형 생산현장제어 개념은 우선 생산흐름제어에만 적용되었다. 궁극적으로는 3가지 범주의 생산현장제어 문제를 모두  협조-분산형 제어의 개념아래 구현할 수 있다. Dilts와 Boyd 그리고 Whorms는 공동으로 펴낸 논문에서, FMS와 같은 자동화된 생산시스템을 제어하는 방식이 어떻게 변화하면서 발전해 왔는지를 구조적 관점에서 자세히 설명하고 있다(Dilts, Boyd, and Whorms 1991). 다양한 구성 요소들이 있을때, 이 요소들을 결합하여 특정한 목적에 부합되는 시스템을 만들어 낼 수 있는 방법 또한 다양하다. FMS 운용제어를 위한 제어구조란, 특정한 목적을 달성하기 위한 제어 시스템을 구성하기 위해 여러 가지 요소들을 구성하고 결합시키는 일종의 규칙(protocol)이다. 

[그림 3.1.1]  제어모형

FMS의 속성상 제어요소로는 주문, 각종 자원, 각종 메시지 등이 될 수 있으며, 제어시스템으로는 생산현장제어 시스템 등이 있을 수 있다. 이때 생산현장제어라는 목적을 달성하기 위해 사용가능한 제어구조로는 기존의 off-line schedule generation 방식부터, 본 논문에서 제시하고자 하는 분산형 방법까지 다양한 구조가 사용될 수 있다. 
Dilts와 Whorms는 생산시스템에 사용되고 있는 제어구조를 세가지로 분류하였다. 첫째는 중앙 집중형 제어구조로서 호스트 컴퓨터내에 main database를 두고 여기애서 모든 정보취합과 제어명령의 발생 등이 이루어지는 구조를 취하고 있다. 중앙 집중형 제어구조의 특징은 의사결정과 관련된 모든 책임이 호스트 한곳으로 집중되어 있다는 사실이다. 둘째는 계층형 제어구조로서, 다단계로 이루어진 중앙 집중형 제어구조라고 할 수 있다. 각 단계별 제어활동은 상위단계의 권한 범위내에서만 이루어지며, 이와 같은 상.하관계가 최상위단계까지 구축되어 있다. 따라서 계층형 제어구조하에서의 의사결정은 중앙 집중형 제어구조와 같이 이루어지지만, 각 단계별로 제어와 정보취득 및 처리는 분산화 되고 있다. 현재까지 대부분의 생산시스템의 운용제어는 이 방식을 채택하고 있다. 美國 표준국에서 제시한 AMRF (Advanced Manufacturing  Research Facility) 모형이 가장 대표적인 사례다. 셋째는 분산형 제어구조로서 컴퓨터 통신, 정보처리, 센서 등의 급격한 기술발달로 이루어진 '자동화의 섬' 현상과 생산시스템 내의 각 제어 요소의 지능화 (local intelligence)의 향상으로 등장한 구조다. 분산형 제어구조는 각 제어요소에 독자적인 의사결정권이 주어짐으로써, 의사결정이 분산화 되는 구조를 제공하고 있다. 그러나 각 제어요소 사이의 통신 과부하 문제를 동시에 가지고 있는 단점이 있다. 따라서 분산 시스템의 설계시에는 통신부하 문제를 반드시 함께 고려해야만 한다. 결국 적절한 제어구조의 선택을 위해서는 의사결정의 권한위임 여부, 제어에 필요한 정보기지를 어디에 둘 것인가, 제어에 필요한 각종 메시지의 발생지와 목적지가 어디인가 라는 이 세가지의 요소가 가장 중요한 고려요소라 할 수 있다. 현재 각종 하드웨어의 저가화, 고기능화 및 소프트웨어와 관리기술의 고급화 등에 힘입어 생산시스템의 자율성(autonomity)과 지능화(intelligence)가 급격히 추진되고 있는 추세다. 이와 같은 상황으로 미루어 볼 때 향후에 전개될 자동화된 생산시스템의 제어구조 또한 고도의 자율성을 지원하는 구조가 되어야함이 자명하다. 따라서 FMS의 운용 제어 구조로서 분산형 제어구조를 선택함이 타당하며, 자율성, 지능화에 덧붙여, 각 제어 요소 사이의 협조(cooperation)와 이를 통한 제어능력을 갖출 수 있는 구조로 확장함이 필요하다. 본 논문에서 제시하고자 하는 제어구조는 이와 같은 특성을 지원하는 형태다.

3.2 정보흐름제어

정보흐름제어는 FMS 공장의 데이타베이스에 주로 관련된 내용이다. 정보흐름제어는 CIM이 진행될수록 더욱 더 그 중요성이 부각되는 분야임에도 불구하고, 기술적인 어려움으로 인하여 상대적으로 연구가 덜 이루어진 분야이다. FMS 공장에서 일어나는 모든 일은 반드시 제어실 내의 컴퓨터상에 통보되어야 한다. 예를 들어, 기계에서 부품가공이 완료됨, 새로운 부품의 가공이 시작됨, AGV가 이동함, pallet을 내려 놓음, 기계가 고장남, 공구가 파손됨 등의 모든 사항은 그때 그때 곧바로 LAN을 통하여 컴퓨터상에 보고가 된다. 뿐만 아니라 설계실에서의 제품사양 변경이나 MRP 자료의 변경 등과 같이 다른 데이타베이스의 내용에 영향을 주는 내용들의 변경도 제어되어야 한다.

[그림 3.2.1] Client/Server 구조를 이용한 정보흐름제어

정보흐름제어에서 주된 제어 대상은 정보의 내용상의 일치성 및 무결성(integrity)과 시간이다. 정보를 주고 받는 쪽이 서로 다른 운영체제, 서로 다른 데이타 모델에 근거한 데이타베이스, 또는 서로 다른 정보처리 소프트웨어를 사용하는 경우에 정보흐름제어는 대단히 중요한 일이 된다. 이중 운영체제와 정보처리 소프트웨어에 관련된 문제는 화일 변환 등의 방법으로 비교적 쉽게 해결할 수 있으나, 데이타베이스 문제만은 데이타의 의미(semantics) 문제 때문에 매우 복잡한 제어체제를 갖추어야 한다. 데이타베이스 관련 문제는 크게 세가지 유형으로 나눌 수 있다. 첫째, 모든 노드가 동일한 DBMS 소프트웨어를 사용하는 경우, 둘째, 모든 노드가 동일한 데이타 모델을 사용하지만, 서로 다른 DBMS 소프트웨어를 사용하는 경우, 세째, 모든 노드가 서로 다른 데이타 모델을 사용하는 경우 등이다. 문제가 되는 것은 두번째와 세번째의 경우이다. 
먼저 두번째의 경우를 살펴보자. 이 문제는 해결하기가 비교적 덜 복잡하다. 데이타 모델이 같기 때문에 약간의 기교에 의하여 화일 및 자료의 변환이 가능하다. 가능한 방법의 한가지로 SQL server를 가진 client/server 구조를 제시할 수 있다. (그림 3.2.1 참고)

[그림 3.2.2] 전문가시스템을 이용한 데이타베이스 통합방법

세번째의 경우는 이론적으로 대단히 어렵고 복잡하다. 이른바 분산데이타베이스에 관련된 내용이다. 현재까지 이와같은 상황을 완전히 지원하는 DBMS는 존재하지 않는다. 따라서 서로 다른 DBMS간의 화일변환과 의미변환, 정보전송여부, 그리고 데이타의 무결성까지를 만족시켜주는 기능을 수행할 수 있는 제어시스템을 규칙기반형 전문가 시스템을 이용하여 제작하여 사용하고 있다(그림 3.2.2, 그림 3.2.3).

[그림 3.2.3] 그림 3.2.2의 시스템통합에 대한 상세모형

3.3 통신메시지 흐름 제어

통신메시지 흐름제어(communication control)는 생산시스템 내의 LAN을 지원하는 문제다. 공장자동화를 이루는 생산자원들 간의 통신 네트워크를 지원하는 데 사용하는 프로토콜로서 MAP (manufacturing automation protocol)을 사용하고 있다 (현재는 MAP Ver 3.1이 표준으로 사용됨). MAP을 사용하는 목적은 자동화를 추진하는데 있어서 , 異 기종 기기간의 통신 및 접속문제를 해결하기 위하여 국제적 표준에 기반을 둔 프로토콜을 사용함으로써 생산자동화 도구의 개발 및 이용에 통일을 이룩하려는 것이다. 

[그림 3.3.1] OSI 계층구조 및 통신환경

MAP 3.0은 국제 표준기구에서 제시한 OSI (Open System Interconnection) 7계층표준모형을 기반으로 구성되며(그림 3.3.1), 특히 공장의 특수한 통신환경 및 요구사항을 반영하기 위해서 10Mbps의   broadband를 바탕으로 토큰버스에 의하여 운영되는 하위계층과, 메시지 전달 및 처리를 하는 상위계층, 그리고 각종 응용 프로그램으로 구성된다. 

[그림 3.3.2] OSI 표준모형과 MAP의 비교

그러나 공장내에서의 사용을 전제로 구성된 MAP과, 범용통신구조를 지원하기 위한 OSI 표준모형과는 실제 구현 및 운용상에서 약간의 차이를 보이고 있다. 계층화 및 각 계층의 기능은 서로 동일하지만 MAP에서는 계층의 구분이 공장의 상황을 반영하고 있어 계층의 범위가 약간 다르다(그림 3.3.2).
[그림 3.3.2]의 7계층 구조중 생산현장제어 관점에서 볼 때, 산업공학 분야에서 해결해야 할 부분은 상위계층의 일부와 응용 프로그램 계층의 내용들로서, 이것들은 알고리즘을 개발하던 기존의 연구와는 그 궤를 달리한다.  응용계층은 각종 응용 소프트웨어들과 연결제어 서비스요소 (ACSE ; association control service element) 그리고 사용자의 각종 응용 프로그램으로 구성된다. 응용계층에는 다음과 같은 소프트웨어들이 있다.
       FTAM: file transfer, access and management
       MMS: message management system
       DS: directory service  

[그림 3.3.3] LAN이 설치되어 있는 FMS의 통신환경

OSI 표준모델은 응용계층이 presentation 계층의 응용 한가지만을 수용한다. 그러나 MAP에서는 [그림 3.3.2]에서 보는 것처럼 응용 프로세스가 presentation 계층의 응용 뿐만 아니라 FTAM, MMS, DS와 같은 여러가지 응용을 수용해야 하기 때문에 이 두가지 요소를 관리할 수 있는 ACSE 계층이 응용계층 안에 별도로 존재한다. 바로 이와같은 MAP의 특징 때문에 LAN이 설치되어 있는 FMS의 분산 운용을 위한 생산현장제어는 알고리즘 지향적인 기존의 연구로부터, 모든 물리적, 논리적, 개념적 실체(entity)를 포함하는 시스템 지향적인 연구로의 전환을 필요로 하고 있다. [그림 3.3.3]은 LAN이 설치되어 있는 FMS의 전형적인 통신환경이다. 
각종 기계 및 설비, 장치에 연결되는 컴퓨터에는 LAN과의 접속을 위한 하드웨어 접속과 네트워크 프로토콜을 운영하는 네트워크 소프트웨어가 필요하다. 여기에다가 생산계획, 일정계획, 공정관리, 진도관리 등의 각종 응용 프로그램들이 탑재되는 경우에는, 다시 이 프로그램들의 관리 및 운용을 위한 부분이 네트워크 소프트웨어에 추가되어야 한다. 즉 분산 제어를 위한 의사결정 프로토콜이 추가로 필요하게 된다. FMS 생산현장제어 시스템 개발의 실제적인 어려움이 바로 여기에 있는 것이다. 알고리즘 개발을 위주로 하던 기존의 생산현장제어 연구는 분산 제어를 위해 필요한 층(layer)의 개념을 전혀 반영하지 않았다는 점에서 그 한계를 명확히 드러낸다. 특히 기존의 연구들은 "operation scheduling"과 제어에만 치중한 나머지 실제 운영의 문제들을 간과함으로서, 실제로 모형을 응용하고자 하는 경우에는 분산시스템과의 접속을 위한 모형의 수정 및 새로운 설계가 추가되어야하는 단점이 있었다. 본 논문에서는 협조-분산형 접근방법을 사용함으로써, 네트워크 소프트웨어의 운용과의 접속 및 응용프로그램 구현까지가 하나로 융합된 방법을 제시하였다. 이와같은 접근법은 향후의 실제 FMS 운용소프트웨어 개발시에 보다 유용한 방법으로 사용될 수 있다. 이에 관한 자세한 내용은 4장에서 다루었다. 

3.4 생산흐름제어(operational control)

생산흐름제어는 FMS 공장내에서 가공할 부품들의 생산과 관련된 실제 활동을 제어하는 것이다. 이러한 활동으로는 부품생산지시 및 가용자원할당, 공장의 상태정보 파악, 각종 이상 현상의 발생 등이 있다. 생산현장제어를 생산흐름제어의 관점에서 파악해 본다면 기존의 작업일정계획과는 다르다. 작업일정계획은 부품생산지시 및 가용자원할당 문제에 주로 치중한 반면 공장의 상태 파악, 실시간 반응, 이상 현상의 대처에는 매우 취약한 구조를 가지고 있다. 진정한 의미의 FMS, 즉 진정한 의미에서 '유연성 있게' 제어, 운용하려면 바로 이와같은 요소들에 대한 해결 능력이 있는 생산현장제어 구조를 제시해야 한다. 이 문제는 바로 3.2절과 3.3절에서 언급한 문제와도 긴밀하게 얽혀있어서 대단히 복잡하고 어렵다. 가장 자연스러운 접근법은 FMS 공장에서 발생하는 상황과 그것을 처리하는 대처방법을 그대로 모형화하는 것이다. 물론 이것은 이상적인 대안이지만 최소한 이와같은 원칙을 견지할 때만이 성능 좋은 생산현장제어 시스템을 개발할 수 있을 것이다. 
따라서 기존의 작업일정계획 시스템과는 달리 생산현장제어 시스템은 다음과 같은 기능을 가져야 한다.
① 예정된 계획이 지켜질 수 없을 때, 생산을 어떻게 지속시켜 나갈 것인가?
② 고장, 자재고갈 등의 이상 현상 발생시에는 어떻게 대처해 나갈 것인가? 
   여기에는 다시 ①번 문제가 포함된다.
③ 시스템이 안정된 상태에서 가동될 수 있도록 사전 예방적 대응을 할 수
   있는 능력이 있는가?

[그림 3.4.1] Shop floor controller의 기능

즉, 기계고장의 예측, 시스템 정지상태 예측 및 방지대책, 정지상태 발생시의 해결 능력 등을 가져야 한다. 이와같은 기능은 다시 더 많은 세부 종속기능으로 기능적인 분해를 하여야 한다. 왜냐하면 그와같은 세부기능 하나 하나가 생산현장제어 시스템의 성능에 크게 영향을 미치기 때문이다. [그림 3.4.1]에 바람직한 생산현장제어 시스템이 가져야 할 기능을 개략적으로 표시하였다. FMS 연구에서 일반적으로 loading은 가공기계와 부품의 공정을 match 시키는 것을 의미한다. 본 논문에서 언급된 loading 제어란 일반적 FMS의 loading과 scheduling을 합한 개념이다(그림3.4.1 참고). 이 부분은 넓은 의미의 생산현장제어 시스템에 포함된다고 볼 수 있다. Dispatching 제어란 Loading에서 내린 의사결정을 수행하기 위하여 부품과 가용자원을 결합시키는 과정이다. Material Handling 제어는 AGV나 AS/RS와 같이 부품의 저장, 이동등과 관련된 자원들을 관리하는 것이다. 이 세가지는 기존의 생산현장제어에서도 다루는 일반적인 내용이다. 진정한 의미의 FMS 분산 제어 시스템이 되기 위해서는 이외에도 시스템 이상현상 제어모듈, 시스템정지상태 제어모듈, 그리고 이런 상황에서의 의사결정지원을 위한 simulation 및 전문가 시스템, 그 외에 경영지원을 위한 통계처리 및 보고모듈 등을 포함해야 한다. 본 논문에서는 이와같은 개념지원을 위하여 협조-분산 형태의 협상 모형과 일반화된 확률적 Petri net (generalized stochastic Petri net) 모형을 사용하였다.

4. MODERATO : 분산-협조형 생산현장제어 모형

4.1 개 요

FMS 또는 CIM 환경에서의 생산현장제어를 다루는 많은 시스템들은 생산시스템의 분산성을 반영하지 못하고 있거나 또는 분산적 특성을 충분히 이용하지 못하고 있다. 앞 장에서 제시한 바와 같이 CIM화가 추진되면서 기업 또는 공장의 분산적 특징은 더욱 커지고 있으며 각 기계나 work cell의 지능화 정도, 정보가공능력, 컴퓨터 속도 및 용량 등이 급속히 향상되고 있어서, 각 work cell은 하나의 독립된 시스템으로서 작동할 수 있는 경우가 많다. 이와같은 점들을 고려해 볼 때, 향후 전개될 CIM화의 추진 방향은 loosely-coupled distributed system (LCDS)이 될 것으로 예측된다.

[그림 4.1.1] Tightly-coupled distributed system

[그림 4.1.2] Loosely-coupled distributed system

 LCDS란 tightly-coupled distributed system(TCDS)에 대응되는 개념으로서 원래는 컴퓨터 통신망을 구성할 때 분산시스템을 어떻게 설계할 것인가를 나타내는 개념이다. [그림 4.1.1]에 tightly-coupled distributed system의 개념도를 나타내었다. 
TCDS(그림 4.1.1)에서는 하나의 운영체제에 의해 분산시스템 전체를 제어하지만 LCDS(그림 4.1.2)에서는 분산된 개개의 시스템이 독자적인 능력을 가지고 전체 시스템의 공유자원을 이용하며, 상호간의 자료교환 및 작업수행시 협조가 이루어진다.  다른 workstation에 있는 자원을 이용하고자 하는 경우에는 통신망을 이용하여 해당 workstation에 접근하여 원하는 자원을 이용한다. 또한 개개의 분산된 노드들이 독자적인 입력과 출력을 가진다. 즉 독자적인 의사결정 권한을 가진다. 생산시스템의 경우를 비교해보면 생산계획, 일정계획이나 AGV의 이동 등과 같은 생산단계의 관리 및 제어문제 등 제반 의사 결정 문제를 풀고자 하는 경우, 반드시 현장상태에 대한 정보가 필요하다. 
 
[그림 4.1.3] Local intelligence를 갖춘 CIM의 개념도

이 경우 공장 내에 설치되어 있는 LAN을 이용하여 각 cell 또는 workstation의 상태 및 정보를 검색하고 host computer 내의 데이터베이스 검색 등을 수행하여 필요한 정보를 얻을 수 있고 또 각 노드에서는 독자적으로 입력과 출력을 조절함으로서 전체통신에 기여할 수 있다. 특히 각종 장비의 기능 향상, 가격하락, 소프트웨어의 다양화 및 고급화에 의하여 개개의 machining center 또는 work cell이 독자적인 computing power와 정보처리 능력과 의사결정 능력을 갖추어 가고 있는 것이 현실이며(그림 4.1.3), 장기적인 관점에서 볼 때 CIM이 구축되어 가는 추세라고 볼 수 있다. 따라서 각 노드 또는 시스템 전체에서 운용되는 소프트웨어도 이와같은 특성에 맞도록 설계 및 개발이 되어야 한다. 특히 생산현장에서는 더욱 그 영향이 크기 때문에 분산시스템의 특성이 반영된 새로운 생산현장제어 시스템이 개발되어야 할 것으로 여겨진다. 지금과 같이 최상위 단계에서 일방적으로 결정되어 내려오는 중앙집중식 의사결정 방식으로는 생산현장 내에서의 기계고장이나 자원고갈 등과 같은 동적인 상황에 효과적으로 대처하지 못할 뿐만 아니라, 각 노드의 intelligence를 효과적으로 사용하지 못하는 단점이 있다. 본 논문에서는 분산인공지능 기법을 이용하여 분산된 각 기계나 machine cell의 정보처리능력과 의사결정능력 등을 이용하고 동적인 상황에 대처할 수 있는 새로운 생산현장제어 시스템 구조를 제안하였다. 제안된 시스템은 생산현장에서 각 기계의 운용이나 자원의 배분 등과 같은 의사결정문제(operational decision making)를 다루고 있으며 분산된 각 노드 사이의 통신 지원과 생산현장의 제어 및 관리를 위한 정보처리를 지원해 주는 구조를 가지고 있다. 특히 분산인공지능 기법과 LCDS의 특성 및 장점을 충분히 이용하여, 각 cell끼리의 정보교환과 협상, 협조에 의한 의사결정을 수행하는 새로운 방법을 보여주고 있다.

4.2 Contract Net 모형

Davis와 Smith(Davis 1983)는 분산시스템의 문제해결을 위한 새로운 방법으로서 "입찰네트워크(contract net)"라는 모형을 제시하였다(그림 4.2.1). 입찰네트워크는 노드와 메시지로 이루어지며 각 노드는 메시지교환을 통하여 서로 통신을 한다. 입찰네트워크에서는 각 노드의 통신시에 각 노드 사이에서 일어나는 각종 메시지와 제어지시의 전달 등을 "협상(Negotiation)"이라는 방법을 통하여 모형화 하였다. 분산형 생산시스템의 경우 각각의 자동화의 섬이 바로 입찰네트워크의 노드에 해당한다고 볼 수 있다. 

[그림 4.2.1] Contract net 모형

분산시스템의 특성상, 시스템 차원의 정확한 해를 구하기 위해서는 각 노드사이의 협조(coorperation)에 의한 문제해결이 필요하다. 
이때 각 노드가 
어떻게(How to)통신을 하는지, 
서로 무슨 내용을(What)주고 받아야 하는가
를 규정해 주어야 한다. 이런 방식들을 체계적으로 규정해 놓은 것이 바로 "협상"의 개념이다. 협상의 개념을 이용하여 입찰네트워크상에서 특정 업무나 거래를 처리하고자 하는 경우 다음과 같이 3가지 종류의 노드가 정의된다. Manager 노드는 처리해야 될 업무를 정의하는 노드이고 bidder 노드를 contract 노드라 한다. 각 노드는 서로 다른 종류의 메시지 교환을 통한 bidding 과정을 이용하여 통신을 수행한다. 각 노드사이에 협상을 통한 메시지 교환이 이루어지는 방식을 간단히 소개하면 다음과 같다(그림 4.2.2). 

[그림 4.2.2] The bidding scheme

Manager 노드에서는, 새롭게 처리해야할 업무에 대한 정보와 bid에 대한 기준 등을 담은 task announcement 메시지를 각 노드에 보낸다. 이 메시지를 받은 노드들은 자기자신이 보유하고 있는 업무평가지침(task evaluation procedure)을 이용하여 업무 처리에 대한 정보(시간, 비용, 능력  등)를 담은 bid를 manager 노드에 보낸다. Manager 노드는 각 업무에 대한 bid 평가지침(task-specific bid evaluation procedure)을 이용하여 bid 정보를 평가한 후 업무 수행에 적합한 bid를 골라(1개 이상의 bid가 선택될 수도 있음) award 메시지를 보낸다. 선택된 노드는 업무 수행에 책임이 있으며, 동시에 contractor 노드가 된다. Contractor 노드는 award 메시지를 받아들일 것인지 아니면 업무 수행을 포기할 것인지를 담은 acknowledgement 메시지를 manager 노드에 보낸다. 업무를 실제로 수행하는 도중에 contractor 노드는 수시로 상황에 대한 정보를 보내 업무의 수행 상황을 알려주며 업무 수행이 끝나면 최종 보고를 manager 노드에 보낸다. Manager 노드는 중단 메시지를 contractor 노드에 보내서 업무의 수행을 중단시킬 수도 있다. Contract net상에서 업무의 수행중 업무 수행 완료 등으로 유휴 노드가 발생하면 노드 이용가능 메시지(node-available message)를 보내서, 새로운 업무의 수행을 위해 유휴 노드가 이용될 수 있음을 알려준다.

4.3 MODERATO 시스템 구조

본 연구에서는 Davis와 Smith의 입찰네트워크 모형(Davis 1983)을 확장하여, multiple-agent를 가진 분산-협조형(cooperative-distributed) 생산현장제어 시스템 MODERATO를 제안하였다. 입찰네트워크에 의한 bidding 방법을 생산현장제어에 적용하는 데 핵심이 된 개념은, 협상에 의한 자원배분이 대단히 효율적인 방법이라는 연구 결과이다(Oren 1975). 제안된 시스템은 order agent (OA), resource agent (RA), communication forwarding agent (CFA)의 3종류 agent로 구성되며, 공장 내에 여러 개의 work cell이 존재하고 각 cell은 컴퓨터 통신망으로 연결되어 있는 상황하에서 동적-분산형 on-line 생산현장제어 문제와 공장내의 이상현상 대처 및 시스템 정지상태 예방 문제를 다루고 있다. 효과적인 생산현장제어를 이룩하기 위해서는 다른 work cell의 정보나 현재의 공장상태(shop status)에 대한 정확한 정보를 가지고 있어야 한다. 따라서 본 시스템은 Davis와 Smith의 입찰네트워크를 기본구조로 채택하여 FMS의 분산 제어에 적합하도록 agent 개념을 도입하였으며, 정보처리의 효율성을 높이기 위해서 제어 시스템 내의 agent 사이의 통신문제를 다룰 수 있는 새로운 구조를 설계하고 대상 알고리즘도 개발하였다. Davis와 Smith가 제시했던 contract net은 노드의 개념을 사용하고 있으나 MODERATO 시스템에서는 노드 개념 대신에 agent 개념을 도입하였다. 일반적으로 simulation이나 소프트웨어 개발, 시스템 모형화 등에서는, 대상 실체(entity)를 나타내기 위해 노드, 모듈(module), agent 등의 개념을 사용한다. 이 때, 노드는 단순한 modeling construct를 의미하며, 모듈은 노드의 개념에 특정 목적의 기능이 추가된, 보다 발전된 개념의 모형화 도구이다. Agent는 모듈의 개념에 추가로 독자적인 의사결정 능력을 포함하는 최고급의 개념이다. 따라서 MODERATO 시스템에  agent 개념을 도입함으로서 각 제어요소들의 local intelligence를 최대로 활용할 수 있을 뿐만 아니라, 자율성을 보장하는 의사결정 mechanism을 구현할 수 있게 하였다. 특히 FMS의 분산 운영 제어 시스템을 구축하는 데 있어서 분산적 특징을 반영함에 따라 수반되는 통신 과부하 문제를 해결하기 위해 MODERATO에서는 제어구조 내의 통신만을 전담하는 agent로서 CFA를 도입하였다. 

[그림 4.3.1] MODERATO 시스템의 전체구성도

그러나  CFA가 도입됨으로써 자칫 복잡하게 될지도 모를 제어구조를 간단히 하기 위해서, MODERATO에서는 층(layer) 개념을 도입하여 2층 구조(2-layered architecture)를 가진 제어 시스템을 제안하였다. 이 구조는 일종의 client/server의 개념으로서, 통신의 관점에서 client와 server를 분리시켜 놓은 것이다. 즉, OA와 RA는 client 입장에서 통신에는 관심을 두지 않은 채 오로지 두 agent 사이의 정보교환 및 의사결정에만 전념할 수 있으며, 이때 수반되는 모든 통신관련 메시지 및 자료는 CFA가 처리하게 된다. 다시 말하면 CFA는 shop floor layer로 부터 개념상 숨겨져 있어서(hidden), 전체 제어 논리의 흐름상 자연스러움을 제공함과 동시에 분산 제어 구조에 수반되는 통신부하 문제를 해결할 수 있게 된다. 전체적인 시스템의 구성도는 그림4.3.1과 같다. 각 agent의 상세한 구성도는 해당 절에서 나타내기로 한다.  
[그림 4.3.2] Cooperative-distributed shop control의 개념도

MODERATO 시스템은 다음과 같이 작동한다. [그림 4.3.2]에서 보듯이 OA에서는 수행해야 할 작업들에 대한 정보를 각 RA에 알려주는 task announcement를 한다. 동시에 RA에서는 각 자원의 상태를 기록한 shop status vector (SSV)를 CFA에 보낸다. SSV는 event가 생길 때마다 수시로 보내게 된다. OA가 task announcement를 할 때는 반드시 사전에 SSV를 참고하게 된다. Task announcement를 받은 RA들은, 각자의 목적함수와 평가기준에 따라 task announcement에 나타난 작업에 대한 작업완료시간을 계산하여 OA에 bid를 보낸
다. OA는 RA에서 보내온 bid를 평가기준에 따라 평가하여 그 중 적합한 것을 선택하고 award 메시지를 보낸다. RA는 자신이 할당되었음을 알리는 내용을 담아 SSV를 CFA에 보낸다. RA는 자신에게 할당된 작업을 마치면 다시 SSV를 보낸다. 만약 위와 같은 일이 일어나는 중간에 긴급주문이 있을 경우 OA는 CFA에 있는 SSV를 참고하여 적당한 시점에 interrupt 메시지를 보낸 다음 위와 똑같은 과정을 거쳐 긴급주문을 처리하게 된다. OA에는 작업배정을 제어해주는 전문가 시스템이 있으며, shop의 상태나 공정의 진행도, 이상현상의 발생 등에 대처하여 생산전략을 조절해 주는 event처리기와 part/resource 제어모듈이 있다. CFA에서는 시스템의 원활한 운영을 위하여 말 그대로 "flexible"한 상태를 유지할 수 있도록 on-line 감시 시스템을 운영하고 있다. 각 agent의 기능 및 구조는 다음 절에 그림과 함께 자세히 설명되어 있다.

4.4 The Order Agent (OA)

OA는 처리해야 할 작업 등을 각 기계에 할당해 주는 역할, 공장 내의 이상현상에 대처하는 역할을 한다. 즉 job dispatcher의 역할을 수행하며, 수행해야 할 job들에 관한 정보를 RA에 보내준다. 이때 audience restriction이란 개념을 사용한다. Audience Restriction이란 OA에서 task announce를 할 때 해당 작업을 처리할 수 있는 자원,  즉 대체공정 리스트 상에 존재하는 자원의 agent에게로만 task announce 메시지를 보내는 것을 말한다. Audience Restriction 개념에 의하여 OA가 task announce 메시지를 보낼 때는 모든 RA를 대상으로 하는 것이 아니라, 대체공정(alternative routing)상에 열거된 자원의 agent에게만 메시지를 보내게 된다. 이 방법에 의하여 전체 RA에게 메시지를 보낼 때보다 통신부하를 줄일 수 있다. OA내의 dispatching 전문가시스템은 job, 공정 등과 관련된 데이타와 job dispatching을 위한 각종 발견적 방법 및 규칙들을 유지하고 있다(부록 A 참고). OA에서 발생하는 메시지의 종류는 표4.4.1과 같다.

[표 4.4.1] OA에서 발생하는 메시지의 종류

OA는 주어진 생산시스템의 생산량을 극대화시키는(Max. throughput)것을 주 전략으로 삼고, 제품의 납기를 준수하여 생산하는(Min. number of tardy job)보조전략을 채택하고 있다. 이 두가지 전략의 달성을 위하여 수많은 dispatching 규칙들을 동원할 수 있으며 이 역할은 전문가시스템에서 수행한다.이 두 가지의 목적함수를 충족시키기 위해서 본 연구에서는 두 가지 방법을 사용하였다. 첫째로 각 job에 대한"criticality"개념을 사용하였다. Job의 criticality CR은 

      CR = TNOW + (잔여공정 가공시간) +  %

로 정의된다. 만약 CR이 납기보다 크면 그 job은 critical하다고 정의하고,어떤 job이 critical하다고 판정되면 dispatching전략을 바꾸어 준다. 

[그림 4.4.1] Order agent 상세구조도

Criticality의 정의에 사용된  %는 일종의 주관적 신념을 반영하는 척도로서 기존의 생산일정계획에서 사용되었던 dynamic slack과 유사한 개념이다. 값의 설정 정도에 따라서 생산현장의 관리를 엄격하게 할 것인지 아니면 느슨하게 할 것인지가 결정되며, 나중에 생산 일정계획의 조정이 필요한 경우에는 값이 원래 의미의 여유시간 역할을 수행하게 된다. 즉 값은 time buffer의 기능을 가질 수도 있다. 둘째로 지능형 작업할당 방법을 사용하였다. 실제 생산현장의 경우 생산일정계획 담당자는, 미리 정해진 원칙이나 규범이 없어도 자기 자신의 경험과 판단으로 異常현상에 대처해 나가는 자신만의 독특한 원칙과 방법이 있고, 이 방법들이 좋은 결과를 보여주고 있음이 알려져 있다(Sarin, 1990). 본 연구에서도 이 점에 착안하여 생산일정계획 담당자의 지식과 원칙을 이용하기 위한 방법으로 "지능형 작업할당(intelligent dispatching)"전략을 사용하였다. 기존의 생산일정계획 방법들은, 특정목적함수를 가장 잘 구현해 주는 특정한 rule을 사용하는 방식들을 취해왔다. 이 방법에서는 특정 rule이 한 번 선택되면 끝까지 그 방법에 의해 생산일정계획이 이루어지기 때문에 시스템에서 異常현상이 생겼을 때에는 수행도가 현저하게 나빠지는 단점이 있다. 이와같은 단점을 극복하기위해 Wu는 MPECS라는 시스템을 제안하였다(Wu,1987). MPECS에서는  t라는 interval마다 shop의 상태를 simulation하여 거기에 맞는 dispatching rule을 찾아 적용시켜 주고 있다. 그러나 초기에  t를 어떻게 설정해 주느냐에 따라서, 시스템의 성능이 심하게 변할 수 있는 단점이 있고, 최악의 경우에  t="일정계획 작성기간" 이라면 기존의 일정계획과 똑같아지게 된다. 그렇지만 MPECS에서는 기존 일정계획의 단점을 보완하기 위해 생산현장의 현재 상태에 관한 정보를 더 많이 반영할 수 있는 구조를 제시하고 있어서 보다 발전된 일정계획 구조라고 할 수 있다. 이와같은 점을 극복하기 위해 Cho와 Wysk는 (Cho 1992) simulator의 예측능력을 향상시켜주는 신경망 모형을 채택하였다. 그러나, 기본적으로 이 모형도 MPECS의 또다른 변형으로서  t의 영향을 심하게 받는 것으로 드러났다 (Cho 1992). 이와 같은 이유는 생산현장의 현재 상태에 대한 정확한 정보를 적시에 사용하지 못하기 때문인 것으로 여겨진다. MODERATO 시스템에서는 OA의 설계에서 현재 shop의 정보를 충분히 반영하기 위해 상황에 따라 dispatching rule을 수시로 바꿀 수 있도록 하였으며, MPECS에서 일정시간간격  t마다 dispatching rule을 자동적으로 바꿀어 주던 것과는 달리 OA에서 dispatching rule을 바꾸어 줄 때는 앞에 정의한 job의 CR과 3.2.2절에 나오는 기계 복잡도를 그 기준으로 사용하였다. 주문의 관점에서 납기를 지킬 수 있는지 여부와, 자원의 관점에서 가동률과 현장의 부하상태를 on-line으로 감시할 수 있기 때문에, 이 정보로부터 OA는 dispatching rule을 바꾸어 줄것인가의 여부를 스스로 판단할 수 있다. 따라서 OA는 adaptive dispatcher로서 작동하고 있다. 뿐만아니라, 공장내의 이상현상이나 시스템 정지상태의 발생이 예상되는 경우 등 정상적인 상태를 벗어나는 경우에는 그 영향력을 흡수하는 능력을 가졌다. Event처리기와 part/resource 제어 처리모듈에서 그와 같은 일을 수행하며, 이 모든 상황을 종합하여 최종적인 전략은 dispatching 전문가 시스템에서 내리게 된다. 결국 dispatching rule을 바꿔 줄 때에는 job에 대한 criticality, OA의 목적함수, 기계선호도, 기계 및 자원의 복잡도(4.5절 참고)의 4가지 요소가 조합을 이루며 그 결정이 이루어진다. 이 방법은 생산계획 일정 담당자의 문제 해결방법과 매우 유사한 것이다. OA는 전체 시스템의 협상시에 task announcement의 수행, bid의 선택, 긴급주문이 들어왔을 때의 interrupt 처리 등을 수행하며, 작업 중심의 일정계획(job-based approach)을 전개하고 있다. OA의 의사결정과정을 [그림 4.4.2]에 흐름도로 표시하였다. 흐름도상의 각 모듈의 기능은 다음과 같다. 

① job_selection( ) : Intelligent dispatcher의 일부로서, 목적함수, FMS layout 형태, routing의 복잡도, 생산현장의 부하정도 등을 고려하여 어떤 작업을 처리할지를 결정하는 함수다. 
② criticality( ) : CFA에서 읽어들인 SSV를 참고하여 각 작업에 대한 criticality를 계산하며, 이 결과로부터 각 작업에 대한 목적함수를 교환해줄 것인지 여부를 판단하는 함수다.
③ change_obj_fn( ) : critical하다고 판단된 작업에 대하여, 적절한 목적함수를 선택해 주는 함수다.
④ MSG_evaluation( ) : Message Handler로서, 현재 다루고 있는 메시지의 종류를 판단하고, 각 메시지별로 추가의 action을 지정해 주는 함수다.
⑤ resource_sel( ) : 주어진 작업을 처리할 기계나 자원을 최종적으로 선택하는 함수으로서, CFA의 SSV와 입력자료상의 대체공정 등을 참고한다.
⑥ rush_order( ) : Interrupt Signal이 오면 긴급주문에 대한 처리를 수행하여, 작업선택 목록의 맨 앞에 끼어 들도록 만들어 주는 함수다.
⑦ MSG_generation( ) : 메시지 종류 별로, 그 내용 및 발생순서별 일련번호를 자동으로 발생시키는 함수다.
⑧ MSG_sending( ) : 발생된 메시지를 다른 agent로 전송하는 함수다.
⑨ abort( ) : 시스템 운용상의 오류나 기타 이유로, 이미 발생시켰던 message를 취소하고자 하는 경우에 사용하는 함수다.

[그림 4.4.2] Order agent의 흐름도
4.4.1 Order Agent 구현을 위한 지식획득

Order agent의 한 모듈인 intelligent dispatcher의 구성을 위해 본 논문에서는 1차적으로 simulation을 이용하여 fact base를 구축하고, 2차적으로 factbase를 이용하여 meta rule을 유도하고 knowledge base를 구축 하였다. 기존의 전문가 시스템이 가지고 있는 지식들의 한계를 극복하기 위해, 본 논문의 진행에서는 simulation을 위한 실험계획 단계에서 세심한 주의를 기울였다. 기존에 발표된 실험결과 및 rule들은 대부분 특정상황에서의 실험결과이기 때문에, 그 결과를 일반화 시키는 데는 많은 논리적 비약과 오류가 뒤따른다.
Montazeri와 Wassenhove(Montazeri 1990), 안재경(Ahn 1991), Blackstone, Phillips, Hogg(Blackstone 1982) 그리고 Denzler와 Boe (Denzler 1987) 등은 FMS의 일정 계획에 대한 자세한 simulation 결과를 발표하였다. 특히 안재경의 연구는 동적인 상황에서의 결과를 포함하고 있어서 가장 앞서간 연구로 여겨진다. 그러나 여기에서도 FMS의 형태, 즉 Layout에 따른 효과나, 생산현장의 혼잡도, 특정 규칙의 사용 도중 성능이 나빠질 경우에 대한 대책 등이 미비되어 있다. 본 논문에서는 아래와 같은 실험계획에 의거하여 정밀한 실험을 실시함으로써 보다 adaptive한 지식을 획득하도록 하였다.  실험은 결과의 유의성을 높이기 위하여 예비실험과 본실험으로 나누어 진행하였으며 각각 약 20,000회 이상의 simulation을 실시하였다. 본 실험에서는 Montazeri와 Wassenhove(Montazeri 1990)가 유의깊게 선별한 20개의 dispatching rule을 사용하였다(표 4.4.2 참고). 특별히 관심을 둔 부분은 공정의 갯수에 따른 영향과, FMS형태에 따른 영향 그리고 생산현장의 혼잡도 등 이었다. 이것을 알아보기 위하여 생산현장의 부하를 기계가동율을 기준으로 하여 높을 때, 중간일 때, 낮을 때 등의 3단계로 구분하였고, 한 제품의 생산에 필요한 공정수가 적을 때, 보통일 때, 그리고 많을 때로 나누었으며, 각 경우의 공정 갯수는 평등분포(uniform distribution)를 이용하여 발생시켰다(Baker 1984). 또 FMS layout에 따른 결과를 알아보기 위해, material handling system의 운영 방식에 따라 FMS를 직선형, 순환형으로 분류하여 제품의 공정을 적용시켰다. 직선형 FMS란 AGV의 이동경로가 직선으로 구성되어 있어서 서로 교차되는 경우가 없는 형태를 말하며, 순환형 FMS란 AGV의 이동경로가 폐쇄還 형태를 이루는 시스템을 말한다. 시스템 성능 평가기준은 예비실험을 거쳐 유의하다고 판단된 것 중에서, 순서에 따라 Maximize throughput, Minimize # of tardy jobs, Minimize tardiness, Minimize flowtime,  Maximize AGV utilization의 5가지를 선정하였다.

[표 4.4.2] 실험에 사용된 20개의 dispatching rule


20개의 dispatching rule이 각 각의 성능평가 척도(performance measure)에 대하여 얼마나 좋은 결과를 보이고 있는지를 [표 4.4.3]부터 [표 4.4.7]까지에 정리하였다. 표에 나와 있는 값들은 각 실험조건의 조합에 의한 simulation 수행에서, 가장 좋은 성능을 보인 횟수를 의마한다. 예를 들어 [표4.4.3]을 보자. 직선형 FMS를 운용하기 위해서 생산량 최대화를 목적함수로 두었을 때, 생산현장의 부하가 높을 때는 SMT rule이 총 15회의 실험중에서 3회에 걸쳐 가장 좋은 성능을 보였으며, 반대로 생산현장의 부하가 낮을 때는 SPT, SLACK/RO, SSLACK rule 이 각각 2회씩 가장 좋은 성능을 나타내었다. 또 생산현장의 부하를 생각하지 않는 경우에는,  3가지 생산현장 부하 상태에 대한 결과를 합계한 값으로 성능평가 척도를 삼을 수 있다. 

[표 4.4.3] Throughput에 대한 dispatching rule의 기여도





[표 4.4.4] Mean flow time에 대한 dispatching rule의 기여도





[표 4.4.5] Number of tardy jobs에 대한 dispatching rule의 기여도





[표 4.4.6] Mean tardiness에 대한 dispatching rule의 기여도





[표 4.4.7] AGV utilization에 대한 dispatching rule의 기여도


4.5 The Resource Agent(RA)

RA는 각 자원마다 하나씩 존재하며, 각 자원의 의사결정자(decision maker) 역할을 한다. 각 자원은 초기 투자비용, 자원의 수명, 자원의 운영방침, 고객의 중요도 등에서 모두 다른 가치를 가지고 있기 때문에 이것을 모두 하나의 척도로 환산하여, 각 RA마다 독자적인 목적함수를 가질 수 있으나 본 연구에서는 모든 RA가 똑같은 목적함수를 가지고 있는 것으로 가정하였다. 그러나 추후에는 서로 다른 목적함수를 가지는 구조가 되도록 개선해야 할 것이다. RA에서는 OA가 보내온 task announcement vector(TAV)를 검토, 평가하여 bids를 보내는 역할을 한다. OA에서 TAV를 보낼 때는 대체공정을 고려한 audience restriction에 의하여, 가공이 가능한 모든 기계에 보내기 때문에 TAV를 받은 각 자원은 모두 bid를 낼 수 있다. 

[그림 4.5.1] Resource agent의 상세 구조도

RA에서 발생하는 메시지의 종류는 표 4.5.1과 같다.

[표 4.5.1] RA에서 발생하는 메시지의 종류

복수의 bid들은 OA와 RA사이에 협상에 의해 조정되며, 각 RA끼리는 재협상을 할수있는 새로운 구조와 알고리즘을 제시하였다. RA사이의 재협상 여부를 판정하기 위한 기준으로는, 자원의 복잡도(congestion level)를 정의하여 사용하였다. Resource Congestion이란 특정 작업 A가 어떤 기계에 할당되었을 때, 만약 기계 유휴시간이 전혀 없다는 전제하에, 그 기계에 할당된 작업을 모두 처리한다고 할지라도 작업 A를 납기안에 마칠 수가 없는 경우에 그 기계는 복잡한 상태에 있다고 한다. 먼저 각 자원 i에 대하여
                         n
                OQTi =    tj
                         j=1 
      (단, j는 자원 i의 queue에서 대기하고 있는 작업)

를 정의하자.  OQTi란 자원 i 에서 대기하고 있는 작업들의 가공시간을 모두 합한 것이다(이때 queue란 물리적인 것이 아니고, 자원 i 에 할당된 작업 list를 의미한다). 즉 OQTi는 기계 i 에 할당 된 작업들이 조금도 기다림없이 연속하여 가공이 이루어질 때의 가공시간의 합을 의미한다.
그러면 
               ERTi = OQTi + tk
          (단, k는 기계 i 에서 현재 가공중인 작업)

는 기계 i 가 가장 빨리 free 상태로 될 수있는 시간을 의미한다.
              EFTi = ERTi + tannc + α%
     (단, tannc는 OA에서 가공을 의뢰한 작업의 가공시간)
이 때 EFTi는, TAV에 의하여 RA에 의뢰된 작업이 기계 i 에서 가장 빨리 가공이 완료될 수 있는 시간(earliest finishing time) + 여유시간 α% 를 의미하며, 이 값을 기계복잡도 계산의 기준으로 삼았다. 즉 EFTi가 납기보다 크면 machine i가 복잡한 상태에 있다고 정의한다. 특정 작업에 대한 가공의뢰가 들어 왔을 때, 만약 어느 기계가 복잡한 상태에 있다면 그 기계는 작업을 가급적 할당하지 않고 대신 대체 공정상의 다른 기계를 이용하도록 하고있다. 그러나 모든 기계가 복잡한 상태에 있을수도 있다. 이 경우에는  α값을 줄여가며 가능한 기계를 찾아본다.
만약
               Min[EFTi]   Due_Dateannc
                 i  
   (단, Due_Dateannc는 TAV에 의해 의뢰된 작업의 납기)

이라면 어떤 자원도 주어진 기간내에 생산을 완료할 수 없게 된다. 따라서 이런 경우에는 그 중에서 가장 빨리 가공을 완료하는 것을 택할 수 밖에 없다.  이런 경우가 발생하면 재협상 과정에서 각 RA의 queue 에 있는 작업중에서 맨 마지막에 할당된 작업을 제거한다. 이와같은 개념을 이용하여 본 논문에서는 OA와 RA사이의 협상은 물론이고, RA끼리의 재협상을 지원할 수 있는 알고리즘을 제시하고자 한다. 

재협상 알고리즘은 다음과 같다.

단계1. 주어진 operation(tannc)을 처리할수 있는 대체 공정상의 모든 RA, 즉 task를 받은 모든 RA에 대하여 EFT   납기 를 만족하는 RA가 존재하는 경우에는 그 RA를 선택하고 재협상을 마친다.   그렇지 않으면 단계 2로 간다.
단계2. 단계1의 모든 RA i (i = 1, 2, … ,r)에 대하여 Wi = ERTi - tj를 계산한다.   단, tj 는 RAi 에 가장 최근에 할당된 작업의 가공시간을 의미한다.
단계3. Wi 와 tj 를 오름차순으로 정렬하여  Wi의 최소값에 해당하는 RA를 X, tj 의 최소값에 해당하는 작업을 Y 로 둔다.  
      즉, X = RA[min.Wi].   Y = operation[min.tj]
                     i                        j 

단계4. Y를 X에서 가공할 수 있다면 단계7을 수행하고, 그렇지 않으면 단계5로 간다.  단계4는 기술적 제약을 검사한다.
단계5. 단계 3의 모든 tj 에 대하여  
       Y' = operation[min.{tj}]
                        j
       단 , j   Y 를 구한다.
단계6.  Y'이 공집합이 아니면 단계4를 수행하고, 공집합이면 단계10으로 간다.
단계7.  Z = Wi(X) + ty + tmh + tannc 를 계산한다.
       단, Wi(X) 는 resource agent X 의 Wi값,  ty는 Y 의 가공시간, tmh는 자원 사이의 이동시간, 그리고 tannc는 가공이 의뢰된  작업의 가공시간을 의미한다. 이렇게 계산한 Z값이, 납기보다 크면 단계10으로 가고, 그렇지않으면 단계 8로 간다.
단계8. 두 개의 작업사이의 할당관계를 바꾼뒤에, Xj와 Y의 criticality를 계산한다. 단, Xj 는 resource agent X의 queue에 배정되었다가, 제거된 작업을 의미한다. 계산 결과 두 개의 작업중에 어느 하나라도 critical 하다면 단계9로 가고, 그렇지 않으면 두 작업의 교환을 확정하고 재협상을 마친다.
단계9.  Xj 와 Y 의 criticality의 합이 {min[EFTi]-납기} 보다 크면 단계10으로 
                                       i
       가고, 그렇지 않다면  두 작업의 교환을 인정하고 재협상을 마친다.
단계10. Min[EFTi] (단, i=1,2....r)을 만족하는 RA를 선택하고
          i
       재협상을 마친다.

예를 들어 [그림 4.5.3]을 보면, 마지막 작업이 제거된 상태의 queue들 중에서 최소의 queue 길이를 가지는 W와, 제거된 작업중에서 최소의 가공시간을 가지는 작업 Y를 고른다. Y를 queue W 뒤에 넣고 EFTi를 다시 계산하여 bid를 낸다.   
본 연구에서 제시된  분산-협조형 제어구조에서는 RA끼리 재협상을 통하여, 이미 할당된 작업을 변경할 수 있는 기능을 가지고 있기 때문에 위와 같은 경우에도 효과적으로 대처할 수 있다.  그렇지만 기계와 작업 사이의 할당관계를 바꾸어서  복잡도를 해결하였다고 하더라도 그에 따르는 역작용이 있을 수 있다. 기계 A의 queue에서 제거된 작업이, 기계 B의 queue에 들어갔을 때의 criticality 등이 오히려 커질수도 있다. 뿐만 아니라 기술적 제약, 기계의 복잡도 등도 고려해야한다.  



[그림 4.5.2] 재협상 알고리즘의 흐름도

따라서, 이와 같은 역작용을 방지할 수 있는 방안을 마련하여야 한다. [그림 4.5.2]에 제시된 재협상 알고리즘에서는 이와 같은 역작용 등을 고려하여, 부가적인 逆작용없이 순수하게 기계복잡도의 개선이 일어나는 경우(monotone improvement)만을 선택할 수 있도록 하였다.

[그림 4.5.3] 재협상에 의하여 작업할당이 바뀌는 경우

RA는 event가 생길때마다 각 자원과 생산현장의 상태변화를 SSV를 통해 CFA에 보내도록 되어있다. 본 시스템 설계시에 고려한 event는 기계나 공구의 고장, 작업완료, 작업개시, 정규보수시기, 생산 개시나 완료와는 무관하게 재협상에 의해 발생하는 queue의 길이의 변화, 기계복잡도 발생 등이다. OA가 작업을 기준으로 전개된 dispatching 결과를 보내는 반면, RA는 기계나 자원을 기준으로 전개된 bid를 발생시키고 있다. 본 시스템은 작업과 자원 양자의 관점에서 문제를 바라보고, 양자사이에 협상을 통하여 문제를 풀어나가는 구조를 취하고 있다. WINQ(work in next queue) 규칙에서는 다음 queue에 있는 작업에 있는 정보를 반영하여 결정을 내리기 때문에 좋은 결과를 제공하는 것으로 알려져있다.  마찬가지로 본 연구에서 제시한 재협상 구조는 정보의 다양한 획득으로 의사결정의 질을 향상시키는 데 기여 할 수 있다. 예를 들어 바로 다음에 납기가 촉박한 작업이 들어 오는 경우에 바로 전의 선택을 재협상을 통하여 변경시켜 줄 수 있다. 특히 작업을 기준으로 한 의사결정과 기계를 기준으로 한 의사 결정사이의 협상 및 RA사이의 재협상을 통하여 의사 결정의 수준을 향상시킬 수 있음은 매우 중요한 특징이다. 그림[4.5.1]에 RA의 의사결정과정을 흐름도로 표시하였다. 흐름도상의 각 모듈의 기능은 다음과 같다. 

① MSG_check( ) : 메시지의 존재 여부를 확인하고 그 종류를 판별하는 함수다.
② find_MSG( ) : OA로부터 긴급주문에 대한 interrupt가 와 있는지, 또는 이미 발생한 메시지에 대한 취소요청이 있는지를 찾아주는 함수이다. Interrupt가 존재한다면 ACKV 메시지를 발생시켜서 전송해주고, Abort요구가 있으면, 주어진 msg_id#에 해당하는 메시지를 삭제시킨다.
③ congest_calc( ) : 자원의 복잡도를 계산하고 earliest finishing time(EFT)을 계산하는 함수다.
④ congest_or_not( ) : 자원의 복잡도 확인 및 이에 대한 대응조치를 수행하는 함수다.
⑤ Re_Nego( ) : audience restriction에 의하여 메시지를 받은 모든 자원이 복잡한 상태인 경우, 각 자원 사이의 재협상을 시도하는 함수다.
⑥ Event( ) : 난수 또는 미리 정의된 분포를 이용하여 자원의 고장과 정기점검 시기를 발생시키는 함수다.
⑦ MSG_generation( ) : 메시지 종류 별로, 그 내용 및 발생순서 별 일련번호를 자동으로 발생시키는 함수다.
⑧ MSG_sending( ) : 발생된 메시지를 다른 agent로 전송하는 함수다.


[그림 4.5.4] Resource agent의 흐름도

4.6 The Communication Forwarding Agent(CFA)

Davis와 Smith 가 제시하였던 원래의 경매네트워크 모형(Davis 1983)은 manager node와 contractor node만이 존재하는 구조였다.  이 모형을 분산시스템의 생산현장제어에 적용하는 과정에서, 효율적인 정보처리의 필요성과 생산관리와 관련된 의사결정의 특성 등에 의하여 메시지 버퍼(message buffer) 역할을 하는 CFA를 도입하였다. 자동화된 생산현장의 경우, 각종 장비나 기계의 상태에 대한 계측 및 감지 데이타가 매우 빈번히 발생하며 이 데이타들은 시간에 따라 변화하는 특성을 가진다.  더구나 이와 같은 내용이 시스템관리역할을 하는 OA 에 전송되어야 하기 때문에 OA 와 RA 사이에  통신부하 문제가 발생할 가능성이 매우 높다고 보고되어 있다(Nof 1989 ; Weber 1989). 뿐만아니라 deep queueing 현상에 따라 정보전송자(information sender)의 대기 현상이 생길수도 있고, 지연된 반응시간 등으로 인하여 실시간 반응 필요성에 크게 위배 될 수 있으며, 경우에 따라서는 정보의 불일치 현상을 초래할 수도 있다(Weber 1989).   특히 RA 에  보내오는 정보는 짧은 시간주기로 계속 수정되는 것들이 많기 때문에, OA 내의 데이타베이스 같은 곳에 기록하고 조회/검색하기에는 시간, 비용 등의 문제가 뒤따르게 된다. 더구나 그 내용들이 굳이 데이타베이스에 오랫동안 보관되어야 되는 것들이라기 보다는 일시적인 것들이 대부분이기 때문에 이와 같은 정보를 효율적으로 처리할 수 있는 새로운 구조가 필요하게 되었고, 그 대안으로서 본 연구에서는  2층 구조 (2-layered architecture)를 가진 CFA를 제안하였다. 2층 구조를 사용하면 통신에 소요되는 시간은 OA와 CFA, 또는 RA와 CFA사이의 메시지 전송시간이 된다. 메시지의 처리는 CFA에서 전담하기 때문이다. [그림 4.6.1]에서 실선으로 표시된 a,b,e,f는 OA, RA와 CFA 사이의 메시지 교환이 실제로 발생함을 의미하며, 점선으로 표시된 c,d는 OA와 RA사이의 가상 메시지 흐름으로서 OA(또는 RA)가 CFA로 부터 받아들인 메시지로부터 어떤 결정을 내리고, RA(또는 OA)에게 action을 취함을 의미한다. 

……… : 메시지의 가상흐름  ----- : 메시지의 실제흐름 
[그림 4.6.1]  2층 구조(2-layered architecture)의 CFA 

바꾸어 말하면 상대방 agent의 메시지에 대한 처리를 의미한다. 기존의 분산 제어 방식에서는 메시지의 처리와 전송이 한데 묶여 있어서 통신에 소요되는 시간이  a+b+c+d+e+f가 되지만, 2층구조를 가진 CFA에서는 메시지의 처리를 CFA에서 전담하기 때문에 통신에 소요되는 시간은 a+b+e+f가 된다. 뿐만 아니라 OA에서는 audience  restriction을 이용하여 대체 공정 상의 가용 자원에 국한하여 task announce를 하기 때문에, 모든 자원에 task announce를 하던 기존의 방식들에 비하여 상대적으로 통신량이 줄어들게 된다. 따라서 MODERATO 시스템에서 제시한 2층구조의 CFA는 FMS의 분산 제어를 위해 필요한 효과적인 통신 agent라 할수 있다.
FMS의 생산현장제어 수행시에 고장, 자재고갈, 시스템 정지상태 등과 같이 전혀 예상하지 못했던 상황이 발생하였을 때, 이와 같은 사실을 실시간 수준에서 감지하고, 시스템에 전파하여 실시간 대책을 세우는 기능이 절실히 요구된다.  본 연구에서 제시된 CFA 구조는 그림 4.6.2와 같다.

[그림 4.6.2] Communication forwarding agent의 상세 구조도

위에 언급된 사항들을 다루기 위해서는 공장내의 최신 정보를 언제나 이용할 수 있어야 하며, 고장이나 시스템 정지상태, 자재고갈 등을 예측 및 예방할 수 있어야 한다.  CFA 에서는 이를 위하여 on-line 감시 시스템과 시스템 정지상태 관리기능(예측 및 복구), 그리고 MODERATO 시스템의 통신지원을 위한 기능들을 갖추고 있다. MODERATO 시스템이 실제 공장에 설치 될 경우 MAP의 제6계층과, 제7계층에 존재하게 된다. 따라서 두 계층간의 통신지원을 위한 MODERATO 시스템 내의 프로토콜이 설계되어야 한다. 

[그림 4.6.3] Message queue 방식의 IPC 개념도

MODERATO에서는 이 프로토콜의 설계를 위해, UNIX의 프로세스(process) 개념을 이용하였다(그림 4.6.3 참고). 왜냐하면 각 계층은 독립된 프로세스로 구성될 수 있고, 이 경우 각 프로세스 간의 통신이 곧 계층 간의 통신을 의미하므로 UNIX에서 제공하는 프로세스 간 통신지원 수단인 IPC (inter process communication)를 사용할 수 있기 때문이다. 본 논문에서는, UNIX에서 제공하는 IPC중에서 구조화된 메시지를 key에 의하여 구분하는 queue 방식인 메시지 queue 방식을 이용하였다. [그림 4.6.3]에 이 방식의 IPC 동작을 나타내었다. 메시지 queue 방식을 이용하면, CFA를 이용하여 각종 메시지들을 그 형태에 따라 구분하여 target process로 저장하고 자기에게 도착하는 메시지를 queue로 부터 읽어내게 된다. 따라서 IPC에 참여하는 process는 원하는 메시지를 queue에 보내고, 읽어내는 기능만 수행하면 되므로 매우 간단한 interface구조를 가지는 장점이 있다.  이것의 구현을 위해 UNIX의 IPC system call 중에서 msgget(), msgsnd(), msgrcv()를 사용하였으며, 이와 같은 시스템 call을 이용하여 queue에 메시지를 보내고 읽는 것과,  IPC 운영상황 감시를 위한 LOG process를 구현하였다. 

OA와 RA사이의 모든 정보교환은 CFA를 통해서 이루어진다.  예를 들어 OA가 RA에 message#3을 보내고자 하는 경우 OA는 CFA에 message#3의 내용을 보내면서 동시에 message#3을 전송했다는 ticket을 보낸다.  이 ticket에는 message전송시각, 전송번호 등과 같은 색인만을 담고 있다.  반대로 RA에서는 OA로 정보를 보내는 경우도 마찬가지다. CFA는 인공지능에서 말하는 "blackboard"의 개념과 거의 같다고 볼 수있다.  시스템내에서 event가 발생할때마다 RA는 CFA에 SSV를 보내기 때문에, CFA내에는 언제나 생산현장의 현재상태에 대한 정확한 정보가 담겨있다.  따라서 CFA를 이용하면 현장의 부하상태에 대한 정보(shop load profile)를 언제나 정확하게 파악할 수 있기 때문에, CIM과 같은 시스템의 shop control 에 아주 적합한 구조라고 할 수 있다.

CFA에서는 이와 같이 가장 최신의 정보를 유지하고 있기 때문에  이 정보를 이용하여 시스템운영효율을 향상시키는 데 기여 할 수 있다. FMS운영시에 가장 어려운 문제이면서도, 가장 다루기 힘든 문제가 바로 "system deadlock"현상이다.   이것에 관하여는 5장에서 자세하게 다루었고, 그 결과를 MODERATO 의 CFA 구조설계에 채택하였다. CFA내의 on-line 공장감시 시스템으로부터 넘겨 받은 자료를 이용하여, 시스템 정지상태 처리 모듈은 다음 단계의 공장상황을 정확하게 예측할 수 있다. 공장상황이란 각 자원의 상태 및 각종 요구상황 발생을 의미한다. 이렇게 예측된 결과로부터 시스템 정지상태가 예상되면 즉각 이것을 피해가는 방법을 제시하며, 만약 이미 시스템 정지상태가 발생되었을 경우, 이것을 해결할 수 있는 기능을 가지고 있다. 이와 같은 사항들은 절실한 요구이지만 기존의 생산현장제어 시스템들은 중앙집중형 제어에 근거하고 있기 때문에, 기능이 취약하거나 아예 다루지 못하고 있다.  본 논문에서는 시스템 정지현상을 시스템적 차원에서 파악하고 여기에 대한 수학적 모형을 개발함으로써 시스템 정지상태에 근본적으로 대처할 수 있는 방법을 제시하였다.
CFA내에 들어오는 정보는 크게 2가지로 분류되어 저장된다. 하나는 시스템 전체에 해당되는 메시지로서 현장상태보고(shop status report), 기계고장, 생산개시 및 완료 등과 같은 것들이고, 또 하나는 각 자원에 해당되는 메시지로서 기계의 상태, queue의 변화상황 및 가공대기 상태 등이 여기에 해당된다. 제안된 시스템은 CFA에는 일시적인 자료(transient data)가 임시로 저장되고, 영구보관이 필요한 자료(permanent data)나 지식등은 OA에 저장되는 구조를 지니고 있기 때문에 정보기록, 검색, 삭제, 조회 등에 의한 부하는 크게 줄어든다. 그러나, 모든 정보가 CFA를 거쳐가고, 기록, 삭제되기 때문에 CFA자체의 부하가 커져서 또다시 전송자 대기현상 등이 발생할 가능성이 존재한다. 이 문제를 피하기 위해서 각 메시지의 전송시에는 메시지 고유식별자(message identifier)를 표시하는 방법을 택하고 고장, 긴급주문과 같은 일이 생길 때는 직접 access를 허용하도록 함으로써, deep queueing에 따른 문제의 발생 가능성 배제와 실시간 응답이 가능하도록 2층 구조의 CFA를 제시하였다. CFA의 운용방식을 [그림 4.6.4]에 흐름도로 표시하였다. 각 모듈의 기능은 다음과 같다. 
① PN_model( ) : Petri net model generator 및 editor
② RM_gene( ) : reachable marking generator
③ Blocking( ) : blocking tester
④ D_L_Prev( ) : deadlock prevention 함수
⑤ D_L_Recov( ) : deadlock recovery 함수
⑥ D_L_Control( ) : RA에서 query를 받아들여, 이 query의 수행으로 인한 system의 deadlock을 예방 및 해결하는 함수

[그림 4.6.4] Communication forwarding agent의 흐름도

4.7 MODERATO 시스템의 운용방식 및 특징

MODERATO 시스템의 운용방식은 다음과 같다. OA와 RA 사이의 협상시작은, 처리해야 할 작업을 OA가 선언함으로써 이루어진다. OA에서 task announcement vector(TAV)를 선언할때는 다음과 같은 내용이 CFA에 보내어지고, RA에는 메시지 id# 만이 보내진다. 이때 audience restriction에 의하여 대체공정상 가능한 RA에게만 보내지게 된다. 이것은 분산제어시의 통신부하를 줄이기 위해 도입된 것이다. TAV를 받은 RA는 OA에 bidding vector(BV)를 보낸다.   이때 각 RA 는 자기자신의 능력과 현재 queue의 상태, 그리고 TAV에 의하여 선언된 job의 특성등을 고려하여 작업완료 예상시간을 계산해 낸다.  

TAV : message id #, part #, operation #,
       (Routing (machine, processing time),
                (machine, processing time),
                          ●
                          ●
                          ●
              (machine, processing time),
       start time, finish time, least finish time

이론적으로 볼때 모든 RA는 서로 다른 목적함수에 의하여 TAV를 평가하고 BV를 내는 것이 타당하다. 왜냐하면 각 자원마다, 초기 투자 비용이 다를뿐만 아니라, 기업내의 운용방침, 기계성능, 주문 받은 제품의 중요성등이 모두 다를 것이기 때문이다. 그러나, 본 연구에서는 편의상 모든 RA가 똑같은 목적함수를 갖는 것으로 가정하였다.

BV의 내용은 다음과 같다.
BV : message id #, message id # for TAV, resource #
     earliest start time, expected finish time
RA는 event가 일어날 때마다 수시로 CFA에 SSV를 보내어 shop의 현재상태를 가장 최근의 것으로 수정해 주도록 되어 있다.

SSV의 내용은 다음과 같다.
SSV : resource #, resource status(가동/대기/고장), loaded part #
      loading time, expected release time, # of jobs in queue

SSV에는 메시지 id #가 없다. 왜냐하면 SSV는 항상 최신의 정보로 수정되어야 하므로 과거의 상태에 대한 데이타는 의미가 없기 때문이다. 즉, 현재 순간의 정보만이 의미가 있는 내용이기 때문이다.
SSV와 더불어 CFA에서는 현재 queue내에서 가공대기 상태인 job에 관한 내용을 저장하고 있어서 queue의 내용 및 상태를 다음과 같이 파악해 볼 수 있다.

Resource # {(part #, queue에 들어올 시간, expected start time)
            (processing time, due date, ................)
                            ●
                            ●
                            ●                                 }
Resource # {(part #, queue에 들어올 시간, expected start time)
            (processing time, due date, ................)
                             ●
                             ●
                             ●                                 }
    ●

이외에도 CFA내에는 처리가 끝난 메시지들을 삭제하고 생산종료 및 시스템 기록 유지의 기능을 가진 몇가지 함수들이 존재한다.
기존의 일정계획들은 대부분이 가공시간의 관점에서만 그 평가기준을 파악하여 왔다. 그러나 생산시스템이 자동화되어 가고 정보화가 추진되어감에 따라 초기투자 비용이 커져서, 비용의 문제도 함께 고려되는 것이 바람직한 것으로 여겨진다. 그런 면에서 파악해 본다면 본 연구에서 제안한 분산-협조형 생산현장제어 구조는 더욱 타당성을 지닌다고 볼 수 있다.
예를 들어 그림 4.7.1의 경우를 보자.

[그림 4.7.1] 재협상 예제

부품 1은 기계 A와 B에서의 가공비용이 같다. 기계 A에서는 시간 t1에 다음 공정을 시작할 수 있고 이때 치구 및 고정구 등을 교환해야 하며, 기계 B에서는 t2에 다음 공정을 시작할 수 있고 치구 및 고정구 교환은 없어도 된다고 하자. 이 경우에 기존의 일정계획 방법에 의하면 부품 1은 당연히 기계 A에서 t1에 다음 가공이 시작된다. 이때 소요비용은 가동 준비비용과 기계 A에서의 가공비용이다. 그러나 t2까지 기다렸다가 기계 B에서 가동을 하는 경우에는 가동준비 비용이 발생하지 않는다. 대신 기계 A에 대하여 시간 t1에서 t2사이 만큼의 idle time cost가 발생하게 된다. 만약 이 비용이 가동준비 비용보다 작다면, 시간 t2까지 기다렸다가 기계 B에서 부품 1을 가공함이 더 타당할 것이다. 본 연구에서 제안한 분산-협조형 생산현장제어 구조에서는 RA와 OA의 협상 및 RA끼리의 재협상 과정에서 이와 같은 문제를 반영하고 있기 때문에 유연한 생산현장제어 구조를 갖추고 있다.

     MODERATO 시스템은 그 구조의 설계시에, MAP과의 관계성을 고려하였기 때문에 몇가지 특성을 가지고 있다. 주어진 실세계를 모형화하여 그 모형을 구현시킬때, 보통 정형화된 모형화 방법론을 사용한다. 특히, 수학적모형에 기반을 둔 경영과학(OR/MS)모형의 경우는 더욱 그렇다. 자동화된 공장을 효율적으로 운영하기 위한 지금까지의 많은 연구들이 경영과학 모형을 중심으로 진행되어왔다. 그러나, 동적이고, 분산형 구조를 가지며 예측하기도 힘든 여러가지 상황을 포함하는 생산현장제어에는 이와 같은 방법들이 그 한계를 드러내고 있으며, 특히 현장에 설치되기 위한 소프트웨어 모듈로 구현되는 경우에는 소프트웨어 공학적인 새로운 모형이 더욱 필요하게 되었다. MODERATO 시스템은 바로 이와 같은 문제점을 해결하기 위해 분산시스템 모형화및 소프트웨어 구현을 위한 통신네트워크 개념의 지원과 이를 위한 프로토콜의 내부 탑재 등 보다 정형화된 모형화 방법론을 채택함으로써, FMS의 분산 제어를 위한 모형-이론적인 틀(model-theoretic framework)을 제시하고 있다. 특히 2층 구조의 제어 시스템을 갖도록 함으로써, OA, RA 와 CFA가 서로 상대 agent에게는 숨겨져 있는 것과 같이 되기 때문에, 제어 논리의 단순화와  시스템의 확장성이 크게 향상되는 장점이 있다. 또한 설계된 시스템을 실행설계로 전환하여 실제로 공장에 설치할 경우에도 구조의 수정이나 추가의 프로토콜 설계 없이도 단지 실행 매개변수 값들에 대한 설정만으로도 MAP환경의 제 6계층및 제 7계층에 곧바로 이식(porting)이 가능한 구조로 되어 있다.

5. FMS의 정지상태 처리

5.1 확률적 Petri net을 이용한 FMS 모형화

확률적 Petri net을 이용한 FMS 모형화 및 성능분석은 강력한 수학적 뒷받침 아래 동시성(concurrency), 무작위성(randomness), 동기화(synchronization) 등을 다룰 수 있다. 또한 그래프 이론과 Markov chain에 의하여 지원되는 분석방법은 확률적 Petri net을 on-line제어 시스템 개발에 응용하는 데 좋은 이론적 토대를 제공해주고 있다.  시스템 성능 및 상태, 장래상황 등에 대한 예측능력이 확률적 Petri net 모형을 통하여 크게 향상될 수 있고, 이 결과가 on-line으로 시스템 제어에 응용될 수 있는 가능성은 앞으로의 생산현장 제어시스템 개발과 FMS 운용 소프트웨어 개발에 많은 기여를 할 것으로 기대된다.

확률적 Petri net를 이용하여 FMS를 모형화하기 위하여 다음과 같이 6가지의 모형화 요소(modeling construct)를 정의하자.

① 순서 요소(sequence construct)

[그림 5.1.1] Sequence construct
그림에서 보듯이 P1이라는 상태가 되어야만이 t1이 실행가능하고 t1의 실행결과 P2가 됨을 알 수 있다. 순서 요소는 공정의 선행관계나, 어떤 사건의 인과관계를 표시하는 데 사용한다.
② 동기화 요소(synchronization construct)

[그림 5.1.2] Synchronizaion construct

t1은 P2의 token이 도착할 때야 비로소 'enabled' 상태가 된다. 즉, P1과 P2가 모두 만족되어야만 t1이 실행가능하다. 즉, t1은 P1과 P2를 시간상 일치시켜주는 역할을 한다. 동기화 요소는 부품의 조립관계를 표현하거나 part sequencing 등을 나타내는데 쓰인다.

③ 결합 요소(merging construct)

[그림 5.1.3] Merging construct

결합요소는 어떤 transition이 일어나느냐와 무관하게, 한 곳으로 모이는 경우를 표현한다. 결합요소는 FMS의 storage buffer나 AS/RS 등을 표현하는 데 쓰인다.
④ 선택 요소(confliction construct)

[그림 5.1.4] Confliction construct

선택요소는 어떤 상태에서 다음에 발생가능한 사건이 여러가지 있을때 사용하며, 경우에 따라서는 발생확률이 주어지기도 한다. FMS의 경우 dispatching rule의 선택 등에 사용된다.

⑤ 동시성 요소(concurrency construct)

[그림 5.1.5] Concurrency construct
P1,P2,P3에 모두 Token이 존재하는 구조. 즉, t1, t2, t3는 동시에 발생하는 transition이다. 동시성 요소는 FMS 모형화에서 중요한 역할을 하며 주로 대체공정의 표현 등에 사용된다.

⑥ 우선순위 요소(priority construct)

[그림 5.1.6] Priority construct

P2는 t2에 대한 inhibitor place가 된다. 따라서 t2는 위 그림의 P2에 token이 없을 때만 'enabled' 상태가 된다. 우선순위 요소는 우선순위 표현이나 zero testing 등에 사용된다. FMS에서는 기술적 선택사항이나 선호도, 자원의 선점(preemption) 등을 모형화할 때 사용한다.

본 논문에서는 이상의 6가지 모형화 요소를 사용하여 FMS를 모형화 하였다. 대상 FMS의 buffer는 pallet stand 형태이고 pallet은 central storage에 저장되며 용량은 제한되어 있다. Loading/Unloading station은 일반적인 형태로서 아무 part나 사용할 수 있고 refixturing등에도 사용된다. Fixture와 pallet은 분리가 가능한 mount/dismount 형태이며, part를 분리하고자 하는 경우 pallet에서 fixture에 고정된 part 뭉치를 먼저 분리한 다음, 다시 fixture를 제거하는 방식을 사용한다. Fixture의 저장은 Loading/Unloading station을 이용하고, 공정순서는 한 part 당 여러개의 공정이 존재하며 한 part 당 fixture는 1개만 사용하는 경우를 대상으로 한다(그림 5.1.7). 단, 각 공정 사이에는 반드시 central storage에서 대기하도록 가정한다. [표 5.1.1], [표 5.1.2], [표 5.1.3]에서 component란 가공을 위해 FMS에 투입된 원자재를 의미하며, part란 component와 pallet이 결합된 상태를 의미한다. 또한, 시스템의 정지현상을 허용하며, 정지현상 발생시에는 Loading/Unloading station을 임시 queue로 이용하여 정지현상의 해결 및 회복(resolution and recovery)을 수행하도록 하였다. 가공을 위해 FMS에 투입된 원자재나 가공을 마친 부품은 AS/RS에 저장한다.
[그림 5.1.7] 제한된 Central Storage 용량을 가진 FMS모형

[표 5.1.1]  [그림 5.1.7]에 대한 Place와 Transition (Machine Buffer Model)


FMS의 shop floor control을 수행하기 위하여 갖추어야 하는 중요한 기능 중의 하나가 system deadlock 처리이다. Deadlock이란 시스템 구성요소간의 요구사항 충돌(cyclic requirement)에 의한 시스템의 정지현상을 말한다. 예를 들어 그림 6.4.1.1을 보자. 

[그림 6.4.1.1] System deadlock

A의 가공이 완료되면 B에게 AGV를 보낼 수 있고, B가 A에게 AGV를 이용해 부품을 보내주어야 A의 가공이 완료된다고 가정해보자. 이런 상황에서 A는 B에서 부품을 받을 수 없고 따라서 가공이 완료되지 못하므로 AGV를 보내줄 수가 없게 된다. B는 AGV를 이용할 수 없게 되어서 A에 부품을 보낼 수 없는 상태가 되었다. 결국 시스템은 전혀 가동이 될수 없는 상태로 전이되었고 이 상태를 deadlock이라 한다. 

Viswanadham과 Narahari(Viswanadham,1990)는 deadlock을 다음과 같이 4종류로 구분하였다.

(1) 하나의 시스템 자원을 2개 이상의 프로세서가 동시에 사용할 수 없다. (Mutual Exclusion)
(2) 사용중인 자원은 현재의 프로세스가 끝나기 전에는 release될 수 없다. (No Preemption)
(3) 어떤 자원을 사용중이면서, 동시에 다른 프로세서가 사용중인 자원을 필요로 하는 프로세서가 존재한다. (Hold and Wait)
(4) 순환형 대기현상, 즉 A는 B를, B는 C를, C는 A를 기다리는 현상을 보이는, 프로세서가 존재한다. (Circular Wait)

이 구분을 따른다면, deadlock이 없다는 것은, 위 4가지 상황에 해당하는 일이 발생하지 않음을 의미한다. 따라서, Petri Net 모형을 이용했을 때에는 다음과 같이 deadlock을 정의할 수 있다. 

정의 1 : Deadlock
  Petri Net으로 모형화된 FMS의 경우, 현재의 marking에서 
  enabled transition이 없을 때를 의미한다.

   Deadlock Controller

6.3절에서 GSPN을 이용하여 FMS를 모형화하고 그 수행도를 분석하는 방법을 소개하였다. GSPN 모형은, 원래 Petri Net의 성질에 의하여 그래프 이론적인(Graph-theoretic) 특징을 그대로 간직하고 있다. 그래프 이론은 그 수학적 성질이 그 동안 많이 연구되어 왔을 뿐만 아니라 응용분야도 다양해졌다. 본 논문에서는 GSPN 모형의 그래프적 성질을 이용하여 FMS의 운용시에 발생가능한 deadlock 문제를 해결하기 위한 방법을 제시하였다. GSPN 모형으로부터 reachability graph를 형성하는 경우를 생각해보자. Reachability Graph란 현재의 marking에서 enabled transition을 실행시켰을 때 얻어지는 새로운 marking을 표현한 것이다.
[그림 6.4.2.1]의 (a)를 보자. 현재 marking Mi에서 ti를 실행시키면 시스템은 Mi+1상태를 거쳐서 다른 상태로 전이한다. 그러나 tj를 실행시키는 경우에는 Mi+2상태가 되어 더 이상 취할 생각이 없이 시스템은 Mi+2상태에 계속 머무르게 된다. 즉, Mi+2는 deadlock을 나타내는 marking이다. (b)의 경우도 마찬가지다. 

      (a)                                          (b)

[그림 6.4.2.1] Reachability graph로 본 간단한 deadlock

Mi에서 tj나 tk중 어느 것을 실행하여도 시스템은 작동하지만, 그 다음 단계에서는 어느 것을 실행시켜도 시스템은 Mi+3상태에서 빠져 나오지 못하게 되어 deadlock 상태가 된다. GSPN 모형으로부터 reachable marking을 계속 찾아가는 과정에 의하여 형성된 Reachability Graph는 이처럼 시스템 deadlock 현상에 대한 가시적이고 예측가능한 결과를 제공하는 훌륭한 성질을 보이고 있다. 그림 6.4.2.2에서, 그림 6.4.2.1  (b)의 경우에 대한 확장을 보자.
[그림 6.4.2.2]는 그림 6.4.2.1과는 약간 다른 구조를 보여주고 있다. 만약 현재의 marking이 Mi라면, 여기에서 몇번의 transition을 수행하더라도, 시스템이 deadlock이 되는 것을 전혀 알 수 없다. 그러나 일단 Mi 상태에서 ti를 실행시키기만 하면, 그 이후에는 어떤 경우에도 궁극적으로는 deadlock 상태로 전이하도록 되어있다. 

[그림 6.4.2.2] Reachability graph로 본 복잡한 deadlock

즉, 그림 6.4.2.1 (b)의 경우와 그림 6.4.2.2에서 Mi 상태가 외형상으로는 다른 구조이지만 결국은 똑같은 behavior를 나타낸다는 것을 발견할 수 있다. 이와같은 현상은 reachability graph의 node 갯수때문에 생기는 것으로 여겨진다. 

정의 2 : 상태공간(state space) S
 주어진 GSPN의 상태공간S는, GSPN에 대한 reachability graph 
       G=(V,E)의 모든 노드들의 집합이다. 
 S = { Mi | Mi   G, G = (V,E), Mi   V, (Mi,Mj)   E }

즉, GSPN의 상태공간이란, 초기 marking M0로부터 유도된 모든 reachable marking들의 집합을 의미한다. 

정의 3 : boundedness
       GSPN의 임의의 place Pi에 대하여 
          , 단, Z+는 양의 정수
      를 만족하면, 주어진 GSPN은 bounded이다.

정리 1 : 주어진 GSPN은 그 상태공간 S가 유한집합일때만 'bounded'이다.
(증명) ( ) 임의의 GSPN P가 n개의 place로 이루어져 있고, 
           상태공간 S가
           P = { P1, ...., Pn }, 단, n은 양의 정수.
           S = { S1, ...., Sn },  단, s는 양의 정수.
           n과 s가 정수이므로,  ---------- ①
          ①식을 만족하는 양의 정수 Z+ 가 존재한다.
          S가 유한하므로, ①식은 n개의 place로서 만들어낼 수 있는
          reachable marking에 대한 경우의 수를 의미한다.
         그런데, (Z+ + 1)n = (Z+ + 1)。(Z+ + 1)。。。(Z+ + 1) ---②
         와 같이 (Z+ + 1)의 (n + 1)번 곱으로 나타낼 수 있다. 
         S가 유한하므로, ①식은 n개의 place로서 만들어낼 수 있는 
         reachable marking에 대한 경우의 수를 의미한다. 즉, 각 place의 
         marking은 아무리 커도 0,1,...(Z+ - 1),Z+의 (Z+ + 1)가지를 넘지
         못하게 된다.
         이것은 를 의미한다. 
         따라서, P의 상태공간 S가 유한집합이면, P는 bounded GSPN.
     ( ) GSPN P가 P = { P1, ...., Pn }이고 bounded라 하자. 
         P가 bounded이므로, 인 양의 
         정수 Z+가 존재한다. 따라서, 어떤 reachable marking에서나, 
         각 place의 marking은 기껏해야 0,1,2,...,Z+가 된다. 그러므로, 
         reachable marking의 최대갯수는 (Z+ + 1)n이 된다. 
         Z+, n이 정수이므로 (Z+ + 1)n도 유한한 정수이다.
         즉, P가 bounded GSPN이면, 상테공간 S는 유한 집합.(증명끝)
                                                       
정리1이 의미하는 바는 다음과 같다. 주어진 FMS를 모형화해서 얻은 GSPN P가 bounded이면, 유한상태공간을 얻기ㄸ문에 시스템이 가질수 있는 상황이 유한함(즉, 경우의 수를 예측할 수 있음)을 의미한다. 바꾸어 말하면 각종 resource에 대한 필요량이 유한량을 의미하고 이것은 곧 deadlock에 대한 정확한 예측의 기초자료를 제공함을 의미한다. 또한, 상태공간이 유한하므로 실제 FMS에서는 buffer의 overflow방지등을 모형화하는데 쓰일수 있다. 따라서 GSPN이 bounded이면 인 임의의 Mi로부터, 상태공간 S내에 있는 모든 Mj에 "reachable"하게 된다.

정의 4 : Deadlock Prevention
 Reachability graph에서, 모든 i, j에 대하여 Mj는  deadlock 상태
       이고,일때  Mi → Mj 를 나타내는
       (Mi,Mj)   E를 reachability graph에서 삭제하는 것을 말한다.
  
즉, 시스템이 deadlock현상을 유발할 수 있는 상황에 대한 정보를 모두 가지고 있어서, 시스템을 deadlock으로 유도하는 transition을 피해가는 경우를 deadlock prevention이라 한다. Deadlock prevention 상태에서는 어떠한 경우에도 시스템 deadlock이 없다.

정의 5 : Deadlock Avoidance
 제한된 정보를 이용하여, 시스템 deadlock을 예방하는 행위로서,
 local deadlock prevention 과정이다. 

Deadlock Avoidance는 제한된 정보를 이용하기 때문에, 궁극적으로는 deadlock 발생가능성을 배제할 수는 없다.

정의 6 : Deadlock Recovery
 Reachability graph에서, 모든 i, j에 대하여 Mj는  deadlock 상태
       일 때, (Mj,Mk)   E인 tk를 인위적으로 첨가하는 것을 말한다. 

다시 말하면, 시스템의 deadlock이 예상되거나 deadlock이 이미 발생했을 때, 이 상태를 해결하는 것을 deadlock recovery라 한다.
                                                           tj
이때 tk는 여러개의 transition으로 이루어질 수도 있으며 Mi ----> Mj도 여러번의 transition에 의하여 "reachable"한 경우도 존재한다.

정리 2 : GSPN의 상태공간이 유한하면, Deadlock Prevention이 가능하다. 
(증명) GSPN P = { P1, ...., Pn }의 상태공간 S가 유한하다면, S = {M1,....,Ms}가 유한집합이다. 만약, M1을 초기상태의 marking이라 가정한다면, M1으로 유도가능한 reachable marking에 대한 reachability graph를 형성할 수 있다. S가 유한하므로 reachability graph는 'finite tree'가 된다. 따라서, tree상의 leaf node에 있는 모든 marking에 대하여 enabled transition의 有無를 조사함으로써 deadlock을 판단할 수 있다. 따라서, S가 유한하다면, deadlock상태의 marking을 찾아낼 수 있기 때문에, 정의4에 의하여 deadlock prevention이 가능하다.

보조정리 1 : GSPN이 bounded이면, Deadlock Prevention이 가능하다. 
(증명) 정리1과 정리2로부터 자명함.

정의 7 : N-visible
 Reachability graph에서, 모든 i, j에 대하여 현재 Mi 상태에서,         
 (Mi,Mi+1)   E, (Mi+1,Mi+2)   E,..........,(Mi+n-1,Mi+n)   E 이면
       marking Mi일때 주어진 GSPN은 N-visible (단, N은 양의 정수). 

결국 GSPN 모형이 N-visible 하다는 것은, 현재상태에서 n번의 transition후에 도달 가능한 (N-step ahead transition) marking을 미리 알수 있다는 의미이다.

정리 3 : Reachability graph의 상태공간에 대한 Cardinality가 m일때, 
        GSPN이 m-visible이면, GSPN에 의해 모형화 된 시스템은
        deadlock prevention이 가능하다(단, m은 양의 정수).
(증명)  GSPN의 Place와 상태공간이 P = { P1, ...., Pn }와 S = { M1, ...., Ms }, (단, n과 s는 양의 정수)일 때,  GSPN이 m-visible이므로, 현재 marking이 Mi라면,
            (Mi,Mi+1)   E, (Mi+1,Mi+2)   E,..........,(Mi+m-1,Mi+m)   E
      인, m개의 호(arc)가 존재한다. 이것은 m번의 transition후에, Mi를 root node로 하여, leaf node까지의 깊이가 m인 finite tree를 형성할 수 있다는 말이 된다. 즉, tree상의 모든 node에 대하여 m번의 transition이내에 모두 도달할 수 있다. 또, m이 양의 정수이므로, n개의 place에 대하여 을 만족하는 정수 Z+가 존재한다. 정의3에 의하여 P는 bounded GSPN이 된다. 따라서, 정리 2와 정의3에 의하여 deadlock prevention이 가능하다.(증명끝)

보조정리 2 : Reachability graph의 상태공간에 대한 Cardinality가 m일때,
            GSPN이 k-visible이면, GSPN에 의해 모형화 된 시스템은,
            현재시점에서 적어도 k번의 transition 동안은 deadlock이 
            발생하지 않는다. (단, 0 < k < m)
(증명) 정리 3의 증명으로보터, GSPN P가 k-visible이면, P는 깊이가 k인 finite tree를 형성한다.  그런데 k < m 이므로, k번의 transition이내에 모든 marking을 방문할 수 없다. 따라서, k번만에 도달가능한 marking들 만으로 깊이가 k인 finite tree를 형성한다. 그러므로, 현재의 marking으로부터 적어도 k번 안에 있는 tree만을 생각한다면, 정리 3에 의하여 deadlock prevention이 가능하다.

정의 8 : blocked state(정체상태) 
 초기 marking이 M0인 Petri Net C=(P.T.I.O)에서 다음조건을 
 만족하는 reachability marking M은 정체상태에 있다고 말한다.
 조건 : 임의의 transition ti가 ①,②,③을 만족한다. 
  ① #(pi,I(ti))   2
  ② ①에 속하는 어떤 p에 대하여, μ(p)   arc(p→ti)
  ③ ti는 M에서 "enabled" 상태가 아니다.

그림으로 설명하면,
[그림 6.4.2.3] 시스템 정체상태를 나타내는 Petri Net 모형
과 같다.

어떤 marking M에서 시스템이 정체상태에 있다는 것은 그 marking을 벗어나기가 매우 어렵다는 것을 의미하고, 이것은 system deadlock이 발생할 가능성이 높아졌음을 의미한다. 

이 개념은 교차로에서의 교통량 변화를 보고 교통정체 및 마비현상을 예측하는 것과 똑같은 개념이다. 교통량 변화가 어떤 기준을 넘기거나 추세를 보일 때, 적절한 교통통제를 실시하는 것과 마찬가지로 시스템이 정체상태에 들어가면 deadlock 예방을 위한 조치들을 취하게 된다. 
이때 M = (0102)이며 P = p4가 되고, p1과 p3에 token이 없기 때문에 ti는 "enabled"가 아니다. 바꾸어 말하면 ti는 p1과 p3를 기다리고 있는 입장이고, p4는 처리해야 할 일들이 몰려 들어서 빨리 ti를 실행시키고자 하는 입장이지만 ti가 "enabled"가 아니기 때문에 기다릴 수 밖에 없어서, 현재의 marking M = (0102)에서는 시스템이 정체상태로 전이하게 된다. 

[그림 6.4.2.3]은 Synchronization Construct로서, 이것은 주로 조립공정의 표현에 많이 사용된다. 위에 언급한 정체 현상이 실제로 현장의 조립공장에서 자주 발생하고 생산량에 큰 영향을 미치고 있음이 보고되었다(정한일,1991). 따라서 이와같은 문제를 예측할 능력이 있는 GSPN 모형의 사용을 고려함이 타당하다고 여겨진다. 

정의 9 : n-reachable marking An
 An = {M,S,M',St}
 단, M은 현재의 marking
 M'은 M으로부터 n번의 transition에 의해 유도된
             reachable marking
 S는 transition sequence
 St는 marking M'의 상태, St = { deadlock, blocked, normal }

예를 들어
[그림 6.4.2.4] n-reachable marking

[그림 6.4.2.4] 에서
A1 = {M1,t1,M2,Normal}
A1 = {(M2,t2,M3,Blocked), (M2,t3,M4,Blocked)}
A1 = {M4,t5,M5,Deadlock} 
이 된다.

A3 = {(M1,(t1,t2,t4),M5,Deadlock),(M1,(t1,t3,t5),M5,Deadlock}
이다.
[그림 6.4.2.5] On-line deadlock control system

A1은 1번의 transition으로 도달할 수 있는 reachable marking의 상태를 나타낸다. A3는 3번의 transition을 거치면 어떤 경로를 따라가든 deadlock이 됨을 의미한다. 결국 n-reachable marking이란 n번의 transition후의 시스템 상태를 의미한다.

이상에서 나타낸 정의와 정리들을 이용하여 본 논문에서는 그림 6.4.2.5와 같은 on-line deadlock 제어시스템을 제안하였다. 제안된 시스템은 GSPN모형이 제공하는 우수한 수학적 성질을 이용하여 deadlock을 예상하고 대처하는 능력을 가지고 있다. 
Deadlock recovery는 FMS의 Loading/Unloading station을 임시저장장소로 활용하여 시스템의 상태를 바꿔줌으로써, 새로운 reachable marking을 얻을 수있는 방법을 사용하였다.  여기에 대한 알고리즘은 다음과 같다.

 Deadlock_Control Algorithm

단계 0  RA로부터 Query Q를 받아들이고, 
        CFA에서 현재의 Marking Mc를 확인한다.
단계 1  Mc의 enabled transition ti를 모두 찾는다.
       이고,  이면, 
       단계 2로 가고, 아니면 단계 0으로가서 다른 Query를 읽는다.
단계 2  Q를 실행시켜서, 새로운 marking MN을 얻는다.
단계 3  MN이 deadlock이면 
        apply Deadlock_Recovery algorithm
        아니면 단계 4로 간다.
단계 4  MN의 enabled transition tj를 모두 찾는다. 
        모든 tj에 대하여, 2-reachable marking MT를 구한다.
단계 5  MT가 deadlock이면
        apply Deadlock_Prevention algorithm 
        아니면 단계 6으로 간다.
단계 6  Query Q를 실행한다.

 Deadlock-Recovery algorithm

단계 1 Loading/Unloading station에 여유가 있다면 단계 6으로
       아니면 단계 2로 간다.
단계 2 Loading/Unloading에서 empty pallet을 기다리는 부품들이 
       있거나, Tray를 기다리는 부품 및 완성품이 있으면 단계3으로
       아니면 단계 7로 간다.
단계 3 Loading/Unloading에 Empty tray 있다면 단계 5
       아니면 단계 4로 간다.
단계 4 Empty tray를 이용하여 부품을 AS/RS → Loading/Unloading로   
       이송한다.
단계 5 Tray를 이용하여 부품을 Loading/Unloading → AS/RS로 옮긴다.
단계 6 Loading/Unloading의 한 곳을 임시 Queue로 선언하고 
       시스템 운영을 계속한다.
단계 7  Re-initializatize FMS

 Deadlock_Prevention Algorithm
 
 For  (현재 노드 MN에 대한 부모노드 MP에 대하여)
      If (MN , MP) ∈ E  
               then MP의 모든 노드에 대한 arc를 삭제
                   exit;
     else N←L 
        recursively apply Deadlock-Prevention Algorithm ;

 이 알고리즘에서는 Deadlock prevention을 유도하는 모든 arc를 삭제하여 Deadlock_prevention_list에 그 정보를 보관하고 있다가 Deadlock Control Algorithm이 수행될 때마다, 그 정보를 전달함으로써, 사전에 Deadlock을 차단하는 역할을 하고 있다.

6. 실험 및 성능 비교

6.1 실험환경 

분산-협조형 제어 구조가 생산현장의 제어에 적합한가를 검증하고 그 성능을 평가하기 위하여, 본 논문에서는 실제로 운용되고 있는  FMS를 대상으로 하여 MODERATO 시스템을 적용하였다. 대상 FMS로는 서울대학교 자동화시스템 공동연구소(Automation and Systems Research Institute)에 설치되어 운용 중인 SNU/FMS를 선정하였으며, 비교 대상 모형으로는 입찰 네트워크(contract net)에 기반을 둔 Shaw의 분산 제어 모형(Shaw 1989)을 선택 하였다. 실험에서는 IBM-PC 486/DX (운영체제 : MS-DOS 6.0)에서 C언어를 이용하여 SNU/FMS에 대한 컴퓨터 모형을 개발하고, 개발된 모형에 Shaw의 모형과 MODERATO 시스템을 각각 적용하여 두 시스템 사이의 성능을 비교/분석 하였다. 

SNU/FMS는 [그림 7.1]과 같은 배치로 구성되어 있으며 모든 설비 사이에 통신망이 구축되어 있고 통신 protocol로서는 Ethernet/TCP/IP를 사용하고 있다. SNU/FMS는 Machining cell, Assembly cell, Inspection cell, MHS, AS/RS, Set-up station (Loading/Unloading station), 그리고 FMS control room으로 이루어져 있다.

Machining cell은 수평형 machining center, CNC선반, 물류처리를 위한 6축 로보트로 구성되며, cell제어는 IBM-PC/286에 의하여 이루어진다. 
Assembly cell은 4축 로보트  2대, 6축 로보트 1대, 그리고 컨베이어, cell 제어용 IBM-PC/286으로 구성되어 있다. 
Inspection cell은 2축  로보트, 2대의 vision 카메라, 화상정보 처리장치, 그리고 cell 제어용 SUN SPARC workstation으로 구성되어 있다. 
MHS : 물류처리를 위해 AGV를 사용하고 있으며, AGV의 가반중량은 350Kg이고, 공장바닥내에 설치된  유도선에 의하여 운용되는 것과  센서에 의하여

[그림 6.1] SNU/FMS Layout     

유도되는  무궤도 방식 등 2가지가 사용되고  있다. Cell제어용 컴퓨터는 IBM PS/55이다.
AS/RS : AS/RS rack과 stacker crane으로 구성되며,  제어용 컴퓨터는 IBM 7541이 사용된다.
Set-up station :  Loading/Unloading station이며, 작업자가 pallet에  치구 및 소재를 설치하고, 완성품이나 조립품의 탈착 및 세척작업을  수행하는 곳이며 제어용 컴퓨터로는 IBM-PC/286을 사용한다.
FMS control room : 중앙제어실  역할을 하며 host computer로서 HP9000/433 workstation을 사용하고, host에 탑재된 DBMS로서 INGRES를 사용하고 있다.    
이외에 로보트로 구성된 용접 cell이 있으며 assembly cell에는 computer vision 시스템이 도입되어  있다. SNU/FMS에서는 현재 3가지 종류의 모터를 생산하고 있고 각 모터는 6개의 부품으로 이루어져 있다. 6개의 부품 중 shaft  cap, bearing, bolt는 외주 제작하며, SNU/FMS에서는 shaft, end cap, case 등의 3가지 부품을 가공한다. 

6.2 영향변수 설정

일반적인 생산계획 절차에 의하면, 대일정계획 (master production schedule)에 의하여 생성된 계획은 週 단위의 생산에 관한 자료다. 이 자료는 다시 생산현장에 생산지시로 전해지게 된다. 총괄 생산계획과 같은 장기계획은 부품의 종류가 많고 적음에 따라 많은 영향을 받는다. 그러나 한 週 간의 생산계획에 관한 주문들은 중복이 가능한 부품들로 구성될 수 있기 때문에, 부품의 종류가 많고 적음은 생산현장제어 시스템의 성능에 크게 영향을 주지 않을 것으로 판단된다. 뿐만 아니라 생산현장제어라는 일 자체가, 생산 현장의 현재 상황에 크게 영향을 받기 때문에, 부품종류의 많고 적음보다는, 공정의 복잡도나 가공시간 또는 납기할당 방법 등에 더욱 민감한 영향을 받을 것으로 판단된다. 이와 같은 이유로 본 논문에서는 생산현장제어 시스템의 성능에 영향을 줄 수 있는 변수로, 성능 평가의 기준이 되는 목적함수의 형태, 공정의 복잡도, 그리고 각 주문에 할당된 납기 등을 설정하였다. 대일정계획에서 수립된 생산계획에 의하여 생산이 이루어지고 있다는 전제 하에서는 생산량과 납기가 주어지기 때문에, 납기를 준수하는 것과 계획했던 전체 부품을 최단시간에 생산하는 것이 중요한 관심사가 된다. 따라서 본 실험에서는 성능 평가를 위한 목적함수로서 number of tardy job, total tardiness, makespan time 등을 채택하였다. MODERATO 시스템에서 채택하고 있는 지능형 dispatcher, deadlock controller, 기계 및 각종 자원 사이의 재협상 등의 방법이 실제로 생산현장제어 시스템의 성능 향상에 기여를 하고 있는지 알아보기 위하여 공정의 복잡도를 고려하였다. 공정의 복잡도란, 공정갯수에 따라서 공정이 간단한 것부터 복잡한 것까지를 4종류로 나눈 것으로서, 이렇게 분류한 자료를 생산에 투입하여 생산현장의 복잡도를 변화시켜 가며,  Shaw의 모형과 MODERATO 시스템 사이의 성능을 비교 분석하였다. 또한 on-line 제어에 기반을 두고 있는 MODERATO 시스템의 robustness를 알아보기 위하여, 생산현장이 아주 복잡하거나 납기가 변할 때 어떻게 반응하는지를 알아 보았다. 이를 위하여 가공시간을 기준으로 하여 할당된 납기를 변화시켜가며 MODERATO 시스템의 성능을 추적해 보았다.

6.3 입력자료 발생

Shaw의 모형과 MODERATO 시스템의 성능을 비교하기 위해서, 실험에 사용된 부품에 관한 자료는 크게 4가지이다. Data  set I은 SNU/FMS에서 생산하고 있는 모터에 대한 실제 자료이며, data set II, III, IV는 난수(random number)를  이용하여 무작위로 발생시킨 자료다. 
난수를 이용하여 data set을 발생시킨다는 것은 결국 공정과 가공시간을 발생시키는 것이다. 6.2절에서 밝힌 바와 같이 각 부품에 대한 주문은 이산형 평등분포(discrete uniform distribution)를 이용하여, 공정의 갯수가 5개인 것, 10개인 것, 15개인 것, 그리고 20개 이상인 것 등 4종류로 나누어서 발생시켰다. 각 주문에 대한 공정의 발생은 U(1,20)를 이용하여 발생된 난수를 균등하게 4가지로 나누어서 실시하였다. 발생된 난수가 1-5사이에 속하면 공정의 갯수를 5개로, 6-10사이에 속하면 공정의 갯수를 10개로, 11-15사이에 속하면 공정의 갯수를 15개로, 16-20사이에 속하면 공정의 갯수를 20개로 하였고, 이 때 각각의 공정순서는 U(1,6)을 이용하여 정해 주었는 데, 1부터 6까지의 각 수에 SNU/FMS의 각 기계나 Cell을 한 가지씩 대응시켜 두었다. 각 공정 별 가공 시간은 2단계의 절차를 거쳐 발생 시켰다. 먼저 연속형 평등분포(continuous uniform distribution)를 이용하여 각 주문별 평균 가공시간  를 발생시키고, 발생된 평균 가공시간  와 삼각분포(triangular distribution)를 이용하여 각 공정 별 가공시간을 발생시켰다. 실험에 사용된 평균 가공시간  는 U(100,200)을 이용하여 발생시켰고, 최종 가공시간은 Trangular(0.75 , ,1.25 )로 부터 발생시켰다. 또한 각 기계나 cell간의 이동에 소요되는 시간은 U(110,140)의 분포로부터 발생시켰다. 가공시간 및 이동시간 발생의 단위로는 초(second)를 사용하였다. 
</tdmsfiletext>
