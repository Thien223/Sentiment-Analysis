<language> Korean </language>
<textcode> KSC-5601-1988 </textcode>
<process> raw </process>
<version> 2001(or)</version>
<filename> kaistcorpus_written_raw_or_academic_paper96_ted.txt </filename>
<title> 내부점 선형계획법의 자료 구조 개선과 수행도  향상에 관한 연구(A study on data structure   design  and   performance improvement   for   innterior  point   linear programming methods) </title>
<author> 이시우 </author>
<date> 1992</date>
<publisher> 서울대학교 </publisher>
<kdc> TM530.96 </kdc>
<tdmsfiletext>
 초   록
  선형계획문제 해법 중의 하나인 내부점 선형계획법에는 많은 변형기법들이 있다.  본 연구에서는 이러한 다양한 기법들을 통합할 수 있는 프로그램 LPKAB을 개발하였다.  본 논문은 내부점 선형계획법의 수학적인 특징과 연산 원칙을 고려하여 적절한 자료 구조를 설계하고 여러 내부점 선형계획 변형 기법들이 공통적으로 사용할 수 있는 모듈화를 꾀하였다.  본 논문의 내용은 이 프로그램을 개발하는데 고려된 사항과 개발 단계에서 발생한 문제점을 실험하고 개선 방향을 제시하였다.

  내부점 선형계획법 중에서 projective algorithm과 affine scaling algorithm을 통합한 LPKAB을 이용한 실험에서 dual affine scaling algorithm이 가장 우수한 성능을 보였다.  그리고 수행도를 개선하기 위해 선형 방정식을 푸는데 Gaussian elimination과 Choleski factorization을 이용하였는데 Choleski factorization 기법이 Gaussian elimination보다 수행 속도 면에서 크게 우수하고 수치적 안정성을 가지는 것으로 나타났다.

중심어 : 내부점 선형계획법, 자료 구조, 모듈화, Choleski 
         factorization, ill-conditioning
제 0 장. 서론  
 0.1 선형계획문제와 접근방법 
 선형계획법(Linear Programming)은 경영과학 분야에서 가장 널리 사용되고 있는 모형 중의 하나이다.  이것은 모형 수립이 명료하고 해법이 잘 개발되어 있을 뿐만 아니라, 대단히 많은 변수를 가진 방대한 현실 문제도 쉽게 다룰 수 있기 때문에 시스템의 기획 및 설계분야, 경영관리 및 운영분야, 공학분야의 최적화 문제, 그 밖의 환경과 지역개발 문제 등, 다방면에 걸쳐서 넓게 이용되고 있다.[박순달, 1991]
선형계획문제는 다음과 같은 형태로 표현될 수 있다.




선형계획법에 관한 관심은 이론적인 면과 실용적인 면이 있다고 볼 수 있다.  1940년대 후반, G.B. Dantzig가 개발한 단체법(simplex method)은 최악의 경우 지수시간의 복잡도를 가진다고 개발 초기부터 알려져 있다.  그러나, 실제적으로는 문제의 크기에 따라 선형적인 횟수의 반복만에 문제를 풀 수가 있다.  단체법에 관련된 선형대수학적 작업은 보통 기저(basis)에 대한 희소행렬(sparse matrix)의 LU factorization과 관련되어 있다.  각 반복마다 두 번의 선형시스템 연산과 기저 요소에 대한 update(즉, 열 대체)가 일어나게 된다.  이 factorization은 계속 update되기 보다는 수치적 안정성(numerical stability)과 비영요소(fill-in)의 증가를 막기 위해 주기적으로 다시 계산되어야 한다.  선형계획문제는 일반적으로 그 크기가 매우 클 뿐만 아니라 제약 계수행렬은 매우 희소도가 높다.  희소행렬기법은 factorization과 update가 필요한 단체법에서 신속하게 처리될 뿐만 아니라 수치적인 안정성까지도 확보해 준다.[Gill et al, 1984]  좋지 못한 복잡도에도 불구하고도, 실용적인 관점에서 보면 선형적인 반복횟수와 한 반복에 대한 빠른 수행방법이 단체법을 선형계획문제에 대한 효율적이고 신뢰성 있는 알고리즘으로 자리잡게 했다.
Dantzig 자신은 물론 많은 사람들이 단체법은 가해영역(feasible region)의 모서리를 따라 이동하는 바람직하지 못한 특징을 알고 있었기 때문에 가해영역의 내부를 가로지르는 실용적인 해법을 찾기 위해서 많은 시도 - Neumann[1947], Hoffman et al.[1953], Tompkins[1955,1957], Frisch[1957] - 가 있었다.  이러한 기법들은 비선형기법을 선형계획문제에 적용해 보려는 시도였다.  그러나, 이들 기법들 중에 어느 것도 일반 선형계획문제에 대해 단체법보다 속도면에서 뛰어나다고 주장되지 못하였다.
이론적인 면에서 고찰해 보면 많은 사람들이 다항식 계산 복잡도를 가지는 선형계획법을 개발하려고 했다.  1979년에 최초로 Khachiyan[1979]에 의해 타원체의 수축을 이용하여 비선형 기하에 기반을 둔 다항식 복잡도의 해법이 개발되었다.  초기에는 이 타원체법(ellipsoid method)이 실용적으로도 단체법만큼 빠를 것으로 기대되었지만 너무 많은 반복횟수와 희소행렬기법이 적용될 수 없는 관계로 한 반복 당 요구되는 계산량이 너무 커서 이런 기대는 충족될 수 없었다.
선형계획법에 대한 많은 관심은 1984년에 이르러서야 Karmarkar[1984a,b]에 의해 결실을 맺게 되었고 다항식 계산 복잡도를 가질 뿐만 아니라 실제적인 문제에 있어서도 단체법보다 훨씬 빠르다고 주장되고 있는 내부점 선형계획법들이 논의되기 시작하였다.

0.2 연구의 목적 및 필요성 
이 논문은 Karmarkar(1984)가 제안한 선형계획법 알고리즘에 기반을 둔 여러 내부점 선형계획법 알고리즘에 관한 것이다.  
지금까지는 각 해법의 이론적인 접근을 통하여 계산 복잡도를 향상시키려는 노력이 많았으나 실용적인 면에서 전산기를 이용한 수행에 관한 연구는 단지 단체법과의 수행속도 비교에 그친 경우가 대부분이었다.  여기서 전산기에서의 수행도(performance)란 최소의 자원으로 최대의 문제를 최단의 시간에 풀 수 있는 능력으로 정의하고자 한다.  여기서 자원이라고 함은 전산기의 CPU 사용시간이나 메모리의 소요량으로 볼 수 있다.  이론적인 계산 복잡도가 아무리 좋다고 하더라도 적절한 자료 구조와 알고리즘을 채택하지 못한 프로그램은 실용도면에서 좋은 특성을 가진다고 말할 수 없다.  
따라서 실용적인 측면을 고려하면 이들 선형계획법에 적합한 프로그램이 개발되어야 하는데 컴퓨터의 용량이 제한되어 있으므로 적은 용량 내에서 보다 큰 문제를 풀 수 있어야 한다.  일반 선형계획 문제들은 행렬계수의 희소도가 매우 높기 때문에 모든 행렬 요소를 보관하는, 적절치 못한 자료구조를 채용한 프로그램은 컴퓨터의 용량에 크게 제한받게 되서 그 효용성이 크게 떨어진다고 하겠다.  이에 내부점 기법에 적절하면서 비영 요소만을 보관하는 자료 구조가 개발된다면 수행능력이 용량면에서나 속도 면에서 우수할 뿐 아니라 수치적인 안정성도 확보할 수 있는 잇점이 있을 것으로 사료된다.  그러므로, 이와 같은 내부점 선형계획법에 적합한 자료 구조를 제시하고 그 자료 구조에 알맞는 구현방법에 관한 연구가 꼭 필요하다고 볼 수 있다.  
그리고 알고리즘의 효율적 구현을 위해서는 중복된 계산이 수행되지 않도록 체계적으로 연산 단계에 대해 분석하고 적절한 모듈화를 지향함으로써 여러 분야에 대한 연구가 수행됨에 따라 쉽게 수행해 볼 수 있는 프로그램의 구현이 필수적으로 요구된다 하겠다.
Karmarkar[1984]가 projective algorithm을 발표한 이래 이와 유사한 많은 내부점 기법들이 발표되었다.  그리고 최근에 들어서 이들 기법들을 이론적으로 통합해 보려는 시도 - Vial[1989], Shanno와 Bagchi[1990] - 가 일어나고 있다.  이와 마찬가지로 이론적으로 통합이 가능하다면 실제적인 수행측면에서도 통합이 가능하리라고 생각될 수 있다.  지금까지는 각 기법들을 실행시키기 위해 각각의 프로그램들이 개발되었지만 본 연구는 이들 각 기법들이 공통적으로 사용할 수 있는 자료 구조 설계와 모듈화를 수행함으로써 각 기법들을 통합할 것이다.
본 연구에서는 다항식 시간의 계산 복잡도를 가지는 내부점 선형계획법에 공통적으로 이용될 수 있는 적절한 자료 구조를 설계하고 효율적인 수행을 위한 체계적인 모듈화를 수행하는데 그 목적이 있다.  이와 같은 연구가 아직 부족함으로 인해서 본 연구의 수행절차는 다른 기법에 관한 자료 구조와 모듈화에 대한 모델로서 사용될 수 있으므로 교육적인 역할도 담당할 수 있을 것으로 기대된다.

 0.3 논문의 구성 
제 1 장에서는 본 논문과 관련된 이론적 배경을 다루는데 그동안 내부점 선형계획법이 어떤 방향으로 연구되어 왔고 본 연구의 입지를 알아보기 위한 방향으로 서술되어 있고 아울러 자료 구조의 개념과 Choleski factorization의 의미, 기존의 수행 결과들에 대한 고찰로 이루어져 있다.  제 2 장에서는 좋은 자료 구조의 의미를 정의하고 내부점 선형계획법에 적절한 자료 구조를 설계 제시한다.  제 3 장에서는 통합 내부점 선형계획법 프로그램인 LPKAB의 모듈화 스키임에 대해서 다루고 제 4 장에서는 수행도 개선에 관한 연구의 일환으로 Choleski factorization 방법과 내부점 선형계획법과의 관련성 및 수행도에 관해서 다룰 것이다.  제 5 장에서는 본 논문의 실험에 사용된 문제들에 대한 것과 내부점 선형계획법 수행 상의 문제점 및 각 기법들의 우열 비교를 할 것이다.  끝으로 결론에서는 앞으로 계속 수행되어야 할 연구 방향을 제시하였다.

제 1 장. 이론적 배경 
 1.1 내부점 선형계획법 
Karmarkar의 논문 이후에 많은 내부점 선형계획법들이 제안되었다.  이들 기법들이 어느 정도 유사하고 어느 정도 차이가 있는지는 명백하지 않다.  Megiddo[1986]는 다양한 알고리즘들 간의 차이를 설명할 수 있는 이론이 필요하다고 말했다.  이와 같은 노력은 최근에 들어서 여러 사람-Vial[1989], Shanno와 Bagchi[1990]-에 의해 시도되고 있다.
내부점 선형계획법은 다음과 같이 분류될 수 있다.

   projective algorithm
   affine scaling algorithm
   path following algorithm

위의 내부점 선형계획법들은 다항식 계산 복잡도를 가진다.  첫번째 기법은 회의 반복 횟수가 필요하고 적절한 근사 스키임을 사용하면 한 반복당 회의 연산이 필요하다.  세번째 기법은 회의 반복 횟수가 필요하고 특별한 근사 스키임을 사용하면 한 반복당 회의 연산이 필요하다.  하지만 두번째 기법은 다항식 계산 복잡도를 가질지 알려져 있지는 않지만 N. Megiddo와 M. Shub[1986]의 연구 결과에 의하면 다항식 계산 복잡도를 가지지 못할 수도 있다고 한다.  여기서 더이상 복잡도 문제는 논의하지 않기로 하고 본 논문에서는 첫번째와 두번째 기법만을 고찰하기로 한다.  

Karmarkar가 선형계획문제에 맞는 projective algorithm을 제안한 이후로 수행상의 문제와 계산학적 효율에 대한 관심이 일어나기 시작하였다.  이러한 노력의 대부분은 새로운 알고리즘이 대형 선형계획문제를 단체법보다 50배나 빠르게 풀 수 있다는 Karmarkar의 결과를 되풀이해 보기 위한 시도였다.
Karmarkar 알고리즘은 가해영역의 내부를 가로지르는 개선 방향을 찾는 내부점 선형계획법이다.  대조적으로 단체법은 한 정점에서 인접한 다른 정점으로 가해영역의 모서리를 최적점이 발견될 때까지 이동하는 방법이다.  대형문제에 대해서 단체법은 많은 정점들을 열거할 필요가 있다.  그래서 가해영역의 내부를 통하여 이동할 수 있는 개선 방향을 찾는다면 상당한 계산량의 절약을 기대할 수 있다.  그러나, Karmarkar 알고리즘의 각 반복은 많은 계산량을 요구하는 사영(projection) 과정이 필요하게 되고 이것은 많은 사람들의 연구 대상이 되었다.
Tomlin[1987]은 수정된 QR 알고리즘과 Givens rotation을 이용하여 사영 단계의 효율을 높였지만 계산 시간을 단체법과 비교해 볼 때 상당히 느린 것으로 보고하였다.  Todd와 Burrel[1986]은 대형 희소문제에 대해서 비슷한 알고리즘을 수행하고 각 반복마다 그리 많은 부담을 하지 않고도 정점해를 구하는 방법에 대해서 논의하였다.
Shanno와 Marstern[1986]은 가해성을 유지하는데 어려움이 있다는 사실을 보고하고 근사 사영(inexact projection) 알고리즘은 물론 사영 알고리즘에 reduced gradient를 이용한 방법을 수행하였다.  이들 알고리즘은 제한적이나마 성공적이었으나 단체법과 비교해 보려는 시도는 없었다.
Cavalier와 Soyster[1986]는 사영 변환을 사용하지 않고 선형 변환을 사용하는 Karmarkar 알고리즘의 변형을 연구하였다.  그들도 점점 ill-conditioning되는 것과 가해성을 유지하는데 문제가 있는 것으로 보고되었다.  Vanderbei[1986]도 동일한 변형을 제안하였는데 그는 알고리즘의 수렴성을 증명하고 밀도가 높은 작은 문제에 대해서 단체법과 비교될 만한 수행결과를 얻었다.  Kortanek과 Shi[1987]과 Sherali[1987]도 여러 가정하에서 이들 변형 알고리즘의 수렴성을 증명하였다.
Lustig[1985]는 사영 단계를 계산할 때 Paige와 Saunders[1982]의 반복 알고리즘 LSQR을 이용하여 수행하였다.  수행결과는 MINOS보다 훨씬 느린 것으로 보고되었다.
근사 사영 방법은 네트워크 유통 문제에 대해 기본적인 수행 결과를 제공한 Pickel[1985a,b]에 의해서 연구되었다.  Dennis[1987]는 사영행렬을 근사시키기 위해 표준 variable-metric 기법을 이용한 변형을 제시하였다.  이 기법에 의하면 필요한 matrix factorization의 수를 줄일 수 있다고 했다.  Karmarkar 알고리즘에 대한 전반적인 고찰은 Hooker[1986]에 의해서 제공되었다.

Karmarkar 알고리즘은 가해영역이 단체를 이루는 homogeneous한 선형제약식들만으로 이루어진, 특별한 형태의 선형계획문제를 다룬다.  이러한 형태에서 가해영역이 단체 위에 있어야 한다는 조건은 normalization constraint로 해석될 수 있고 가능해 공간을 사영 공간으로 볼 수 있다.  Karmarkar는 첫째, 단체의 내부에 있는 가능해 하나를 알아야 하고 둘째, 문제의 최적값을 알고 있어야 한다는 가정을 하였다.  그리고 사영 변환을 도입하여 변환공간에서 개선 방향을 정의하였다.  이 개선 방향의 역변환은 각 반복마다 고정된 값의 개선을 보장하는 의미에서 효율적인 개선방향으로 나타났다.
이와 같은 문제 형태와 가정은 지나치진 않지만 자연스러운 것은 아니었다.  이 부문에 대한 초기의 많은 연구는 좀더 표준적인 형태로 알고리즘을 변형시키기 위한 것이었다.  de Ghellinck과 Vial[1987]과 Gonzaga[1989]는 normalization constraint가 단체일 필요는 없다는 것을 보여 주었다.  사영공간으로 만들기 위해서 새로운 변수를 도입하면 표준 형태가 사용될 수 있다.  최적값에 대한 가정은 Todd와 Burrel[1986]에 의해서 처음으로 완화되었고 그 다음에 de Ghellinck과 Vial[1986]에 의해 연구되었다.  내부 가능해에 대한 가정은 인공변수를 이용하여 처리될 수 있었다.(대수법과 제 2 국면법)  de Ghellinck과 Vial[1986]은 가해문제와 최적문제를 동시에 해결할 수 있는 combined phase I-phase II 기법을 제안하였다.  원래 기법의 특성은 선형의 목적식에 따라 단조적이지 못할 수도 있다는 사실이었다.  Anstreicher[1986]와 de Ghellinck과 Vial[1986]은 단조성을 보장하는 변형 알고리즘을 제안하였다.  Gay[1987]와 Yamashita[1986]는 쌍대문제의 사영 알고리즘을 제안하였다.
이들 모든 알고리즘들은 사영공간에서 개선한다는 공통점을 가지고 있다.  이것들은 사영 변환의 개념에 기반을 둔 것이기 때문에 "projective algorithm"이라는 이름이 붙었다.
사영공간에서 개선하는 것은 직관적이지가 못하다.  Dikin[1967]은 원래의 애핀 공간에서 개선되는 알고리즘을 제안하였다.  이것은 나중에 Vanderbei et al[1985]과 Barnes[1986]에 의해서 재발견되었다.  이 기법은 이들에 의해 affine scaling 기법으로 명명되었다.  이 방법은 단순해서 수행되기가 쉽다.  Mitchell과 Todd[1986]는 사영 알고리즘에서의 개선 방향이 애핀 공간에서 어떤 유사점을 가지는지 보였다.  이 유사점은 애핀 개선 방향과는 다른 "centering direction"이라고 명명된 방향과 관련되어 있다.  이들의 연구에 의하면 projective algorithm과 affine scaling algorithm은 동일한 것이 아니라고 한다.  Gill et al[1986]은 logarithmic barrier function을 이용하여 표준 barrier penalty 기법을 적용하였다.  이 기법도 affine scaling과 centering direction에 관련되어 있지만 다른 방법으로 결합되어 있다.

 1.2 Projective Algorithm 
사영 변환의 중요한 성질 중의 하나는 polytope 내부의 한 점을 polytope의 중앙으로 옮길 수 있다는 것이다.  Projective Algorithm의 발상은 아주 이해하기가 쉽다.  Polytope의 내부에 한 점을 잡고 polytope의 중앙으로 그 점을 옮기기 위해서 해공간을 변환한 다음, steepest descent 방향으로 이동을 한다.  여기서 이 점이 내부에 있음을 유지하기 위하여 항상 가해영역의 모서리로 이동하는 것은 아니다. 변환공간의 이 점을 다시 원공간으로 변환하여 새로운 해를 구한다.  이런 과정을 최적해가 찾아질 때까지 반복한다.
Karmarkar 알고리즘을 적용하기 위해서는 우선 두가지 조건이 만족해야 한다: i) "homogeneous" 형태이어야 하고 ii) 목적함수값이 0인 최소값을 가져야 한다.  주어진 임의의 문제를 주어진 형태로 바꾸는 것은 어렵지 않지만 후자의 조건을 충족시키는 것은 쉽지 않다.
Karmarkar의 논문을 잘 이해할 필요가 있지만 여기서는 다음과 같이 간단한 윤곽만을 제시한다.
Karmarkar 알고리즘을 적용하기 위해서는 주어진 문제를 다음과 같은 특수한 형태로 변환해야 한다.



여기서 는 m x n 행렬, 벡터 는 모든 원소가 1인 열벡터이고, 연산자 는 전치연산자를 의미한다.  【 표   】의 목적함수 값이 0 이고 모든 원소가 양의 값을 가지는 초기 내부 가능해 가 존재한다고 가정했을 때 다음과 같은 사영변환을 사용한다.

  (역변환 : ) (1)    

여기서 인 대각 행렬이다.  이것은 단체  = {  }를 단체  = {  }위로 일대일 대응시키는 방법으로 인 점을 의 중심인 으로 매핑시킨다.  이런 변환 아래서 【 표   】는 다음과 같은 형태로 변환된다.



이 사영 공간에서 단체 에 내접하는 구의 반경의 0.25만큼을 개선폭으로 잡아 【 표   】에서 주어진 등식들의 영공간 위로 【 표   】의 그래디언트 벡터 를 사영시켜 구한 normalized direction으로 이동한다.  그 후에 이 점은 (1) 의 역변환을 통하여 다시  공간으로 변환되고 이 과정은 적당한 수렴값까지 계속된다.  이러한 반복이 【 표 1 】의 목적함수의 감소를 가져올 필요는 없다하더라도 특별하게 정의된 포텐셜 함수의 일정치만큼씩 감소를 가져온다는 것이 증명되었다.  이를 이용하여 Karmarkar는 다항식 시간 안에 그의 알고리즘이 끝날 수 있음을 증명하였다.  여기서 0.25라는 개선폭은 다항식 시간 수렴을 증명하기 위한 것-Lawler[1985]이지 실제로는 (0,1) 구간의 더 큰 값들도 어느정도, 즉 문제에 따라, 다항식 시간 수렴을 보장할 것이다.  더우기 수행도 측면에서는 모든 변수의 가해성(양수 조건)을 유지하는 한도 내에서 가능한한 큰 개선폭을 선택하는 것이 좋은 것으로 발견되었다. - Tomlin[1987], Nichels et sl[1985]  이것은 내접구의 표면 밖으로도 개선폭을 잡을 수 있도록 한다.  이와 같은 예는 【 그림 1 】에서 보이는 것과 같다.



여기서 우리가 다시 생각해 볼 문제는 목적함수값 의 최소값이 0 이라는 가정인데 이 가정은 일반적으로 받아들여 질 수가 없다.  Karmarkar는 처음에 sliding object function 방법을 사용하였는데 이것은 다항식 복잡도의 증명을 위한 것으로 실제로 사용하기에는 부적합한 것이었다.  그는 나중에 원/쌍대 가해성 문제를 풂으로써 선형계획문제를 풀 수 있는 방법을 제안하였으나 이 방법은 문제의 크기를 4 배 정도 크게 만드는 3단점이 있었다.  그리고 그는 "2 차원 검색(two dimensional search)"방법을 암시하기도 했다.-Karmarkar[1985]
여기서 우리는 Todd와 Burrel[1986]에 의해서 고안된 방법을 선택했다.  이 방법은 문제를 확장시키지도 않고 구현하기도 쉬우며 쌍대문제의 최적값도 구할 수 있다는 잇점이 있다.  Anstreicher[1986]도 근본적으로는 다르지만 이와 비슷한 방법을 연구하였다.
Todd-Burrel 방법은 기본적으로 다음과 같이 운용된다.  【 표 2 】의 형태로 문제가 주어지고 그 목적함수값은 라고 하자.  만약 우리가  값을 알기만 하면 목적함수값을 0 이 되도록 하기 위해 으로 두면 된다.  사실 이기 때문에  이라는 것을 알 수 있다.  【 표 2 】의 를 로 두면 Karmarkar의 방법대로 풀 수 있다.
우리는값을 모르기 때문에 Todd와 Burrel은 의 추정치 를 사용하여 계속 수정해 나가도록 하였다.  각 반복에 있어서 우리는 【 표 2 】의 를 로 대치한다.  우리가 추정한 값 가 실제 에 가깝다면 이 방법은 잘 동작할 것이다.  이것을 보장하기 위해서 Todd와 Burrel은 쌍대 가능해를 매 반복마다 구하였다.  그들은 를 쌍대 목적함수로 두고 쌍대성 원리에 의하여 이 값을 의 하한값으로 이용하였다.  그들은 이들 쌍대 가능해들이 쌍대 최적값으로 수렴함을 보임으로써 가 에 수렴하도록 하였다.
쌍대 가능해를 구하기 위해서 【 표 2 】의 쌍대문제를 다음과 같이 표현한다.

 
  
여기서 임의의 m 벡터 에 대해 인 는 쌍대 가능해이다.  반복이 거듭됨에 따라 가 최적 쌍대해로 수렴하도록 각 반복마다 를 정해주기만 하면 된다.
Todd-Burrel 알고리즘은 polytope의 내부점 하나가 필요하고 이 알고리즘을 이용하려면 【 표 5 】의 일반 선형계획문제를 【 표 2 】의 형태(homogenized form)로 바꾸어 주어야 한다.  



Karmarkar[1984]는 원문제의 가능해영역이 유한인 경우 가능해의 합에 대한 상한값()을 이용하여 변수들을 scaling하는 방법을 제안하였다. 

 ,    (2)

그 다음에 에 을 곱하면

  ,  (3)

여기서 와 는 n+1 차원이다.  (3)의 첫번째 식의 좌변의 계수행렬은 매우 밀도가 높게 된다.  따라서 (3)과 같은 방법은 바람직하지 못하다.  이런 단점을 보완하기 위하여 Tomlin[1987]은 (2)와 같이 scaling한 다음 새로운 변수를 첨가하여 이 변수가 1이 되도록 하는 방법을 고안하였다.

            
                           (4)
                

마지막 두 제약식은 다음과 같은 두 개의 식으로 대치될 수 있다.

 
 

모든 변수를 ½로 scaling하면 다음과 같은 식을 얻을 수 있다.

   = ,  (5)

이고 【 표 5 】의 해는  (단, j = 1, ..., n)에 의해 구할 수 있다.
Karmarkar는 초기 내부점을 구하기 위해 인공변수열을 만드는 방법을 사용하였는데 이것은 【 표 5 】의 제약식을 다음과 같이 만든다.

  ,  (6) 

따라서 은 가능해이고  를 0으로 최소화시키면 된다.  이것을 이용하여 (4) 식을 다시 쓰면 다음과 같다.

  =  (7)
 
여기서 이고,   = -n 이다.  이렇게 함으로써 는 m x n 행렬로 유지하면서 초기해 을 구할 수 있다.
 1.3 Affine Scaling Algorithm
Vanderbei et al[1985]과 Chandru와 Kochar[1986] 은 사영 알고리즘을 변형하여 "affine scaling algorithm"이라는 흥미있는 방법을 고안하였다.  이 방법은 해공간을 사영 공간으로 투영시키지 않고 단지 현재의 내부점을 점 으로 scaling 해 주는 방법이다.  이렇게 하면 가해영역의 polytope의 초평면으로부터 점이 떨어져 있어야 하는 내부점 선형계획법의 조건을 충족시킬 수 있고 목적함수를 0으로 두어야 하는 제약도 필요없다.  그러나 퇴화해가 존재할 때는 수렴성이 보장되지 않는다.  Gill et al[1985]은 이 기법이 【 표 5 】의 선형계획문제에 적용 가능한 barrier 기법과 연관되어 있다고 말했다.  
다른 연구는 Anstreicher[1986]는 사영 기법이 분수계획법에 이용될 수 있음을 보였고 Kojima[1985]는 알고리즘 수행 중에 최적해에서 남아 있을 기저 변수를 찾는 방법에 대해 연구하였다.  Tone[1985]은 개선 방향으로 사영 그래디언트를 사용하지 않고 reduced 그래디언트를 사용하는 hybrid 알고리즘에 대해 제안하였다.  Ba
본 논문에서 고려한 affine primal 기법은 Cavalier와 Soyster[1985], 그리고 Vanderbei et al[1985]가 각각 제안한 기법이다.  일반적인 비음 선형계획문제가 있다고 하면 【 표 5 】과 같은 형태가 될 것이다.  이것을 만족하는 초기 내부가능해 가 있다고 가정하자.  그러면, 선형 변환 와 이 있어서 【 표 5 】의 문제는 【 표 6 】의 형태로 변환이 가능하다.  여기서 인 대각 행렬이다.  



여기서 은 【 표 6 】의 가능해이고 이 점은 비영제약식으로 정의되는 모든 초평면으로부터 같은 거리에 있다는 특징을 가진다.  여기서 을 만족하는 개선 방향 가 주어지면 이 방향으로 가해성을 유지하면서 적당히 이동할 수 있다.  여기서  이라 두면 새로운 벡터 는  가 (0,1) 범위에 있기만 하면 【 표 6 】의 가능해이고 이기만 하면 는 개선방향이다.  를 구하는 방법은 의 영공간에  벡터를 사영시키기만 하면 된다.
이 사영은 다음 식 (7)과 같다.

  (8)

위 식에서 는 full rank이라고 가정한다.  이제 【 표 5 】의 새로운 해는 다음과 같다.

 
            
 
이 과정은 를 다시 로 정의함으로써 적절한 수렴 조건이 만족할 때까지 반복할 수 있다.  
【 표 5 】과 같은 비음 선형계획문제에 여유변수 를 첨가하고 Karmarkar가 제안한 대로 하나의 인공변수열을 첨가하여 초기 내부 가능해를 잡으면 다음과 같다.



여기서 이고 과 , 은 【 표 7 】의 내부 가능해이고 제 2 국면의 가능해를 찾기 위해 primal affine scaling 기법을 적용시킬 수 있다.  Lustig[1985]가 말한 대로 가해영역이 존재한다고 가정하면  는 제어 변수(blocking variable)가 되고 이와 같이 하면 내부점이 생성된다.  
Dual affine scaling 기법은 Adler et al[1989]과 Marsten[1987], Monna와 Morton[1987]에 의해서 성공적으로 수행되었다고 보고되었다.  최근에 들어서야 Dikin[1967]이 먼저 제안한 알고리즘이 주목받게 되었는데 Barnes[1986]와 Vanderbei, Meketon과 Freedman[1986]에 의해서 비슷한 방법이 논의되었다.  그러나 그들은 선형계획문제를 표준형으로 표현하였지만 dual affine scaling 기법은 부등식 형태의 선형계획문제에 직접 적용이 가능하다.
【 표 5 】과 같은 표준형 등식 형태의 문제가 주어졌다고 가정할 때 부등식 형태를 얻기 위해 원문제의 쌍대 문제를 표현하면 다음과 같다.  



여기서 는 m차원의 쌍대변수이다.  이 기법은 원문제의 쌍대문제에 적용하는 primal affine scaling과 동일한 과정으로 수행된다. 즉, primal 기법에서 인공변수열을 첨가하는 것과 마찬가지로 dual 기법에서는 쌍대인공변수열 즉, 하나의 행이 늘어나게 된다.  이 기법은 다른 기법에 비해 많은 사람들-Adler et al.[1989], Barnes[1986], Monna와 Morton[1987]이 성공적으로 구현에 성공했다고 보고되고 있다.  이 기법은 쌍대 여유변수를 이용하여 개선 방향을 찾는데 【 표 8 】에 쌍대 여유변수를 첨가하면 다음 식과 같다.  
 


여기서 는 n 차원 벡터이다.  초기 가능해 에서 출발하여 를 구하는 과정을 적당히 수렴할 때 까지 계속하는 방법이다.  여기서 쌍대해의 개선 방향 는 다음 식 (9)과 같다.

  (9)

           단, 
               

이 기법은 쌍대 여유변수가 비음이라는 조건을 이용하여 쌍대해의 개선 방향을 찾고 쌍대 여유변수가 비음이라는 가해성을 유지해야 하므로 개선폭도 쌍대 여유변수를 이용하여 도출한다.  쌍대 여유변수의 개선 방향과 개선폭은 다음 식 (10)와 (11)에 나와 있다.

  (10)

  (11)

쌍대해가 수렴되었다면 원문제의 해는 마지막 단계의 쌍대 여유변수와 그것의 개선방향으로부터 도출할 수 있다.  원문제의 최적해는 다음 식 (12)과 같다. 

  (12)

앞서 밝힌 내부점 기법 중에 path following algorithm은 logarithmic barrier 문제들에 대해서 central path라고 하는 경로를 따라가는 Newton 기법을 사용한다.  내부점 기법에 에서 궤적을 따라 가는 방법은 Karmarkar[1984]에 의해서 제안되고 Bayer와 Lagarias[1989], Megiddo[1989], Megiddo와 Shub[1989]에 의해서 깊이 연구되었다.  Megiddo[1989]는 central path를 원-쌍대 상보 관계 속에서 고전적인 barrier 경로와 연관시켜 설명했다.  Kojima, Mizuno와 Yoshise[1989]는 이것을 이용하여 최악의 경우  반복 안에 해를 구할 수 있는 원-쌍대 내부점 알고리즘을 제안하였다.  Monteiro와 Adler et al.[1989]는  반복 안에 해를 구할 수 있는 path following primal-dual 알고리즘을 발표하였다.  이 후에 그들은 이 알고리즘을 변형하면 primal-dual affine scaling 알고리즘으로 해석될 수 있음을 보였다.[1990]  그리고 그 논문에서는 적절한 초기해와 적절한 개선폭을 유지하면 다항식 복잡도를 가질 수 있음을 증명하였다.  좀더 자세히 말하면 알고리즘의 반복횟수는 초기해가 central path에서 떨어져 있는 거리에 대한 함수로 주어진다는 것이다.  Megiddo와 Shub[1989]도 초기해가 projective 알고리즘과 affine scaing 알고리즘에 있어서 어떤 영향을 미치는지에 대해서 분석하였다. 
비음 선형계획법의 표준형인 【 표 5 】과 그의 쌍대문제인 【 표 8 】를 생각해 보자.  여기서 【 표 8 】의 문제에 쌍대 여유 변수 를 첨가하면 【 표 9 】과 같다.
  이젠 우리는 【 표 5 】과 【 표 9 】의 내부 가능해집합을 정의할 수 있다.

 

  (13)

 

우리는 여기서 점 에서 duality gap을 으로 정의할 수 있고 이것은 이기만 하면 임을 알 수 있다.  따라서, 우리는 본 논문에서 duality gap을  대신에 를 사용할 것이다.
Primal-dual affine scaling 알고리즘을 도출해 내기 위해서는 【 표 5 】와 관련된 weighted logarithm barrier 함수에 대한 해에 대해서 살펴봐야 한다.  이것에 대해서는 Fiacco와 McCormick[1968]과 Monteiro와 Adler[1989]의 논문을 살펴보면 자세히 증명되어 있다.  그리고 Monteiro와 Adler[1990]가 이들 알고리즘이 primal-dual affine scaling 알고리즘으로 이용될 수 있음을 보였다.
초기해로 인 점을 찾아서 그 개선 방향 을 찾은 다음, 가 되도록(가해성을 유지) 개선해 나가는 과정을 duality gap 이 0 으로 수렴하여 상보 여유 정리(complementary slackness condition)를 만족할 때까지 반복하면 된다.  여기서 개선 방향은 다음과 같이 구한다.(Monteiro와 Adler[1990])

  
         

  (14)
        

 
        

이 식들을 고찰해 보면 와 를 구하는 것은 를 구하는 과정에 함께 구할 수 있음을 알 수 있다.

 1.4 자료 구조
Karmarkar가 제안한 선형계획법은 단체법보다 실용적으로도 더 빠르다고 주장되었다.   다항식 시간 수렴이 증명되었다고 하지만 불행히도 Karmarkar는 자신의 알고리즘의 구현을 위한 세부정보를 공개하기 꺼렸던 것처럼 보인다.  지금까지 Karmarkar의 알고리즘을 구현한 논문들 중에는 Bell Lab.에서 주장한 수행도를 보여주는 것이 없었다.  단지 그 변형을 구현한 논문 중에는 주목할 만한 것들이 있었다.-Adler et al.[1989], Monna와 Morton[1987]  
선형계획법에 대한 관심 중 실용적인 면에서 그 효용을 높이려면 그 알고리즘이 컴퓨터 코드로 구현되어 실제 문제를 푸는데 이용이 될 수 있어야 한다.  그런데 지금까지 발표되어 온 논문들의 대부분은 복잡도 증명에만 그친 경우가 대부분이었고 실제로 구현을 했다하더라도 자료 구조나 중복된 연산의 제거에 대한 관심이 적었다.  Monteiro와 Adler는 dual affine 알고리즘을 제시하고 그것을 구현한 자료 구조와 프로그래밍 기법에 대해서 논의를 했다.  그들은 비영 요소만을 보관하는 자료 구조를 채택하기는 했지만 많은 자료들을 중복되게 보관함으로써 메모리 소요 측면을 희생시키고 속도면에서 이득을 얻으려고 했다.  하지만 우리가 정의한 수행도의 정의에 비추어 보면 자료의 중복 보관으로 인하여 많은 메모리를 차지하게 되므로 최소의 자원으로 풀어야 한다는 조건에 위배된다고 볼 수 있다.  Monna와 Morton[1987]은 계수 행렬 의 비영 요소와 속도면을 고려하여 의 비영 요소를 3차원으로 보관하는 방법을 사용하였다. 
Monteiro와 Adler[1986,1989]는 dual affine scaling 기법에서 임의의 행렬 요소가 필요한 부분은 없고 열방향 연산과 행방향 연산만이 존재한다는 사실을 이용하여 열방향 억세스가 가능하도록 자료구조를 제시하였다.  
이 자료구조는 열방향 연산만을 위한 것으로 행방향 연산을 위해서 위와 같은 형태의 자료구조를 행방향으로 하나 더 보관하고 있다.  일반적인 선형계획법 문제의 계수 행렬 의 희소도가 높다고 하나 중복해서 보관하는 것은 좋지 못하다고 볼 수 있다.  게다가, dual affine 알고리즘의 식 (9)에서 필요한 역행렬의 원행렬 를 보관하고 있는데 이 구조 역시 계수행렬 과 비슷한 구조를 가진다.
Monna와 Morton[1987]은 계수 행렬의 전치 형태 를 열방향으로 보관하고 있는데 그 보관방식은 Monteiro와 Adler[1986, 1989]과 유사하다.   
이들의 논문에서 특이할 만한 사실은 Monteiro와 Adler[1989]는 계수 행렬을 열방향으로 보관하는 대신 행방향으로 한 본을 더 보관하고 있었지만 이들은 행방향 연산을 필요없도록 하기 위해  행렬을 계산하기 위해 행방향으로 미리 을 계산하여 열 요소 별로 3 차원 형태를 보관하고 있다.
알고리즘에 대한 자료 구조를 함께 다룬 연구들에는 위의 것들을 제외하고는 찾기가 힘들었고 좋은 수행도를 보이는 대부분의 프로그램들은 상용화되어 그 자세한 명세는 공개되지 않고 있다.
일반적인 자료 구조에 대한 것은 Horowitz와 Knuth[1973]에 의해 잘 정리되어 있다.  우리가 자료 구조에 대한 논의를 좀더 자세히 하기 위해서는 자료 구조에 대한 정의가 필요하다.  Knuth는 자료 구조의 정의를 "구조적인 관계를 나타내는 표"라고 정의하였다.  이 정의는 너무 포괄적이고 모호한 의미를 내포하고 있어 본 연구에서 자료 구조에 대한 정의를 구체적으로 정의해 보려고 한다.  자료 구조란 "채용한 알고리즘이 주어진 목표를 수행하는데 있어서 필요한 정보를 제공해 줄 수 있는 자료 보관 방식"이다.  이제 이와 같은 정의에 입각하여 좋은 자료 구조에 대한 개념을 정리해 보면 "자료의 중복을 최소화하면서 알고리즘이 잘 수행될 수 있도록 적절한 억세스 경로를 제공해 주는 자료 구조"라고 생각할 수 있다.  본 연구에서는 이와 같은 개념에 유념하여 내부점 선형계획법에 적절한 자료 구조를 설계할 것이다.     

 1.5 Choleski factorization 
어떤 알고리즘이 개발되기 위해서는 상대적으로 적은 메모리 용량을 사용하면서 간단한 코드로 쉽게 구현할 수 있고 많은 문제들을 풀 수 있어야 한다.  이것들에 대해서는 그 중요성에도 불구하고 아직도 많은 연구과제로 남아 있다.  Karmarkar가 자신의 내부점 알고리즘을 발표한 이후로 이런 것들에 대한 관심들이 고조되고는 있지만 현재의 프로그램들은 아직 복잡하다.
선형제약 방정식의 해에 있어서 관련되는 연산 중에 가장 중요한 것은 Gaussian elimination과 Choleski factorization이라고 말할 수 있다.  이 주제들을 다른 논문들은 무척 많을 뿐 아니라 이 기법들 외에 다른 기법들도 많이 연구되어 왔다.  이 기법들은 각 선형방정식의 특성에 따라 잘 이용된다면 좋은 알고리즘을 개발할 수 있다.  예를 들어, Zambardino[1974]은 다른 Gaussian elimination 기법보다 적은 기억 공간을 사용하는 프로그램을 제시하였다.  이 프로그램은 ALGOL로 개발이 되었는데  요소만을 보관하면 되도록 되어있지만 선회 정보를 보관하는데 정수 벡터가 필요하게 되고 Zambardino에 의해서 개발된 프로그램은 다소 복잡하였다.  대각 밴드(diagonal bands)처럼 특별한 구조를 가진 행렬에 대해서 많은 특수 기법들이 고안되었다.  Wilkinson과 Reinsch[1971]은 선형 방정식과 고유치 문제(eigenvalue problem)에 적용가능한 알고리즘을 제시하였다.  특별한 구조를 가진 많은 문제들에 대해서 이런 기법들이 고려되고 있지만 많은 사람들은 선형 방정식에 적용 가능한 믿을 만한 범용 기법의 개발을 원하고 있다.  따라서 본 논문에서도 수행도 개선 측면에서 Gaussian elimination과 Choleski factorization에 대한 프로그램을 개발할 것이다.
가 대칭이고() positive definite이면(, 0이 아닌 모든 에 대해) Choleski factorization이 이용될 수 있다.  Positive definite한 대칭행렬은 흥미 있는 특징을 많이 가지고 있는데 그 특징은 다음과 같다.  
만약 가 positive definite인 대칭행렬이라고 하면 
㈎ 모든 에 대해서 이어야 한다.  다시 말해서 모든 대각 요소는 양수이다.
㈏ 전체 행렬을 통틀어 가장 큰 수는 대각 요소 중의 하나이다.
㈐ 행렬 의 고유치는 실수이고 양수이다.
㈑ 행렬 에서 대칭성을 유지하면서 행과 열을 선택해서 만들어진 행렬도 positive definite이다.  예를 들어, 좌상단에서 시작한 1x1, 2x2, 3x3,... 부분행렬도 positive definite이다.

위의 성질 ㈎∼㈑는  행렬이 positive definite인 대칭행렬일 때 인 분해가 가능하다는 것을 의미한다.  이것을 염두에 두면 우리는 다음과 같이 쓸 수 있다.

  (15)

위의 식 (15)과 같은 분해를 Choleski factorization이라고 한다.

 1.6 Computational Experience 
Karmarkar 자신은 그의 알고리즘의 수행 결과에 대한 논문을 발표하지 않았다.  다른 많은 사람들이 기본적인 실험에 대해서는 보고하고 있는데 Karmarkar가 예측한대로 반복 횟수는 문제의 크기가 증가하더라도 별로 늘어나지 않는 것으로 나타났다.  그러나 각 반복에는 골치 아픈 최소자승문제(least square problem)가 포함되어 있어서 많은 시간이 소요된다.  따라서, 내부점 선형계획법의 성공의 열쇠는 효율적인 최소 자승문제 루틴에 있다고 해도 과언이 아니다.
Tomlin[1985]은 최소 자승문제를 푸는데 잘 알려진 QR factorization 방법을 Householder transformation과 Givens rotation을 이용하여 구현하였다.  하지만 두 경우 모두 사영법이 단체법보다 상당히 느린 것으로 나타났다.   이 주된 이유 중의 하나는 단체법은 희소도가 높은 계수 행렬 를 다루는데 반해 사영법은 희소도가 낮은 행렬 의 선형방정식을 다루어야 하기 때문이다.  이 행렬의 밀도가 높은 이유는 Karmarkar 기본형을 만들어 주기 위해서 계수행렬 에 첨가되는 두개의 열의 밀도가 높기 때문에 행렬 에 많은 비영 요소를 발생시킨다.  이런 문제는 affine scaling 알고리즘의 제 1 국면에서도 인공변수 열의 밀도 때문에 일어나게 된다.
이런 밀도 문제를 극복하기 위한 노력도 꽤 있었다.  Gill et al.[1985]는 로부터 밀도가 높은 열은 제거한 의 Cholesky factorization을 계산하여 이것을 Paige와 Saunders[1982]의 LSQR의 입력자료로 이용한 projected barrier 기법을 개발하였다.  그들의 기법은 일부문제에 있어서는 단체법에 견줄만한 속도를 보였다.  Shanno[1985]는 이 결과에 고무되어 Fletcher-Powell update를 이용하여 Cholesky factor를 구하려고 했었다.
Shanno와 Marsten[1985]은 의 선형 방정식 시스템을 매우 정확하게 풀지 못하면 현재의 해가 비가해가 되어 버리거나 수렴성을 가지지 못한다는 사실을 발견하였다.  그들은 사영법에서 conjugate gradient 기법과 inexact matrix를 이용하여 이런 현상을 극복하려 했지만 성공하지 못하였다.  Aronson[1985]은 LSQR 기법을 이용하여 사영법은 밀도가 높고 난수 발생시킨 소형문제에서 단체법보다 14배나 느리게 해를 찾는다고 보고하였다.
Vanderbei은 밀도가 높은 소형문제에서 그들의 affine scaling 알고리즘이 한 반복당의 계산량은 같게 하면서도 사영법의 반복횟수의 ½만으로도 문제를 풀 수 있다고 하였다.  또, 같은 문제 규모에서 계산 시간 측면에서도 단체법에 필적할 만한 것으로 말했다.
지금까지 많은 연구들이 공통으로 보고한 사실은 최소자승문제가 최적점에 가까와 갈수록 ill-conditioned 되어진다는 것이다.  이 문제는 최적해가 퇴화해일 때 더욱 민감하고 그 이유는 명백하다.  퇴화정점에서는 변수 의 비영 요소 수가 의 rank m 보다 더 적어진다.  이것은 가 full rank가 아니라는 말이 되고 가 특이 행렬이 된다는 점이다.  추측컨대 결국 0으로 수렴하게 될 변수 는 가 ill-condition 되기 전데 찾아내서 제거해야 할 것 같다.
Shanno와 Marsten은 0 으로 접근하는 변수를 그냥 제거해 버리는 것은 다소 위험하기 때문에 Kojima의 기저변수 테스트가 유용한 것으로 연구하였다.
최근에 나온 Adler et al.[1986]의 실험은 기존의 단체법 프로그램인 MINOS 4.0보다 3 배나 빠르게 실제 LP 문제를 풀었고 문제의 크기가 클수록 그 차이도 크게 나타나는 것으로 보고하고 있다.  그는 dual affine 알고리즘을 구현하였는데 inexact matrix를 이용한 근사 사영이 가해성을 잃지 않고 잘 수행되었던 것으로 보인다.
  

제 2 장. 자료 구조 설계 
이 장에서는 이 논문의 목적 중의 하나라고 할 수 있는 내부점 선형계획법의 비영요소 보관 형태의 새로운 자료 구조를 제시할 것이다.  이러한 자료 구조를 설계하는데 있어서 고려한 것은 다음과 같다.

 ● 자료에 대한 억세스 형태 - 연산 별 억세스 형태
 ● 자료가 구현하는 수학적 모델의 특성
 ● 자료 구조가 차지하는 메모리 소요량
 ● 자료 구조를 이용하는 연산의 수행 횟수

이와 같이 이론적인 측면과 실용적인 측면을 동시에 고려하여 그 결과를 실제로 구현하였다.  여기서 마지막 두 항목은 서로 상충되는 특성이 있기 때문에 우선 순위를 정할 순 없지만 가능한한 자료의 중복을 허용하지 않는 방향으로 자료 구조를 설계할 것이다.

 2.1 내부점 선형계획법의 수행 연산 
임의의 m x n 행렬의 자료 구조에 관련된 연산은 여러 가지가 있을 수 있다.  그 중 몇 가지만 정의해 보도록 하겠다.

임의 추출 억세스(random access)
  임의의 원소 에 대한 억세스
행방향 억세스(rowwise access)
  임의의 행 의 요소들의 순차 억세스(sequential access)
열방향 억세스(columnwise access)
  임의의 열 의 요소들의 순차 억세스(sequential access) 
대각방향 억세스(diagonal access) 
  임의의 d 번째 대각원소들의 순차 억세스(sequential access)

이와 같은 억세스 형태를 결정하기 위하여 우리는 먼저 내부점 선형계획법에서 사용되는 각 연산들에 대한 고찰이 필요하다.  행방향 억세스는 계수 행렬 가 행렬곱 앞의 요소이거나 계수 행렬의 전치 형태 가 행렬곱 뒤의 요소일 때 필요하게 된다.  열방향 억세스는 이와는 반대로 계수 행렬 가 행렬곱 뒤의 요소이거나 계수 행렬의 전치 형태 가 행렬곱 앞의 요소일 때 필요하게 된다.  아래에 내부점 선형계획법에서 계수 행렬 를 필요로 하는 연산들에 대한 표이다.


   
1 장에서 소개한 내부점 선형계획법의 각 단계들을 고찰해 본 결과, 계수 행렬 에 관련된 연산은 행방향 억세스와 열방향 억세스 뿐이다.  따라서, 채용할 자료 구조는 행별, 열별로 순차적인 억세스가 가능해야 한다.  일반적으로 실제 선형계획법 문제에서 계수 행렬 는 희소도가 매우 높은 것으로 알려져 있기 때문에 본 연구의 자료 구조는 비영 요소만을 보관하는 자료 구조를 택할 것이다.  즉, 비영 요소만을 보관하면서 행방향 억세스와 열방향 억세스가 동시에 가능한 자료 구조를 설계하여야 한다.  Monteiro와 Adler[1990]는 열방향 억세스만 가능한 자료 구조를 설계하고 행방향 억세스를 위해서는 동일한 형태의 자료를 다시 보관하는 방법을 사용하였다.  여기서 자료 구조 설계에 있어서 고려해야 하는 것은 Karmarkar 기본형으로 변환 시나 1 국면을 수행하기 위해서 인공변수를 첨가하여 계수 행렬 을 확장하는 문제이다.  즉, 행렬의 크기가 변하게 되는 것에 대한 처리가 문제이다.  
우리가 1.4절에서 밝힌 좋은 자료 구조의 정의에 입각해서 생각해 보면 우선 우리가 제시할 자료 구조는 최소한의 메모리만을 가져야 한다는 것을 알 수 있다.  간단한 자료 구조를 채용하여 메모리를 많이 사용하면 프로그램은 쉽게 작성할 수도 있고 속도도 빠를 것으로 생각되지만 메모리를 과대하게 사용하여 프로그램이 개발되었다하더라도 그 과도한 메모리 소요분이 속도에 기여하는 정도는 미미한 것으로 보고되었다
.이러한 측면에서 내부점 선형계획법 알고리즘을 고찰해 본 결과 반드시 필요한 행렬은 2 가지가 있다.  계수 행렬 는 원 자료이기 때문이고 factorization 과정에 필요한 m x m 크기의 행렬 이 필요하다.  기존의 논문에서는 이들 행렬 외에도 를 보관하거나 를 보관하는 방법을 사용하였지만 이들은 매 반복에 있어서 단 한번만 사용하고 알고리즘이 수행 가능하다.  따라서, 굳이 별도의 메모리를 할당하여 보관하지 않고 직접 계산하여 이용하는 것이 효율적인 것으로 사료된다.  따라서, 이  행렬에 관한 연산에 대해서도 좀더 연구할 필요가 있다.  


   
여기서 행 열방향 억세스 형태에 대해서는 자세히 살펴 보면 이들 억세스 형태는 실제로는 행방향 형태로 대치될 수 있음을 알 수 있다.  왜냐 하면 행렬곱은 결함법칙이 성립하므로 역행렬 의 뒷부분부터 계산을 하면  행렬이 항상 행렬곱의 앞쪽에 있는 것이 되어버리기 때문이다.  이 특징은 상당히 중요한 것이다.  왜냐 하면 역행렬 는 한쪽 방향만으로 억세스 가능하면 되기 때문이다.  Monteiro와 Adler[1990]가 제안한 계수 행렬의 보관 방식이 이것에 더욱 적합하다고 생각된다. 하지만 불행히도 본 연구에서는 열방향의 억세스 형태도 고려해 줄 수 밖에 없었다.  그 이유는 역행렬을 구하는 방법을 열방향의 억세스 형태를 취하는 기법을 이용했기 때문이다.  
단체법에서도 계수 행렬의 기저 변수열로 이루어진 행렬의 역행렬 을 보관한다.  단체법은 기본 발상 자체가 한 정점이 초평면을 이동하면서 기저 변수들 중에서 하나씩 교체됨으로써 알고리즘이 수행되는 rank one update에 기반하고 있기 때문에 이들 기저 변수열에 대해서만 를 보관하면 된다.  따라서, 항상 전 단계의 를 보관하고 있고 이 행렬에 rank one update를 적용하여 현재 단계의  행렬을 유지하게 된다.  이와는 대조적으로 내부점 선형계획법들은 각 반복마다 독립된 를 구하게 된다.  에서 으로 넘어 가는 과정이 독립적이라는 말은 임의의 한  만이 수정되는 것이 아니라 의 모든  값들이 개선 방향 으로 수정된다.  따라서 rank one update를 위한 억세스 형태를 고려해 줄 필요가 없다.  하지만 주의할 것은 수행도를 향상시키는데는 inexact matrix를 이용한 근사 역행렬을 이용하는 것이 좋다.  이럴 때는 rank one update에 대한 억세스 형태도 함께 고려해야 한다. 

 2.2 내부점 선형계획법의 수학적 특성 
우리는 2.1절에서 내부점 선형계획법 구현에 꼭 필요한 행렬에 대해서 그 억세스 형태를 연구해 보았다.  이 절에서는 이들 행렬에 적합한 자료 구조를 설계하기 위해서 이들 행렬이 수학적으로 어떤 특징을 가지는지 알아볼 것이다.  이런 특징들이 적절히 고려됨으로써 좀더 내부점 선형계획법에 적합한 자료 구조를 설계하는데 도움이 될 것으로 기대된다.  아울러 불필요한 프로그램 코드를 제거할 수도 있다.
우선 계수 행렬 에 대해서 생각해 보자.  이 행렬은 선형계획문제를 나타내는 원 자료이므로 특이할 만한 수학적인 특징은 없지만 일반적으로 희소도가 높아서 대부분의 행렬 원소들이 0이다.  따라서 이러한 자료의 특성을 잘 이용하기 위해서는 sparse matrix handling 기법이 사용되어야 한다.  그리고 초기 입력 자료를 받아들인 후, 인공 변수열을 첨가 제거하는 연산을 제외하면 초기에 한번 생성되면 그 비영 패턴이 끝까지 유지된다는 특징이 있다.  
다음으로  행렬 에 대해서 생각해 보자. 이 행렬은 많은 수학적인 특징을 가지는데 이것은 내부점 선형계획법 공통적인 고유 특징이라고 말할 수 있다.  이 행렬은 원행렬 의 역행렬인데 이 원행렬이 가 대각행렬일 경우엔 대칭행렬이라는 특징을 가지기 때문에 그 원행렬 역시 대칭행렬의 특징을 가진다.  따라서 자료의 중복을 막기 위해 상삼각 행렬로 보관이 가능할 것으로 생각된다.  하지만 factirization의 과정에서 상삼각 행렬이 유지되지 않을 수 있기 때문에 외포적으로 상삼각 행렬을 유지하는 것은 어려울 것으로 사료된다.  원행렬 는 계수 행렬 와 마찬가지로 비영 요소 패턴이 변하지 않는다.  그 이유는 를 제외한 행렬의 비영 요소 패턴은 에 의해서만 결정되는데  행렬은 대각 원소가 0 아닌 대각 행렬이기 때문이다.  그렇다면 여기서 왜  행렬의 대각 원소가 0 이 아닌지 생각해 보자.   행렬로 우리가 표기하는 것은 각 내부점 선형계획법에 따라 다른데 다음의 【 표 12 】와 같다.      


이론적으로 내부점 선형계획법들은 제약식으로 표현되는 초평면 위로는 내부점이 이동할 수 없도록 되어 있다.  이렇게 되어야 하는 이유는 내부점 기법에서 현재의 해에 대한 가해성을 유지하기 위해서이다.  Karmarkar 기법과 primal affine scaling 기법에서는 내부점이 초평면 가까이에 접근은 하게 되더라도 초평면 위로는 이동할 수 없으므로 대각 행렬 의 어떤 원소도 0 일 수 없다.  그리고 dual affine scaling 기법에서는 쌍대 여유 변수가 0 이 되면 제약식에 속박(binding)되므로 초평면 위로 이동한 것과 같다.  따라서 이런 경우도 성립될 수 없다.  따라서 대각 행렬 의 어떤 원소도 0 일 수 없다.  마지막으로 primal-dual affine scaling 기법에서는 앞의 기법과 같은 이유로 대각 행렬 의 어떤 원소도 0이 될 수 없다.  

 2.3 내부점 선형계획법의 자료 구조 
본 절에서는 위에서 말한 여러 측면에서의 특징을 고려하여 내부점 선형계획법에 적절한 자료 구조를 제시하고 그 특징들과 억세스 방법들에 대해서 논의할 것이다.  계수 행렬 와 대칭 행렬 이 알고리즘 수행 전반에 필요한 중요한 자료 구조이기는 하나 자료 구조의 설계가 잘못되어 있으면 프로그램으로 작성된다 하더라도 메모리가 과도하게 많이 차지하게 되거나 많은 임시 변수(지역 변수)들을 선언해야 하는 폐단을 가진다.  따라서 적절한 자료 구조를 설계하여 계수 행렬 와 대칭 행렬 만으로도 알고리즘이 수행될 수 있도록 하였다.

계수 행렬 의 자료 구조
계수 행렬 에 이용되는 연산은 2.1절에서 밝힌 대로 행방향 연산과 열방향 연산이 모두 사용되므로 비영 요소만을 보관하는 자료 구조를 채택하기 위해서는 계수 행렬 의 비영 요소 의 값은 물론 행지수 는 물론 열지수 도 보관되어야 한다.  그리고, 임의의 행과 열의 비영 요소들을 순차적으로 억세스될 수 있도록 하기 위해서는 연결고리(link)가 있어야 한다.  이런 요구를 충족시키기 위한 자료 구조는 하향 우향 연결 구조가 적합하다. 
이런 자료 구조를 구현하는데 필요한 계수 행렬 의 비영 요소들의 자료 구조는 행지수, 열지수, 비영 요소값, 행포인터, 열포인터이다. 
이것을 도식화 해보면 다음과 같다.

          +--------+--------+------------+----------+----------+ 
          | 행지수  | 열지수 | 비영요소값  | 열포인터  | 행포인터 |→ 
          +--------+--------+------------+----------+----------+
                                           ↓ 
                                                                         
여기서 행지수, 열지수, 비영요소 값들은 각각 비영 요소의 실제 행지수, 열지수, 비영 요소값들을 보관하고 행 포인터는 같은 행 내에서 현재의 비영 요소 다음의 비영 요소가 기억되어 있는 배열내 주소를 보관하고 열 포인터는  같은 열 내에서 현재의 비영 요소 다음의 비영 요소가 기억되어 있는 배열내 주소를 보관한다.  만약 임의의 행이나 열의 마지막 비영 요소라면 마지막을 알리는 특수한 값을 보관한다.  우리가 우리가 만약 임의의 행 나 열 이 필요하다고 하면 행이나 열의 시작 주소만 알면 원하는 행과 열을 순차적으로 억세스할 수 있다.



프로그램에서 사용할 실제 배열은 다음과 같다.  
만약,  행렬의 최대 비영 요소가 MAXA, 행수가 MAXR이고 열수가 MAXC라면

   float AN[MAXA]       행렬의 비영 요소 값 보관
   int   RN[MAXA]       행렬의 비영 요소들의 행지수 보관
   int   CN[MAXA]       행렬의 비영 요소들의 열지수 보관
   int   RNEX[MAXA]     행렬의 행의 다음 비영 요소들의 AN의 배열 지수
   int   CNEX[MAXA]     행렬의 열의 다음 비영 요소들의 AN번호
   int   ROWI[MAXR)    각 행들의 시작 AN의 번호
   int   COLI[MAXC]    각 열들의 시작 AN의 번호

이해를 돕기 위해 다음에 예를 들어 보이도록 하겠다.

예) 다음과 같은  행렬이 있다고 하자. 빈칸은 0 이다.

  

위의  행렬은 아래와 같이 보관된다.

 

위의 자료 구조 중 RNEX 라고 하는 것에서 비영 요소가 들어 있지 않는 배열 요소에도 값들이 포함되어 있다.  이것은 가용 리스트(available list)를 구현한 것으로 비어있는 배열 요소들을 가용리스트에 보관해 두었다가 새로 필요하게 되면 이것을 할당받고 필요가 없게 되면 다시 가용리스트의 제일 앞에 연결시켜 둠으로써 허비되는 배열요소가 없도록 하고 별도의 메모리 부담없이 가용 메모리를 구성할 수 있다.
 행렬이 위와 같은 자료 구조를 택했을 때 임의의 행을 억세스 하는 방법은 다음과 같다.  임의의 열을 억세스하고 싶을 때는 아래의 pseude-code에서 ROWI대신 COLI를, RNEX대신 CNEX  를 사용하면 된다.  다음의 pseudo-code는 Tarjan[1983]이 사용한 것과 비슷한 형태이다.
 
 p := ROWI[i]
 do ( p != -1 )
      .....
         p := RNEX[i] 
 od

대칭 행렬 의 자료 구조
대칭 행렬 에 관련된 자료 구조는 2.1절에서 밝힌 대로 행방향 억세스와 열방향 억세스를 가능하도록 해야 한다.  하지만 적절한 연산 순서를 세우면 행방향 억세스만으로도 관련된 모든 연산을 수행할 수 있다.  그러나 이 경우에는 열방향 억세스를 사용하지 않는 역행렬 연산 루틴도 함께 연구되어야 한다.  본 논문에서는 역행렬 연산 루틴으로 Gaussian-elimination 기법을 이용하는데 이것은 루틴 중간에 효율을 위해서 열방향 억세스도 필요로 한다.  따라서, 행방향 연산만으로 가능한 역행렬 루틴을 연구하면 좀더 효율적인 자료 구조를 설계할 것으로 기대된다.  본 논문에서는 대칭 행렬 의 자료 구조도 하향 우향 연결 구조로 제시한다.  이렇게 함으로써 계수 행렬 와 같은 기법으로 자료의 보관과 억세스가 가능하기 때문에 프로그래밍도 쉽게 할 수 있었다.
내부점 기법에서의 역행렬 은 항상 대칭행렬이다.  따라서, 이 역행렬의 보관 형태는 상삼각행렬로 생각해 볼 수 있다.  이런 대칭성을 이용하지 않고  행렬을 보관을 하면 밀도가 100 % 인 경우에는 비영 요소가 인데 대칭성을 이용한 아래와 같은 자료 구조를 이용하면  개의 비영요소만으로도 자료 보관이 가능하다.  
대칭 행렬 과 관련된 연산을 수행하려면 계수 행렬 와 마찬가지의 자료 구조를 취해야 한다.  결국 의 비영 요소의 자료 구조를 도식화 시켜 보면 의 비영 요소의 자료 구조와 동일하다. 

         +--------+--------+------------+----------+----------+                     | 행지수  | 열지수 | 비영요소값  | 열포인터  | 행포인터 |→    
         +--------+--------+------------+----------+----------+
                                           ↓ 

여기서 행지수, 열지수, 비영요소 값들은 각각 비영 요소의 실제 행지수, 열지수, 비영 요소값들을 보관하고 행 포인터는 같은 행 내에서 현재의 비영 요소 다음의 비영 요소가 기억되어 있는 배열내 주소를 보관하고 열 포인터는  같은 열 내에서 현재의 비영 요소 다음의 비영 요소가 기억되어 있는 배열내 주소를 보관한다.  만약 임의의 행이나 열의 마지막 비영 요소라면 마지막을 알리는 특수한 값을 보관한다.  우리가 우리가 만약 임의의 행 나 열 이 필요하다고 하면 행이나 열의 시작 주소만 알면 원하는 행과 열을 순차적으로 억세스할 수 있다.
 


프로그램에서 사용할 실제 배열은 다음과 같다.  
만약,  행렬의 최대 비영 요소가 MAXBI, 행수가 MAXR이라면
 
float BIN[MAXBI]      행렬의 비영 요소값 보관
int ROCOL[2][MAXBI]  행렬의 비영 요소들의 행지수[0] 열지수[1] 보관
int RCNEX[2][MAXBI]  행렬에서 각 행[0]열[1]의 다음 비영 요소위치 
int RCINI[MAXR]      각 행들의 시작 BIN의 번호

이해를 돕기 위해 다음에 예를 들어 보이도록 하겠다.

예) 다음과 같은  행렬이 있다고 하자. 빈칸은 0 이다.


  

위와 같은 대칭 행렬  행렬은 아래와 같이 보관된다.

 

위의 자료 구조 중 RCNEX[0] 라고 하는 것에서 비영 요소가 들어 있지 않는 배열 요소에도 값들이 포함되어 있다.  이것은 계수 행렬 와 마찬가지로 가용 리스트(available list)를 구현한 것으로 비어있는 배열 요소들을 가용리스트에 보관해 두었다가 새로 필요하게 되면 이것을 할당받고 필요가 없게 되면 다시 가용리스트의 제일 앞에 연결시켜 둠으로써 허비되는 배열요소가 없도록 하고 별도의 메모리 부담없이 가용 메모리를 구성할 수 있다.

 행렬이 위와 같은 자료 구조를 택했을 때 임의의 열이나 행을 억세스 하는 방법은 다음과 같다.  다음의 pseudo-code는 Tarjan[1983]이 사용한 것과 비슷한 형태이다.
 
 p := RCINI[i]
 do ( p != -1 )
      .....
         p := RCNEX[1][p] 
 od
 p := RCNEX[0][p]
 do ( p != -1 )
      .....
         p := RCNEX[0][p] 
 od

그리고 임의의 원소 가 필요할 경우는   만약   j ≥ i  이면, 을 억세스하고 i > j  이면, 을 억세스 하면 된다.

 2.4 제안된 자료 구조의 효용 
일반적으로 실제 사례들을 모델링한 문제들을 보면 희소도가 높은 것으로 나타나 있다.  그런데 이런 희소도를 고려하지 않는 자료 구조를 선택하게 되면 계산에 필요없는 0을 지나치게 많이 보관하게 되고 이것은 곧 수행속도에도 지대한 영향을 미칠 뿐 아니라 수치적 안정성까지도 잃게 된다.  따라서, 상용화된 대부분의 프로그램들은 비영 요소만을 보관하는 자료 구조를 채택하고 있다.  희소도가 높은 현상은 선형계획문제의 크기가 증가할수록 크게 나타난다.
2.3절에서 제시한 자료 구조가 전산기 내부의 메모리를 얼마나 차지하는가에 대한 고려를 해 보면 다음과 같다.  이러한 분석이 가능하도록 한 프로그램의 변수들에 대한 명세는 부록 A에 나와 있다.

 기존 배열방식의 기억 소요
  

 본 연구의 자료 구조에 의한 기억 소요
  
                   
 
 

위의 표에서 비율이라고 일컫은 것은 의 비이다.  여기서 의 밀도 는 문제마다 다를 뿐만 아니라 방법에 따라 다르기 때문에 와 같다고 가정한다.  그리고 2.2절에서 말한 것과 같이 계수 행렬 와 대칭 행렬 의 비영 요소 패턴은 인공변수의 첨가 제거할 때를 제외하고는 절대로 바뀌지 않는다.  따라서 이들 행렬의 밀도는 제 1 국면과 제 2 국면에서만 계산해 보면 각 반복이 진행되는 중에는 변하지 않는다.  위의 표에서 보는 바와 같이 일반 실제 문제에 있어서 문제의 크기가 클수록 밀도가 작아지고 밀도가 작을 수록 절약되는 기억 공간 양이 큰 것으로 나타나 있다.  이것을 그림으로 나타내면 다음과 같다.

 2.5 희소도 
우리가 자료 구조를 설계할 때 고려했던 최소의 메모리를 이용하는 자료 구조를 개발하기 위해서 비영인 요소만을 보관하는 자료 구조를 선택하였다.  우리가 처음에 관심이 있었던 것은 계수 행렬 의 희소도가 대칭행렬 의 희소도에도 유전이 될 수 있는가에 관한 것이었는데 이는 Murty에 의해서도 논의되었는데 일반적으로 그렇지 않다고 보고되어 있다.  따라서, 생성되는 역행렬의 비영 요소(fill-in)를 최소화하는 ordering scheme이 사용되어야 하는데 본 연구에서는 그것에 대한 고려가 되지 못하였다.  하지만 본 논문의 자료 구조는 더 이상의 메모리 운영 부담을 가지지 않고도 ordering scheme을 잘 처리할 수 있을 것으로 보인다.  우리는 이와 같은 희소도 유전에 대한 정보를 얻기 위하여 1 국면과 2 국면의 각 반복마다 비영 요소의 수를 조사하였다.   앞서 밝힌 대로 나 , 의 비영 요소 패턴은 중간 과정의 계산 결과가 0 이 아닌 한, 초기에 한번 결정되면 그 패턴이 변하지 않으므로 각 반복의 비영 요소의 수는 일정하다.  하지만 이런 비영 요소의 패턴이 그대로 유지될 때  행렬이 점점 ill-conditionning 되는 문제가 발생하므로 적절한 값을 0 으로 처리하여 그 비영 요소를 제거해 주는 error-correction 부분에 대한 연구가 필요하다.
각 행렬들의 비영 요소의 수에 대한 정보는 다음과 같다.
【 표 16 】과 【 표 17 】은 Gaussian elemination 기법을 사용했을 때의 비영 요소의 수를 조사한 것이다. 
이들 표에서 살펴보면 행렬들의 비영 요소 수가 국면에 따라 다른 이유는 원문제의 인공 변수열과 쌍대문제의 인공 변수열로 추가되는 열의 밀도가 높기 때문이다.  이상의 표들을 살펴보면 의 희소도는 에 유전이 되지만 의 희소도는 그 역행렬에 유의한 영향을 주지 않는 것으로 나타났다.  하지만 이런 문제는 적절한 ordering scheme이 사용되면 어느 정도 희소도 유전이 가능할 것으로 예상된다.





제 3 장. 체계적 모듈화 
 3.1 기존의 연구분야 분류 
본 논문에서 구현하려는 내부점 선형계획법의 범용 프로그램은 앞으로 다른 연구에 기여할 수 있는 실험용 tool을 제공하려는 목적도 가지고 있다.  따라서, 연구자가 자신이 개발한 새로운 알고리즘이나 발견적 기법(heuristics)을 적용할 수 있는 표범적인 틀이 필요하다.  그렇지 못할 경우는 비슷한 알고리즘 간의 수행도 비교가 그 의미를 상실하게 되거나 프로그래밍 부담 측면에서도 연구자가 자신의 기법을 적용시키기 위해서는 수행 알고리즘 전반에 관한 지식을 가지고 전체를 모두 프로그래밍해야 한다는 문제점을 가지고 있다.  그래서 앞으로 내부점 선형계획법에 대한 많은 실험적 논문들이 나올 것인 바, 그들 실험을 뒷받침할 수 있는 실험용 tool을 제공할 것이다.  따라서, 지금까지 내부점 선형계획법을 연구하는데 있어서 발표된 논문들을 분야별로 분류해 보고 이것들에 관련되어 프로그램들을 모듈화하는 것은 앞으로 이들 분야들과 관련된 논문의 실험에 유용할 것이다.
지금까지 내부점 선형계획법이 연구되어 온 세부분야들은 다음과 같이 분류될 수 있다.
  
 ● 초기 가능해에 관한 연구
 ● 문제 변환에 관한 연구
 ● 개선폭에 관한 연구
 ● 사영행렬의 계산에 관한 연구
 ● 종료 조건에 관한 연구
 ● 목적함수의 최적치에 관한 연구

초기 가능해를 구하는 방법에는 다른 선형계획법과 마찬가지로 대수법과 2국면법이 있다.  초기해를 어떻게 잡아 주느냐가 내부 가능해를 얼마나 빠르게 찾아낼 수 있는 출발점이 되므로 이것에 대한 연구도 많이 필요하다고 본다.  그리고 개선폭은 기본적으로 가해성을 유지할 수 있는 최대의 이동거리를 찾는 방법으로 진행되어 왔다.  그리고 사영행렬은 많은 수학적, 자료 구조적 특징을 가지므로 좀더 빠르게 계산해 내기 위한 방법과 가해성을 유지하는 범위 내에서 근사시킨 사영 행렬을 계산해 내는 방법, 그리고 그 근사 기준에 대한 연구들이 수행되었고 앞으로도 필요하다.  종료 조건에 대한 연구는 내부점 선형계획법이 기본적으로 수렴성에 원칙하고 있으므로 어느 정도 수렴이 되면 종료시키는 방법을 찾는 방향으로 진행되었는데 Megiddo와 Shub[1986]에 의하면 내부점 선형계획법들은 최적해에 가까이 가서는 그 수렴반경이 현저하게 줄어드는 것으로 알려져 있다.  그러므로 너무 작은 tolerance가 주어지면 많은 반복횟수 후에 종료될 수 있다.  그리고 너무 큰 tolerance가 주어지면 해의 정확도가 떨어지는 단점이 발생하게 된다.  이것들의 적정한 절충점을 찾을 수 있는 논문이 필요하다.  그리고 문제마다 이 tolerance가 다르게 세팅되어야 한다면 이것을 담당할 수 있는 전문가 시스템의 개발도 유용할 것이다.

 3.2 내부점 선형계획법의 모듈화 
내부점 선형계획법의 세부분야를 3.1절에서 살펴 보았다.  이런 분야들을 살펴보면 몇 개의 부문 별로 연구가 지속적으로 진행되어 왔음을 볼 수 있다.  앞으로도 이런 분야에 대해서 계속 연구되고 있고 이들 연구 결과를 수행해 볼 수 있는 원형(prototype)이 있어야 할 것이다.  따라서 이런 연구 부문에 따른 모듈화가 0.2절 연구의 필요성에서 약속한 미래의 연구 수행에 일조를 할 수 있을 것이다.  내부점 선형계획법은 기본적으로 비슷한 단계를 거쳐 최적해를 구하도록 되어 있다.  따라서 모든 내부적 기법에 공통적으로 사용될 수 있는 부프로그램을 개발할 수 있을 것으로 기대된다.  
여기서는 고려된 내부점 선형계획법을 구현하는데 필요한 일련의 부프로그램을 모듈화해 보았다.  앞으로 이하의 각 모듈들과 관련된 부분에 대한 연구가 요구될 시는 그 모듈만 대체해서 실험해 봄으로써 그 효과를 알아볼 수 있는 도구가 되길 기대한다.
본 논문에서는 모듈화의 개념을 다음과 같이 정의한다.  모듈화란 서로 인과관계를 가지고 있는 각 단계들을 독립되어 사용될 수 있는 부프로그램화하는 것이다.  모듈화는 다음과 같은 측면에서 접근될 수 있다.  그리고 모듈화를 위해서는 알고리즘 전반에 대한 연산 및 흐름에 대한 이해가 필요하다.  

 전체적인 알고리즘의 흐름 제어
 연산 절약
 자료 구조 관리

즉, 전체적인 알고리즘을 제어하는 모듈과 중복된 연산을 제거하기 위해 부프로그램화되는 모듈, 자료 구조 관리를 위해서 필요한 모듈로 나눠볼 수 있다.  다음의 【 표 18 】은 전체적인 알고리즘을 제어하는 측면에서의 모듈을 보여 주고 있다.



위의 표의 각 열에 나타나 있는 내부점 선형계획법들은 본 연구에서 개발하게될 프로그램들이며 기본적인 입출력 부프로그램들을 제외하면 거의 유사한 루틴들로 사용되나 최적해로 접근하는 방법이 원가능공간에서 접근하느냐 쌍대가능공간에서 접근하느냐에 따라 일부의 부프로그램 루틴이 다르게 이용된다.  위의 【 표 19 】에 나타나지 않는 모듈 중에 중요한 부프로그램이 있다.  이것에 대해서는 다음에 설명되어 있다.

 tercon() 종료 조건에 대한 검사
 monot()  단조성에 대한 검사
 unbound() 무한해에 대한 검사      

이들 tercon() 부프로그램은 최적해의 질을 적절하게 조정하는데 필요하고 monot() 부프로그램은 해의 단조성을 검사하는데 이것은 내부 가능해의 가해성을 검사하는 것과 같다.  그 이유는 내부점 기법에서는 해가 단체의 내부를 벗어나게 되면 해가 단조성을 잃게 되기 때문이다.  unbound() 부프로그램은 해집합이 무한 집합임을 검사하는 것으로 이것에 대한 연구는 아직 미흡하기 때문에 빠른 시일 내에 연구되어 모듈로 첨가되기를 바란다.

연산 절약을 위한 측면의 모듈을 생각해 보기로 한다.
내부점 기법에서는 많은 부분에서 유사한 연산을 수행하게 된다.  이러한 연산들을 각각 다른 부프로그램에서 코딩하면 프로그램이 길어질 뿐 아니라 새로운 연산 방법을 고안하여 수정할 때도 쉽지 않게 된다.  따라서 공통된 연산이 적용되는 곳이면 하나의 모듈로 부프로그램화하는 것이 좋다.

연산절약을 위한 모듈을 관련 연산과 함께 정의해 본다.

 dualUn() 
  
 minVn()       
 c_atu(i)   
 maxstep() 
  
 aatn(i,j) 
  
       
  
 zobk() 
  
     단,  

이와 같은 연산들은 변수들이 다른 차이는 있지만 같은 부프로그램으로 공통되게 사용이 가능하다.
모듈화할 때 마지막으로 분류해 볼 문제인 자료 구조 처리 모듈은 내부점 선형계획법 자체와는 직접적인 관련이 없고 복잡한 문제가 개입되어 있으므로 여기서는 다루지 않기로 한다.

 3.3 모듈화 스키임 
위의 3.2절에서 수행한 연구 결과에 의해 본 논문에서 개발한 프로그램이 가지는 모듈화 스키임을 대략적으로 그려보면 다음과 같다.  우리는 이 모듈화 스키임에 따라 범용 내부점 선형계획법 프로그램을 개발하였다.

 Karmarkar   inisoln()      
                       dualsoln()  - aatn()
                                   - dualUn()
                                   - minVn()  -  c_atu()
                       directCPn() - aatn()
                       steplen()   - maxstep(), maxline()
                       upsol()     - zobk()
     tercon() & monot()
     optsol()

 Primal affine scaling  inisoln()     
           dualUn()     - aatn()
     directCPn()  - c_atu()
     steplen()    - maxline() 
                       upsol()      - zobk()
     tercon() & monot()
     optsol()

 Dual affine scaling  inisoln()      
     directCPn()  - aatn()  
                  - c_atu()
     steplen()    - maxstep() 
                       upsol()      - zobk()
     tercon() & monot()
     optsol()

 Primal-dual affine scaling  inisoln()    
             directCPn()  - dualUn() 
          - c_atu()
                  - aatn()
     steplen()    - maxline()
                       upsol()      - zobk()
     tercon() & monot()
     optsol()

제 4 장. Choleski Factorization 
 4.1 Choleski Factorization Scheme 
내부점 선형계획법 알고리즘에서 가장 많은 시간을 차지하고 오차문제 등으로 어려움이 많은 부분이 최소 자승 문제와 관련된 역행렬 연산 루틴이다.  본 연구에서는 우선 직관적이고 이해하기 쉬운 Gaussian Elimination 방법을 사용하지만 수행도 향상을 위해서 Choleski factorization에 대해서도 논의해 보기로 하자.  
행렬 가 대칭 행렬이고 positive definite한 경우에 선회 연산(pivoting)없이 다음과 같은 분해가 가능하다.

  (16)

여기서 은 하삼각행렬이다.  
사실은 symmetric positive definite 행렬인 경우는 대칭적인 방법으로 Gaussian Elimination을 수행할 수도 있다.-Dahlquist와 Bj rck[1974]
Choleski factorization 알고리즘은 식 (16)에서 직접 유도되었는데-Winkinson[1965]- 다시 말하면 다음과 같은 관계가 있다.

  (17)

 행렬이 삼각행렬이라는 특성으로 인해서 위의 은 1 부터 나  중에 작은 것까지만 취하게 된다.  이런 성질을 이용하면 

  (18)

이 되고 
  (19)

이 된다.  이와 같이 계속하면 

  (20)

이면 우리는 다음과 같은 식을 얻을 수 있다.

  (21)

여기서 우리가 생각해 볼 것이 있는데 에 대해서 정의된 번째 열을 다음과 같이 생각해 볼 수 있다.

  (22)

위 식에서 대각원소는 이라고 둠으로써 쉽게 구할 수 있다.  식 (22)의 우변항은 의 번째 열과 행렬의 번째 열들로 계산이 가능하도록 되어 있다.
이 과정이 안정적이고 일 때, 즉 대각 원소일 때 식 (22)의 우변항이 양수라는 증명은 Nash[1990]과 Winkinson[1961]의 증명을 참고하기 바란다.

 4.2 Choleski Factorization 모듈
Choleski factorization을 구현하는 방법은 여러 가지가 있는데 1.5 절에서 제시한 방법을 이용하면 원행렬의 대칭성을 이용하여 원행렬의 하삼각행렬 부분만을 이용하여 Choleki factor 을 계산하게 되는데 그 열순서대로 계산이 되므로 현재의 번째 열을 계산하기 위해서는 원행렬의 번째 열과 이미 계산이 끝난 의 번째 이전 열들만 있으면 된다.  따라서 대칭적인 임의의 행렬에 대하여 이 기법을 직접 이용할 수 있다.  그리고 전산기 오차 측면에서도 우수한 방법으로 나타났다.  본 논문에서 실험한 기법 중에 원행렬로부터 행연산을 통하여 Choleski factor 을 도출해 내는 Givens rotation의 경우에는 연산 결과 0 으로 감소되어야 하는 행렬 요소가 전산기 오차로 인하여 0 이 되지 않고 의 값을 가지는 문제가 발생되어 해가 잘 나오지 않는 경우가 많았다.  그리고 처음부터 원행렬 전체를 가지고 행연산을 하게 되어 속도 면에서도 이득을 보지 못하는 것으로 나타났다. 
이러한 연구 결과를 통하여 범용 Choleski factorization 모듈을 개발하였다.  
그리고 1.5 절에서 제시한 factorization 방법에서는 임의의 열의 각 요소 중 대각 요소를 먼저 계산한 다음, 대각 요소 이하의 행렬 요소들을 계산하게 된다.  이 때 대각 요소 계산에는 자승근(square root) 연산과 관련되어 있고 비대각 요소계산에는 그렇지 않다. 

 cfactor  Choleski factorization 모듈    
 diaL  Choleski factor의 대각 요소 계산 모듈
 undiaL  Choleski factor의 비대각 요소 계산 모듈

위의 모듈 중에 임의의 번째 열을 계산하기 위해서는 diaL 모듈을 1 번, undiaL 모듈을  번 불리워지게 된다.  이와 같은 모듈들을 이용하여 Choleski factor 을 구한 다음에는 이것을 이용하여 원하는 벡터를 찾아내는 과정이 필요하다.
우리가 원하는 벡터를 라고 할 때 다음과 같은 형태의 식을 가지고 있다고 하자.

  (23)

위의 식 (23)에서  행렬은 m 차원 정방행렬이고 , 는 m 차원 벡터이다.  여기서 가 positive definite인 대칭행렬이라고 하면 행렬 는 다음과 같은 식으로 분해될 수 있다.  이와 같은 역할을 하는 것이 우리가 개발한 cfactor 모듈이다.

  (24)

위의 식 (24)을 식 (23)에 대입하면 식 (25)와 같이 된다.
 
  (25)

위의 식 (25)에서 라고 두면 식 (25)는 식 (26)가 된다.

  (26)

식 (26)는 전방 치환(forward substitution)을 의미하는 것으로 이 식에서  벡터를 구할 수 있다.  우리는 벡터 를 구해야 하므로 다음의 식이 의미하는 후방 치환(backward subtitution)을 통하여  벡터를 구한다.

  (27) 
 
이와 같은 식 (26)와 식 (27)의 과정을 구현하기 위한 모듈로 전방 치환 모듈과 후방 치환 모듈을 개발하였다.

 fsubst  전방 치환 모듈
 bsubst  후방 치환 모듈

본 절에서 제시한 모듈들의 원형은 체계적 모듈화의 일부로서 제시되었다.  이와 같은 루틴을 이용하면 내부점 선형계획법 뿐만 아니라 다른 수학 모델을 구현하는데도 이 Choleski factorization 모듈을 이용할 수 있을 것으로 기대된다.
 
 4.3 내부점 선형계획법과 Choleski Factorization 
본 논문에서 개발한 통합 내부점 선형계획법 프로그램을 수행시켜본 결과 Choleski factorization이 Gaussian elimination보다 우수한 것으로 나타났다.  이러한 결과는 많은 사람들에 의해 밝혀졌었는데 내부점 선형계획법의 수행도에 기여하는 정도는 다음과 같이 나타났다.  이 수행 비교는 다음에 나올 5.3절에서 다시 다룰 것이지만 primal affine scaling과 dual affine scaling에 대해서 본 절에서 수행도를 비교해 보면 다음과 같다.  
각 실험의 명세는 다음과 같다.

 EXP1  Projective algorithm, Gaussian elimination
 EXP2  Primal affine scaling algorithm, Gaussian elimination
 EXP3  Dual affine scaling algorithm, Gaussian elimination
 EXP4  Primal-dual affine scaling algorithm, Gaussian elimination
 EXP5  Projective algorithm,  Choleski factorization
 EXP6  Primal affine scaling algorithm, Choleski factorization
 EXP7  Dual affine scaling algorithm, Choleski factorization
 EXP8  Primal-dual affine scaling algorithm, Choleski factorization




위 실험 결과를 보면 Choleski factorization의 수행 속도가 Gaussian elimination보다 빠르다는 사실을 알 수 있다.  뿐만 아니라 Choleski factorization을 이용했을 때가 Gaussian elimination을 이용했을 때보다 반복 횟수도 작은 것을 생각하면 안정성도 Choleski factorization이 더 우수한 것으로 나타났다.


제 5 장. 수행 상의 고찰 
 5.1 수행 문제  및 수행 기종
본 연구에서 개발된 프로그램들을 실험할 문제들은 통칭 NETLIB PROBLEM 이라고 불리는 것들인데 보통 실험에 사용되는 랜덤 생성한 문제가 아니라 사람이 직접 실제 사례를 모델링한 문제들이다.  이 문제들은 Gay[1985]가 모두 해를 구해서 발표한 것들로 public domain에 공개되어 있다.  많은 사람들이 이 문제들을 자신의 알고리즘을 실험하는 지표로 삼고 있다.  본 연구도 비교를 위하여 이들 문제들을 이용하였다.
본 논문의 실험사용된 기종에 대한 명세는 다음과 같다.

 모델명 : HP-Series 700 workstation Model 730
 Processor : 64 bit Super Scalar PA-RISC   Clock Speed : 66 Mhz   
      MIPS : 76     RAM : 32 MB     운영 체제 : HP-UX


 5.2 Ill-conditionning 
본 연구에서 개발한 자료 구조를 기반으로 통합 내부점 선형계획법 프로그램을 개발하는 과정에서 연산 중간에 해를 찾지 못하는 경우가 발생하였는데 특히 Gaussian elimination 기법을 이용하여 역행렬을 구할 때 대각 요소는 0이 될 수 없음에도 불구하고 0으로 접근하는 경우가 자주 발생하였다.  이것은 행렬이 점점 ill-conditioning되는 경우가 발생한다고 고찰되었기 때문에 그 정도를 조사해 보았다.   행렬의 ill-conditioning은 행렬의 대각 요소가 0으로 접근하게 되고 이것이 행렬을 특이행렬로 만들기 때문에 발생한다.  이것은 특히 퇴화문제에서 더 자주 발생하는 것으로 관찰되었다.
본 연구에서 개발한 프로그램이 특정한 각 문제별 대각 요소의 최대값과 최소값을 다음 표에 나타내었다. 【 표 21 】에 나타나 있는 수치의 단위는 10의 지수이다.  즉, afiro의 초기 단계 시, 대각 요소값의 범위는 에 존재한다는 뜻이다.




위의 【 표 22 】에 나타나 있는 것은 알고리즘이 시작할 초기 단계의 것과 최적 단계의 것이 나타나 있는데 각 반복마다 조사해 보면 점점 그 범위가 넓어지는 것으로 나타났다.  이런 문제가 발생하는 제약식에 대해서는 제거를 하는 방법이 포함되어야 할 것으로 보인다.  위의 결과는 내부점 선형계획법 프로그램을 오차 제어와 안정화시키는데도 많은 연구가 필요한 것을 보여준다.  위의 표와 같은 현상은 Choleski factorization에서도 일어나고 있다.
 5.3 내부점 선형계획법의 우열 실험 
본 연구에서는 주어진 자료 구조를 이용하여 projective algorithm과 affine scaling algorithm을 통합하는 프로그램을 개발하였다.  그리고 내부점 선형계획법 프로그램에서 가장 많은 시간을 차지하는 역행렬 계산 루틴을 Gaussian elimination과 Choleski factorization을 이용할 수 있도록 개발하였다.
이들 기법 간에는 많은 장단점이 있으나 각 문제에 따라 몇 번의 반복만에 최적해를 찾고 얼마만한 시간이 소요됨을 알아보는 것은 내부점 선형계획법에 대한 전반적인 시각을 높여 줄 수 있을 것으로 생각된다.  그리고 오차 문제에 대한 고려가 되지 못했기 때문에 해의 가해성을 잃지 않게 하기 위해서 개선 반경 의 값을 0.3, 0.6에 대해서 실험을 해 보았다.  
각 실험에 대한 명세는 다음과 같다.

 EXP1  Projective algorithm, Gaussian elimination
 EXP2  Primal affine scaling algorithm, Gaussian elimination
 EXP3  Dual affine scaling algorithm, Gaussian elimination
 EXP4  Primal-dual affine scaling algorithm, Gaussian elimination
 EXP5  Projective algorithm,  Choleski factorization
 EXP6  Primal affine scaling algorithm, Choleski factorization
 EXP7  Dual affine scaling algorithm, Choleski factorization
 EXP8  Primal-dual affine scaling algorithm, Choleski factorization







  



여기서 "*" 표시는 대칭행렬 의 대각 요소가 0 으로 접근함으로 인해서 문제의 해를 내지 못하고 빠져 나온 경우로 그때까지의 시간이 나와 있다.  이를 보면 상당한 개선이 이루어진 다음에 ill-conditioning의 영향을 받는다는 사실을 알 수 있다.  "#" 표시도 "*" 표시와 비슷한 역할을 하는데 Choleski factorization에서 행렬이 positive definite이라는 사실을 보장하기 위해서는 대각 요소가 항상 양이어야 하는데 오차문제로 인하여 음으로 접근하게 되는 경우로 그때까지의 시간이 나와 있다.  위의 표에서는 projective algorithm에 대한 실험이 빠져 있다.  다음과 같은 이유로 EXP1과 EXP5는 실험에 넣기가 곤란했다.
Projective algorithm의 실험에는 특수한 변수 가 필요한데 이 변수와 문제와의 관계는 다음과 같다.

  (28)

이것은 해의 도출에 큰 영향을 미치는 것으로 나타났다.  이론적으로는 문제의 크기를 이라고 할 때 컴퓨터의 유효자리 수가 자리까지 처리가 가능하다고 하면 이 변수는 이면 된다.
  (29)

즉, 충분히 큰 수를 지정해 주면 되는데 현재 이용가능한 컴퓨터의 정밀도는 이것에 훨씬 못 미친다.  따라서, 가능한한 값을 작게 지정하는 것이 문제의 정밀도를 잃지 않는 방법이다.  

위의 실험 결과들을 살펴 보면 우선 Choleski factorization이 Gaussian elimination보다 우수하다는 것을 알 수 있다.  그리고 4 가지 기법 중에 dual affine scaling이 가장 우수한 것으로 나타났다. 


제 6 장. 결론
선형계획법에 대한 그간의 연구가 이론적인 면에서 복잡도를 낮추기 위한 많은 연구가 있었다.  본 연구는 이와는 다른 시각으로 즉, 실용적인 측면에서 선형계획법에 대한 연구를 수행하였는데 다항식 시간의 복잡도를 가지는 내부점 선형계획법의 많은 알고리즘을 고찰하였다.  고찰 결과, 이들 기법들이 공통된 단계를 거쳐 최적해를 도출해 나간다는 점에 이용하여 여러 기법이 공통적으로 이용할 수 있는 모듈들을 설계하고 이들을 이용하는 통합 내부점 선형계획법 프로그램을 개발하였다.  이 프로그램은 기존의 연구 분야들을 분류하여 앞으로의 연구 수행에 일조할 수 있는 방향으로 체계적인 모듈화를 하였으며 일반적인 선형계획법 문제의 성질인 희소도를 활용하기 위해서 비영 요소만을 보관하는 자료 구조를 설계하여 통합 내부점 선형계획법 프로그램에 이용하였다.  본 연구에서 설계한 자료 구조는 모든 기법에서 효율적으로 이용되었으며 앞으로의 개선 방향에도 잘 부합할 것으로 기대된다.  내부점 선형계획법들은 자신의 알고리즘에 맞는 기본형과 개선방향 등을 가지고 있는데 이들 간의 우열 비교에서 dual affine scaling 기법이 가장 우수한 것으로 나타났으며 Gaussian elimination보다는 Choleski factorization이 수행속도 면에서나 안정성 면에서 뛰어나다는 사실을 알아냈다.

본 논문과 관련되어 개발된 통합 내부점 선형계획법 프로그램인 LPKAB이 개선될 방향과 이와 관련되어 연구되어야 할 방향을 제시하면 다음과 같다.

● 통합 내부점 선형계획법 프로그램인 LPKAB은 아직 barrier algorithm을 통합하지 못하였다.  barrier algorithm도 barrier function이 포함되는 것만을 고려하면 같은 모듈들을 이용하여 개발이 가능할 것으로 보인다.

● 통합 내부점 선형계획법 프로그램인 LPKAB은 생성되는 비영 요소(fill-in)를 낮출 수 있는 ordering scheme이 포함되지 못하였다.  Ordering scheme이 적절하게 사용되면 본 연구에서 제시한 자료 구조의 효율을 더 높아질 것이고 수행도도 향상될 것이다.

● 통합 내부점 선형계획법 프로그램인 LPKAB은 오차 문제를 고려하지 못하여 최적해를 찾지 못하고 원다면체(original polytope)를 변형하는 현상을 일으켰다.  적절한 오차 교정 모듈이 개발되어야 할 것이다.

● 통합 내부점 선형계획법 프로그램인 LPKAB은 한 반복에 전체 역행렬을 연산하는 과정이 있기 때문에 많은 시간이 소요된다.  이를 해결하기 위해서는 inexact matrix를 이용한 근사 개선 방향을 찾는 방법과 근사 기준에 대한 체계적인 연구가 필요하다.  LPKAB에는 이미 rank-one update 루틴이 포함되어 있지만 근사 기준에 대한 연구가 부족하여 그 효율을 실험해 보지 못하였다.

● 본 논문의 실험에서 각 기법들이 초기해를 찾는 제 1 국면에서 많은 시간과 반복 횟수를 소요하는 것으로 나타났다.  이에 각 기법의 기본형을 유지하면서 초기해를 좀더 빠르게 찾는 방법에 대한 연구가 필요하다.


</tdmsfiletext>
