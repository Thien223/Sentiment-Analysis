<language> Korean </language>
<textcode> KSC-5601-1988 </textcode>
<process> raw </process>
<version> 2001(or)</version>
<filename> kaistcorpus_written_raw_or_academic_paper96_tee.txt </filename>
<title> 상하 분해법의 효율 분석과 효율 제고의 비교 실험적 연구 </title>
<author> 이장원 </author>
<date> 1994 </date>
<publisher> 서울대학교 </publisher>
<kdc> TM530.967 </kdc>
<tdmsfiletext>
              초   록

본논문의 목적은, 단체법 프로그램중 상하분해법을 사용하는 전산 프로그램의 효율를 자료구조, 재역산 시기, 해수정의 개선을 통해 재고하는데 있다. 이 논문에서 다룬 상하분해법은 BARTELS-GOLUB, FORREST-TOMLIN, CHOLESKY 방법이다.
첫째, 상삼각행렬과 하삼각행렬의 자료구조는 비영요소 보관을 근간으로 설계되었다. 특히, 하삼각 eta배열의 비영요소보관에의한 수행시간 감소율은 20%이였다.
둘째, 재역산 기준은 계수행렬의  행수와 밀도를 기준으로 하삼각 eta배열의 크기의 한계를 정하는 것으로 정하였다.
셋째, 본 논문의 자료구조를 채택한 프로그램의 수행시간은 FORREST-TOMLIN방법이 우수하였다.
네째, 해수정은 전통적인 상하분해법의 해수정방법인 substitution방법과 해의 변동분만을 고려하는 방법을 상하분해형에 적용시켜 이 두 방법의 수행시간을 비교하였다. 후자가 연산 속도와 횟수면에서 우수하였으며, 이로인해 5%이상의 수행시간 감소효가가 나타났다.

주요어 : 상하분해법, BARTELS-GOLUB방법, FORREST-TOMLIN방법, CHOLESKY 방법
         자료 구조, 재역산기준, 해수정

        


I.서   론 

I.1  연구의 목적 
           
선형계획법중에서 단체법의 전산 프로그램 수행시 기저행렬의 보관방법은 프로그램의 실행속도, 메모리 소요, 그리고 수치적 안정성에 많은 영향을 미친다. 이러한 맥락에서, 기저행렬 보관 방법의 한 분야인 상하 분해법의 여러기법들에 알맞은 자료구조 연구와 이의 효율성을 실험을 통해 살펴보고, 재역산 시기 결정, 해수정에서의 개선안들이 상하 분해법의 여러기법에서 어떤 영향을 끼치는 지를 알아 보고자 한다.

I.2  연구의 동기  

역사적으로, 상하분해형은 적산형으로 부터 진화한 형태이다. Markowitzs는 재역산에서는 상하분해형을 단체법의 단계에서는 적산형을 사용했다.
Bartels-Golub은 단체법의 단계에서도 상하분해형을 수정시키는 기법을 발견하였으며, Forrest-Tomlin은 실험적으로, 희박행렬에서 비영 요소의 진입을 막는 효률적인 기법을 제시했다.
 이러한 상하분해법으로에의 이행은 상하분해법이 일반적으로 희박성에대한 잇점이 있기때문이다.즉, 수치적 안정, 비영요소 진입의 제어, 빠른 BTRAN, FTRAN이라는 장점을 갖고 있다.
그러나, 많은 이론적인 논문에도 불구하고 각 상하 분해법에 맞는  특정한 자료구조와 이의 전산 프로그램화에 대한 논문은 전자에 미치지 못한다. 이러한 관점에서 이 논문의 동기는, 각 기법에 맞는 자료구조와 이를 전산 프러그램화할때 발생하는 문제점과 제고점을 찾아 발전적인 단체법 프로그램을 만들어 보자는 데 있다.

I.3  연구의 기대 효과 

이 연구의 결과로 실제 선형계획문제를 풀 때 각 상하 분해형의 좀 더효과적인 전산 프로그래밍이 가능하게되어 수행 속도의 감소를 가져올 수 있고, 부 프로그램의 구조화로 각 기법의 비교, 개발이 용이 해질 것이다.

II.  연구 현황 

실제 선형계획 문제는 대부분 크기가 크고 비영요소가 적은 희박행렬의 경우이므로, 단체법에서 이를 푸는 가장 효과적인 메모리와 수행시간을 가지는 상하분해법의 연구는 많은 발전을 해왔다. 그 중에 많이 알려진 것은 Bartels-Golub방법, Forrest-Tomlin방법, Cholesky방법, QR 분해 등이다. 각 기법들은 초기연구를 거쳐, 각 기법의 단점을 보완하는 형태의 변형들이 발표되었다. 이는 대부분 비영요소의 제어와 수치적 안정, 기억소요의 절감등을 주요내용으로 하고 있다.

II.1  상하 분해법에 관한 연구   

각 기법들에 관한 연구는 Bartels-Golub(1969), Tomlin(1970), Beale(1971), de Buchet(1971), Carre(1971), Forrest-Tomlin(1972) Saunders(1972) 등의  초기 연구가 있었다. Bartels-Golub은 단체법의 단계에서도 상하분해형을 수정시키는 기법을 발견하였으며 이는 수치적 안정성도 고려된 형태였다. Forrest-Tomlin은 한 행을 기본 행 연산으로 소거시켜, 실험적으로, 희박행렬에서 비영 요소의 진입을 막는 효률적인 기법을 제시했다. Saunders(1972)는 선형계획법에서 Cholesky법을 이용한 기저유지기법을 연구하였다.
초기 연구 이후 각 방법의 단점을 보안하는 알고리듬이 발표되었는데 연구의 주요 주재는 기저 행열에 비영요소가 새로 진입하는 것을 방지하는 것과 계산 오차를 줄이는 것으로 요약 된다.
 Saunders(1976)는 Bartels-Golub Updating동안 대부분의 상삼각 행렬과 하삼각행렬을 디스크에 보관할 수 있는 방법을 제시하였다.  
J.K.Reid(1975),J.K.Reid(1982)는 Bartels-Golub Updating 시에 행과 열을 재배열시키는 방법을 제시하였다. 이는 Fill-in에 대한 고려가 없는 Bartels-Golub 방법의 단점을 보안한 것으로 한 행이 수정돤 기저행열을 Bump 가 최소화되도록 재배열함으로써 기존 행들간의 연산을 지양하는  방법이다.

II.2  재역산에 관한 연구 

재역산의 방법 역시 비영요소 진입억제와 수치적 안정에 목표를 두고 있으며, 기저의 재정렬방법이 많은 성과가 있다고 발표 되었다.
 Markowitz(1957),Larsen(1962)는 재역산에 상하분해형을 도입하였으며 희박성을 고려하여 선회요소를 선택하는 Mrkowitz Pivot Rule을 제시하였다. 이 방법은 각 선회 요소의 행의 비영요소와 열의 비영요소의 곱이 최소인 것을 선택하는 방법이다. 이 값은 한번의 Pivot Step에서 발생할 수 있는 Fill-in의 상한이다.
 Hellerman-Rarick(1971),(1972) 은  재역산 대상인 기저행렬을 상삼각 행렬에 가깝게 재정렬시키는 방법이다. 이는 두 국면으로 구성되며, 국면 1 은 borded block lower triangular form으로 전환하고 국면 2 는 대각선상의 spike를 줄여 나가는 발견적 기법으로 구성된다.
Erisman-Grimes-Lewis-Poole(1985)의 연구는 P4 의 수치적으로 안정된 형태이다. 그러나, 아직 특수한 형태에 대해서는 수치적 안정성이 완전이 보증이 되지 않는다.
본 연구에서는 상하분해법 중에서 Bartels-Golub방법, Forrest-Tomlin방법, Cholesky방법을 연구 대상으로 한다.

II.3  LP에 사용된 상하 분해법   

이 논문은 상하 분해법중 Bartels-Golub법, Forrest-Tomlin법, Cholesky법을 다루고있으며, 이들 기법은 다음의 두 가지 방향에서 simplex LP solver로 구현되고 있다.

① 주어진 행렬에 대해 상하분해를 게산하는 방법. 즉, LU = PBQ를 계산하는 것이다.( 단,B는 현 기저의 벡터집합으로 이루어 지는 m x m 행렬이다. L과 U는 각각 하삼각 행렬과 상삼각 행렬이다. ) 대부분 L과 U는 명시적으로 보관되지 않고, 각각 상삼각과 하삼각 기본 행렬의 곱으로 저장된다.

② 기저로 부터 한 벡터가 탈락되고, 다른 또 하나의 벡터가 진입할때, 즉 simplex의 매 회 마다 상하분해를 추가 수정하는 방법이다. 대부분 추가수정은, 변형된 U의 상삼각을 유지하기위해 L에  elementary row operation들이 추가되는 것을 요구한다.

 이 논문에서 사용된 상하분해 프로그램은 위의 두번째 경향인, simplex의 매 회 마다 상하분해를 추가 수정하는 방법을 바탕으로 작성된 프로그램이다.



II.3.1  Bartels-Golub 방법 

1) 기저 수정방법
이 방법은 spike된 부분을 뒷 Column으로 Permutation하고 대각선아래의 원소들을 Elementary Row Operation으로 0으로 만드 는 방법을 사용한다.
지금 
   
    단, Bi는 B의 i열

이라고 하자. 여기서 Br과 A.s와 교환하고자 한다. 이 때는 다음과 같이 U와 L을 수정한다. 
    r ; 탈락변수의 지수, s ; 진입변수의 지수.
    
    
         
 행렬의 r째열을 맨끝으로 옮긴다.
        
    이 행렬에 아래의 M을 차래로 곱해 대각선 아래 원소를 차래로 0으로 만 
    든다.


     단,
     
     단,  이면

     
                                             
          이면
     
    

     단,    :   행렬의 r행, r+1렬 원소
          :   행렬의 r+1행, r+1렬 원소 
 실재 프로그램에서는,  를 행렬형태로 보관하지 않고,은 row index 보관 배열, 곱해지는 scalar인  는 실수배열에 보관하였다. 



II.3.2  Forrest-Tomlin 방법 

1) 기저 수정방법

이 방법은 spike된 부분을 뒷 Column으로 Permutation하고 선회행을 Elementary Row Operation으로 0으로 만든 후 그 아래행들을  1 행위로 Permutation하는 방법을 사용한다.

지금 
   
    단, Bi는 B의 i열

이라고 하자. 여기서 Br과 A.s와 교환하고자 한다. 이 때는 다음과 같이 U와 L을 수정한다. 
    r ; 탈락변수의 지수, s ; 진입변수의 지수.
    
    
         
 행렬의 r째열을 맨끝으로 옮긴다.
        
    이 행렬에 아래의 M을 차래로 곱해 대각선 아래 원소를 차래로 0으로 만 
    든다.

     단,
     


     
                                             
     단,    :   행렬의 p행, p+r+1렬 원소
          :   행렬의 p+r+1행,P+r+1렬 원소 
    p : 선회행
 그다음, 선회행 아래행의 한행씩 위로 옮긴다. 
 실재 프로그램에서는,  를 행렬형태로 보관하지 않고,은 row index 보관 배열, 곱해지는 scalar인  는 실수배열에 보관하였다. 


II.3.3  Cholesky 방법 

Cholesky 방법을 이용한 행렬 factorizatiuon방법에는 Givens 행렬, Householder matrix를 이용하는 방법이 있다.

  1) Givens 행렬을 이용한 Cholesky factor의 수정
     Column vector Y가 주어졌을 때 아래와 같은 행렬 Pij을 Givens                matrix라 한다.

           
         i  j, yj  0을 만족하는 i, j에 대해
       r =  , c = yi / r , s = yj / r


          1      i         j              m
        +--------+--------+----------------+
       1| 1      |        |                |
        |      1 |        |                |
       i         c         s
        +-------   ------   ---------------+
Pij =  
        |        |        |                |
       j         s        -c
        +-------   ------    --------------+
        |        |        | 1              |
        |        |        |                |
        |        |        |                |
        |        |        |              1 |
      m
        +--------+--------+----------------+

        ( 단위 행렬에서 (i, i) 요소는 c로 (j, j) 요소는 -c로
          (i, j) 요소와 (j, i) 요소는 s로 바꾼 행렬이다.)

     Pij는 직교 행렬이며 j번째 요소를 0으로 만든다. 즉 

    Pij Y = (yi, …, , r, , …, , 0, , …, ym)

     따라서 주어진 기저행렬 B에 Pij를 차례로 곱하면 최종적인 행렬은 상            삼각 행렬이 된다. 이 상삼각행렬의 전치 행렬이 기저에 대한                    Cholesky factor 가 된다.

  2) Householder matrix를 이용한 Cholesky factor의 수정

    다음과 같은 열벡터 Y 가 주어졌을 때 아래와 같은 행렬  을      Householder 행렬이라 한다.

       ,

   이 벡터의 아래 (m-l-1)개의 요소들은  을 좌측에 곱함으로써 0     으로 만들수 있다.

                            1  . . . l  l+1  . . . .  m
                          +-----------+----------------+
                        1 |           |                |
                        . |     I     |       0        |
                        . |           |                |
                        l +-----------+----------------+
                 =  l+1|             |                  |
                        . |           |                |
                        . |     0     |   I -    |
                        . |           |                |
                        m |           |                |
                          +-----------+----------------+

               단,
                   ,
                    ,
                    ,
                    ,
                    ,
                   
                              ,

   이 Householder 행렬을 벡터 Y의 왼쪽에 곱하면

          

   가 된다.

   이 방법은  에서 시작하여 m-2 단계까지 수행한다.

이 논문에서는 Givens 행렬을 이용한 프로그램을 작성하였으며,       또한, 기저의 열벡터가 변할때  Cholesky factor를 변한 렬만 수정하는 방법( Column Induction method )을 사용하였다. 그 과정은 다음과 같다.

   지금,
         A r → 탈락열
    A s → 진입열
          → A r을 제거하고 난 뒤의 행렬 B에 대한 Cholesky factor 라 두
         자.

        STEP 1.  구하기

         LP = A r을 푼 후 행렬 F를 구한다.

     

      F의 Givens 행렬 를 j = m+1 to 2의 순서로 행렬 F의 좌측에        곱하면 다음과 같은 행렬이 만들어진다. 여기서 는                   의  Givens 행렬로 구해진다.

    

         STEP 2. Updating Cholesky Factor

      위에서 구한 를 이용하여 행렬 E를 만든다.

    

     E의 Givens 행렬 를 i = 1 to m의 순서로 행렬 E의 좌측에        곱하면 다음과 같은 행렬이 만들어진다. 는 의       Givens 행렬로 구해진다.

    

      여기서 구한 L이 새로운 기저 의 Cholesky factor가 된다.

III.  연구 내용 

III.1  자료구조 설계

상하분해법을 이용한 선형 계획 프로그램에서 메모리가 가장 많이 필요한 부분은 행렬 계수 A와 기저 행렬의 상삼각행렬 와 하삼각행열의 보관이다. 따라서, 같은 조건에서 더 큰 문제를 풀기 위해서, 또 더 빠르게 풀기위해서 이 자료들의 자료 구조에 대한 연구가 필요하다. 
이러한 맥락에서, 이 논문에서 제시된 자료구조는 0인 요소들을 보관하지 않는 자료구조를 기본 개념으로 하고 있다. 이는 다음과 같은 두 가지 잇점을 보장하기때문이다.

① 메모리 절약
대부분의 LP SOLVER가 대상으로하는 문제들은 sparcity가 높다. 즉, 대부분의 행렬 원소들은 0이며 이를 모두 보관하는 경우에는 그 만큼 더 많은 기억공간을 소요하게 된다. 상 삼각행렬의 경우, 비영요소 보관의 경우 기억공간소요는 비영요소와 행의 수에 비례하는데 반해 모든 요소 보관의 경우 행의 수의 제곱에 비례한다. 
② 계산시간 감소
대상 문제의 sparcity가 높을수록 계산 루틴의 효율화가 필요하다. 단체법의 수행은 동일한 루틴들의 반복을 의미하며, 그중 평가벡터의 계산( BTRAN ),할인( CCBAR ), 진입열의 수정( FTRAN )등은 많은 벡터 내적을 포함한다. 그외에도 대부분의 연산들이 벡터 내적을 기본으로 한다. 그런데 비영 요소만을 보관하기 위한 자료 구조가 영인 요소들을 내적 계산 과정에서 제외하므로 계산 효율이 증가된다.
비영요소까지 포함하여 모두 보관하는 입력자료의 보관 방법은 행렬계수의 경우는 메모리의 낭비, 기저의 상,하삼각행렬의 경우는 계산 수행시간의 낭비의 중요한 원인이 된다. 
따라서, 이 자료들을 비영요소들만 보관하여 시간과 메모리의 효율을 높이고자 한다.

III.1.1 모든요소 보관의 자료구조

1) 계수행렬 A의 보관

계수행렬 A의 모든요소 보관에는 가로, 세로 각각 행수만큼의 크기를 가지는 matrix형 구조가 필요하다.이를 그림으로 표시하면 다음과 같다.

           
           ( 단, m은 행의 갯수 )
이러한 자료구조는 이래와 깉은 장,단점을 가진다.
a. 장점
① 이해하기 쉽다. ② OVER-HEAD MEMORY가 필요하지 않다.즉, 직접 A를 보관하고 있는 메모리 외의 메모리를 필요로 하지안타는 의미이며, density가 100%에가까우면, 더효율적인 자료구조가 된다. ③ density가 높을 때 계산효율이 가장 우수하다. 위에서 언급한 OVER-HEAD MEMORY의 운용에 필요한 계산 routine를 생략할 수 있기 때문이다.
b. 단점
① 행렬밀도가 낮을 때 메모리 낭비가 많다. 이 경우엔, 실제 계산에 필요한 비영요소는 적고 대부분 영요소이기 때문에 이를 보관하는데 많은 메모리를 소요하게된다.
② 행렬밀도가 낮을 때 계산효율이 저하된다. 영요소까지 모두 처리하므로, 계산의 낭비가 생긴다.

2) 상삼각 행렬 BU의 보관

상삼각행렬 BU의 모든요소 보관에는 가로, 세로 각각 행수만큼의 크기를 가지는 uppertriangular matrix형 구조가 필요하다.이를 그림으로 표시하면 다음과 같다.
   
  ( 단, m은 행의 갯수 )
이러한 자료구조는 이래와 깉은 장,단점을 가진다.
a. 장점
① OVER-HEAD MEMORY가 필요하지 않다.
② density가 높을 때 계산효율이 가장 우수하다. 특히, LU factorization 형태의 프로그램에서는 복잡한 행렬연산을 시행을 필요로 하므로, density가 높을 때는 point 배열의 운용에 필요한 계산이 과중하게 소요된다. 
b. 단점
① 행렬밀도가 낮을 때 메모리 낭비가 많다. 
② 행렬밀도가 낮을 때, 영요소까지 모두 처리하므로, 계산의 낭비가 생긴다.

3) 하삼각 행렬 BL의 보관

하삼각행렬 BL은 elememtary row opration을 나타내는 eta file이므로, elememtary row opration이 행해지는 행번호와 곱해지는 scalar를 보관하여야한다. 이는 모든 요소보관시에는 각각 정수형, 실수형(단정도, 배정도) 1차 배열에 저장된다.
하삼각행렬의 모든 요소 보관의 자료 구조는 다음과 같다.
 : 일차원 행렬로  또는 
            값을 보관한다. 변수의 
 : 일차원 행렬로 에 따른 행의 첨수를 보관한다.
           변수의 형태는 정수이다.

이를 그림으로 표시하면 다음과 같다.
  ( 단, m은 최대 BL의 갯수 )

elememtary row opration때 곱해지는 scalar
   |---- 각각 대응관계이다.
elememtary row opration이 행해지는 행번호   


III.1.2 계수 행렬 A의 비영요소보관 자료구조

  0인 요소들을 보관하지 않으면서 계수 행렬의 정보를 유지하려면 행번호,열번호를 각 비영요소들마다 아는 것이 필요하다. 이러한 정보는 비영요소 보관위한 위한 기본 정보의 구성요인 되고, 비영요소보관의 자료구조를 설계하기 위해선 A행렬의 참조 형태와 수정 여부를 알아야 한다. A에 관계된연산을 보면 다음과 같다.

1) 관계 연산
a. 열참조
  : bartels-golgub, forrest-tomlin method
     : cholesky method

    : bartels-golgub, forrest-tomlin method

2) 자료구조 설계

위의 관계연산에서 알 수있듯이 계수행렬의 참조는 열참조가 주로 사용된다. 그러므로, A행렬의 보관은 열위주 행번호 리스트(columnwise row index list)가 적당하다. 이를 위하여 하나 정수배열 COLI이 각 열들의 시작 주소를 보관하고 또 하나 정수배열 CLN이 각 열들의 비영 요소의 갯수를 보관하여, 이 주소를 시작점으로하여 그 열의 배열을 보관한다. 그리고 또 하나의 실수 배열 AN과 정수 배열 RN 으로 열의 비영요소의 값과 행번호를 보관하되 행번호들의 순서는 같은 열의 낮은 행이 높은 행보다 배열의 앞쪽에 있도록 한다. 
 자료를 다음 배열에 보관한다.

 float  AN[MAXA]    : 실제 비영 요소의 값 기억
 int    RN[MAXA]    : 비영 요소의 행 번호 기억
 int    COLI[MAXC]  : i번째 열의 AN[],RN[]배열에서의 시작 주소
 int    CLN[MAXC]   : i번째 열의 비영 요소의 갯수


 



III.1.3 상삼각행렬 B의 비영요소보관 자료구조

BU는 단체법 수행에서 가장 많이 계산(대개 벡터 내적 형태로)에 사용되므로, 이 BU의 자료 구조가 단체법 전체의 효율에 가장 큰 영향을 미친다. 그리고, 단체법을 구현한 많은 프로그램들이 초기 기저 변수로 인공 변수들을 선택하므로 초기 기저는 이 경우 대각 행렬이 되고, 이 초기 BU는 회수가 진행되면서 점점 비영 요소가 증가하게 된다. 

1) 관계연산

a. 행참조    
  : bartels-golgub, forrest-tomlin method
    : cholesky method
  : bartels-golgub, forrest-tomlin method
    : cholesky method
b. 열참조    
  : bartels-golgub, forrest-tomlin method
     : cholesky method
c. 기타관련연산 :
batels-golub : r행-r+1간 교환, 열이동, 
               elmentary row operation
forrest-tomlin:r행-r+i간 교환, 열이동, 
               elmentary row operation
cholesky : elmentary row operation

2) 자료구조설계 

위의 관련 연산에서도 알수있듯이, 단체법 수행시 BU는 행참조와 열참조 두가지 형태로 모두 사용된다. 그리고 매 회 비영 요소가 바뀔 수 있다. 즉, 현재  0이어서 리스트에 없는 BU의 요소가 비영요소가 될 수 있고, 반대로 비영요소가 0으로 바뀌어 새로 추가될 수도 있다. 따라서, 행렬계수와는 달리 이차원 연결 구조(2-dimensional linked list)의 리스트가 필요하다. 그래서 각각의 비영요소에 대해 행, 열, 비영요소 값, 행포인터, 열 포인터를 보관하여야 한다. 
여기서 행,열의 비영요소 값은 각각 비영요소의 실제 행,열, 비영요소값을 보관하고, 행 포인터는 같은 행내에서 다음 비영요소의  주소를 보관하며, 열 포인터는 열내에서의 다음 비영요소의 주소를 보관한다. 만약, 행이나 열의 끝이라면 해당 포인터는 끝을 알리는 특수한 값을 보관한다. 계산시에는 행,열 시작주소 보관 배열과 포인터를 이용해 해당 벡터를 사용할 수 있다. 
프로그램에서 사용한 실제 배열은 다음과 같다.  
만약, BU의 최대 비영 요소가 MAXBU, 행수가 MAXR이라면

   float BUN[MAXBU]     : BU의 비영 요소 보관
   int   ROCOL[2][MAXBU] : BU의 비영 요소들의 행번호(0),열번호(1) 
            보관  예로써 ROCOL[1][5]는 BUN[5]의 열 번호를 가르킴.
   int   RCNEX[2][MAXBU] : BU의 행(0),열(0)의 다음 비영 요소들의 
         BUN번호  예로써 RCNEX[0][5]는 같은 행에서 BUN[5]의 다          
         음 비영요소의 행번호를 가르킴. 
   int   RCINI[2][MAXR]  : 각 행(0),열(1)들의 시작 BUN의번호
         예로써 RCINI[0][5]는제5행의 최초 BUN의 주소를 가르킴.




III.1.4 하삼각행렬 L의 비영요소보관 자료구조

하삼각행렬 BL은 수정된 상삼각 행렬의 삼각성을 유지하기위해 행하는elememtary row opration을 나타내는 eta file이므로, elememtary row opration이 행해지는 행번호와 곱해지는 scalar를 보관하여야한다. 이를 위해 모든 요소보관시에는 각각 정수형, 실수형(단정도, 배정도) 1차 배열에 저장하였으나, 실제 density가 낮은 문제에서는 행번호 보관행렬은 탈락렬에서 부터 순차적이고, scalar보관 행렬은 대부분 영요소가 된다.
따라서, scalar보관행렬은 scalar가 비영일때보관하고, 행번호 보관행렬은 이에 대응하는 경우만 보관하면 된다.
이를 그림으로 표시하면 다음과 같다.

  ( 단, m은 최대 BL의 갯수 )

elememtary row opration이 행해지는 행번호   
   |--> 각각 대응관계이다.
elememtary row opration때 곱해지는 scalar

    LINI[m]
: k회 첨가된 eta의 BL1[],BL2[]에서의 시작번지
    LN[m]
: k회 첨가된 eta의 갯수
    LNR[m]
: k회 탈락렬 번호
 cholesky method에서는  로 분해하기때문에 를 로 표현했으므로, 을 따로 보관할 필요가 없다.

III.1.5  소요 기억 공간 분석

  비영요소를 보관하는 자료 구조의 각 요소별 메모리 필요량이 행렬계수의 비영요소 갯수를 MAXA, 상삼각행렬의 최대 비영요소 갯수를 MAXBU,eta vector의 최대 갯수를 MAXL, 행의 수를 MAXR, 열의 수를 MAXC라 할 경우 다음과 같다.

각 배열별 메모리 필요량


( 위 표에서 f는 실수 한개, i는 정수 한개를 보관하는데 필요한 
  메모리 량) 


III.2  자료구조의 효율성 실험

자료구조는 그것을 채택한 프로그램의 기억공간소요량과 연산수행회수를 결정하는 중요한요인이 된다. 그러므로, 이 절에서는 위에서 설계한 자료구조들이 얼마만큼의 연산수행횟수를 감소시키는 지를 총수행시간의 측정을 통해 알아보고자 한다.
  
III.2.1 BARTEL-GOLUB 방법 
1)실험 1 : BU 비영요소 보관방법,BU BL 비영요소 보관방법의 수행시간비교
  ① DATA : NETLIB DATA
  ② 실험 도구  
        BU 비영요소 보관방법 : LPLUB32.c unix version
        BU BL 비영요소 보관방법 : LPLUB40.c unix version
  ③ 실험기기
       삼성 workstation
  ④ 결과 분석



III.2.2 FORREST-TOMLIN 방법
1)실험 1 : BU 비영요소 보관방법,BU BL 비영요소 보관방법의 수행시간비교
  ① DATA : NETLIB DATA
  ② 실험 도구  
        BU 비영요소 보관방법 : LPLUB32.c unix version
        BU BL 비영요소 보관방법 : LPLUB40.c unix version
  ③ 실험기기
       삼성 workstation
  ④ 결과 분석






III.3  각 기법의 속도비교  실험

 Bartels-Golub법, Forrest-Tomlin법과 Cholesky법을 사용하여 기저행렬을 수정하면, 각 방법에 수반되는 연산 과정이 다르기때문에 문제에따른 효율의 차이가 발생할 수 있다. 그러므로 각 방법에 따라서 문제크기별, 행렬 계수 밀도별로 실행속도 변화를 분석할 필요가 있다. 
 그리고, 각 방법에서 기저행렬계수의  비영요소보관방법과 모든 요소 보관방법의 차이가 실행속도에 미치는 영향도 분석하였다.     






III.3  재역산 시기에 관한 연구 

 L은 eta vector의 형태로 저장,사용됨으로 매 회 그 수가 증가하고 이의 유지,사용이 비능률적이므로 재역산시기는 속도 재고의 중요한 요소이다. 실제, L에 관계한 operation은 자료 행렬의 행크기( NROW )와 밀도( density )에 영향을 받으며, 이를 이용한 재역산시기는 전체 프로그램수행시간에 많은 영향을 미친다. 재역산 시기설정에의해 한 iteration의 수행시간이 증가하는 모형은 다음그림과 같다.                         
** 그림첨가

위의 그림에서도 알수 있듯이, 재역산을 시행하지 않으면, 매 iteration마다 소요시간이 선형이상으로 늘어 난다. 또한, 재역산은 자체 수행시간이 보통 iteration소요시간에 비해 크기 때문에, 이 trade-off관계를 절충할 기준점이 필요하다.  이러한 맥락에서, 몇 편의 논문이 실험적인 결과를 발표 했으나, 널리 공인된 기준이 사용되고 있지는 않고 있다. 이러한, 재역산 기준들은 실험시행이나, 프로그램수행중 매회 수행시간을 보고 기준을 정하는 동적 기준과 주어진 계수행렬의 특성을 이용해 수행전 미리정하는 정적기준으로 나누어 진다. 전자는 후자에 비해 정교하지만 자기 계산 시간을 소비하게되고, 모든 경우를 충족할 수 있는 이론모형의 부재라는 단점이 있다.
 이 논문에서는 후자의 정적모델을 적용하여 매 회  수행시간의 증가에 영향을 가장 크게 끼치는 행 수와  계수행렬의 밀도를 이용한 단순 기준을 사용하여 , 총수행시간을 통해 우수한 기준점을 제시하고자 한다.
   즉,를 재역산 기준으로 놓고, 각각의 경우의 총수행시간을 측정하였다. 
(단, 는 상수,  : 자료 행렬의 행크기
      : 자료 행렬의 밀도 ) 
1) 실험 1 : netlib data의 실험
    **실험결과 첨가

III.4  해수정에 관한 연구 

III.4.1  문제점 분석 과 개선안

기존의 상하 분해형에 사용된 기저 수정 후 해수정방법은, 를 로 분해하여 계산하는 방법이었다. 이를 계산하기 위해서는 매 Iteration마다 Substitution과 eta vector곱을 시행하여야 한다. 이는 상대적으로 시간을 많이 소비하는 작업이다. 그러므로, 이 논문에서는, 상하한이 있는 문제에서 계산된 Min. Ratio 만큼 가감하여 해수정하는 방법을 택하여 매 Iteration마다 Substitution과 eta vector곱을 시행하는것을 지양하는 방법을 제시한다. 
이것은 다음의 두 단계로 나누어 볼수 있다.

SETP 1.   
진입변수를 xs라하고 비율검정에서의 최소 비율을 RMAX라 하자.
1) 진입변수가 하한에 있을경우의 해수정.
          
   

   단,   ; 수정된 진입열 벡터
2) 진입변수가 상한에 있을경우의 해수정.
       

   단,   ; 수정된 진입열 벡터
STEP 2.  eta vector곱
 위의 STEP 1 까지의 계산이 끝나면,
  즉, 의 계산에서 행 Permutation       Operatio이 생략된 값이 된다. 따라서, STEP 1 까지의 계산값에 이번회의 행     의 Permutation Operatio을 행하면 최종 해수정값을 얻을 수 있다. 이의 구
 체적 계산은 다음과 같다.
                     
         

     단, s : 탈락열의 열번호
         m : 행수
        : k행과 k+1행을 바꾸는 permutation matrix
         : step 1 까지의 계산값 행렬

그러나, 실제 step 2의 전산 프로그램 code는 행열을 곱하는 형태가 아니고, B[s]=B[s+1], B[s+1]=B[s+2], ... , B[m-1]=B[m],B[m]=B[s] 의 간단한 형태를 취하고 있다. 
실제, 위의 code는 기존안에 비해 많은 연산 횟수를 줄이는 효과를 나타낸다.


</tdmsfiletext>
